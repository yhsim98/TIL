# 보안 목적
1. 비밀성(confidentiality, secrecy. privacy) 
* 인가된 개인, 단체, 장치, 프로세스만 데이터의 내용을 볼 수 있도록 해주는 서비스

2. 무결성
* 비인가된 데이터의 변경을 발견할 수 있도록 해주는 서비스
* 변조가 된것을 알 수 있도록 한다

비밀성은 보장되어야 하는 서비스지만 무결성은 발견만 할 수 있으면 된다.

3. 인증
* 식별 + 검증
* 누구인지 신원을 증명하는 것
* 메시지 인증 : 무결성과 동일, 메시지가 변경되지는 않았는지 아는 것
* 메시지 원천지 인증 : 무결성 + 메시지가 송신된 위치 또는 송신자를 검증
* 개체 인증 : 주장된 신원을 검증
    * 개체 인증에 사용되는 요소3가지
        * 사용자만 알고 있는 지식 : 패스워드
        * 사용자만의 독특한 특징 : 생체정보
        * 사용자만이 가지고 있는 것 : ID 카드

4. 부인방지(non-repudiation)
* 개체가 지난 행위나 약속을 부인하지 못하도록 하는 서비스
* 송신 부인방지 : NRO
* 전달 부인방지 : NRD
* 제출 부인방지 : NRS
* 수신 부인방지 : NRR

* 토큰의 종류가 중요한 것은 아니다
* 직접 통신하는 경우와 중계자를 이용하여 통신하는 경우가 있다
* 부인방지 토큰은 보통 해당 행위를 부인할 수 있는 주체가 제공하는 것

 
 # 프라이버시
개인이나 집단이 자신 또는 자신의 정보를 선택적으로 노출할 수 있는 권리

디지털 서비스를 사용할 때 교환된 통신 메시지를 통한 노출을 고려한다.

프러이버시 종류
* 내용 프라이버시
    * 어떤 컨텐츠 사용
    * 비밀성 서비스를 통해 제공할 수 있다
* 행동 프라이버시
    * 어떤 서비스를 사용하는 것 자체를 숨김
* 위치 프라이버시
    * gps 막는거


행동 프라이버시 보장을 위한 요구사항
* 불관찰성 : 특정 메시지의 송수자 또는 수신자를 알 수 없어야 한다
* 불연결성 : 두 개의 메시지가 주어졌을 때, 두 개의 메시지가 동일 송신자가 전송한 것인지 또는 두 개의 메시지가 동일 수신자에게 보내는 것인지 연결할 수 없어야 한다는 것을 말함
* 불연결성은 특정 메시지의 불관찰성이 깨졌을 때 그 파급효과를 최소화하기 위해 제공되어야 한다

## 조건부 프라이버시
완전 프라이버시를 제공하면 사용자들에 의해 악용될 수 있기 때문에 대신 조건부 프라이버시를 제공함

필요한 경우 익명성 철회 가능

익명을 철회하는 권한 남용을 피하기 위해 여러 기관에 권한을 분산하는 것이 필요함
* 임계 기반 비밀 공유기법
* n명에게 특정 권한을 분산하고, 이 중에 t명 이상이 동의하면 해당 권한을 수행할 수 있도록 한다
* t는 보안 강도를 조절하기 위한 보안 변수이다
* 가용성 측면에서 (n, n)은 바람직하지 않은 형태의 서비스

# 통신 계층과 암호기술
통신 메시지의 비밀성/무결성을 보장하기 위한 암호기술의 적용과 통신 계층간의 관계

end-to-end
* 장점
    * 통신망과 독립적으로 수행 가능
    * 기반구조를 신뢰하지 않아도 됨
* 단점
    * 트래픽 분석이 가능
    * 메시지 단위로 암호화하기 때문에 오류 발생시 암호화하는 방식에 따라 재전송해야 하는 부분이 클 수 있음

hop-by-hop
* 장점
    * 트래픽 분석이 가능하지 않음
    * 패킷 단위로 암호화가 가능하므로 오류 발생시 해당 패킷만 재전송
* 단점
    * 통신망의 각 호스트/스위치에 기능이 포함되어야 함
    * 기반구조를 신뢰해야 함(중산 호스트/스위치는 평문을 볼 수 있음)
    * 반복적으로 암호기술을 적용하기 때문에 효율성이 떨어짐



기본 용어
* 평문
* 암호문
* 암호화
* 복호화

# 암호알고리즘
* 좁은 의미 : 암호화 복호화 과정에 사용하는 수학 함수
    * 비밀성 서비스 제공이 목적
* 넓은 의미 : 암호 기술에서 사용하는 모든 알고리즘
    * 다양한 목적
* 현대 암호화 함수와 복호화 함수는 모두 키를 사용
    * ``E. K(M) = C, D.K(C) = M
* 암호키(cryptographic key) : 암호화/복호하에 사용하는 키
    * 현대 알고리즘의 안성성은 키에 의존하고, 알고리즘 자체는 공개한다

## 제한적 알고리즘
현대 알고리즘의 안성성은 키에 의존해야 한다

키 대신에 알고리즘의 비밀성에 의존할 경우 **제한적 알고리즘**이라 한다.

제한적 알고리즘
* 장점
    * 해독하기가 힘듦
* 단점
    * 알고리즘을 공유할 수 없음
    * 역공학의 가능성이 존재함
    * 노출될 경우에는 알고리즘 자체를 변경해야 함

키 의존 알고리즘
* 장점
    * 알고리즘 공유가 가능
    * 키가 노출되면 키 자체만 변경 가능
    * 알고리즘이 공개되어 있으므로 허점의 발견이 용이함
        * 알고리즘 개선에 사용
* 단점
    * 알고리즘이 공개되어 있으므로 허점의 발견의 용이함
    * 악의적인 목적으로 사용 가능

## 키용어
사용 기간 또는 횟수에 의한 분류
* 단기간키, 세션키, 일회용키
    * 매우 제한적으로 사용하는 키
    * 생성 후 일시적으로 사용 후 폐기하는 키
    * 비휘발성 메모리에 유지할 필요가 없는 키
* 장기간키, 다중사용키
    * 여러 번 사용하는 키로 비휘발성 메모리에 유지해야 하며, 안전한 키 관리가 중요함

## 암호 알고리즘의 분류
결정적 vs 확률적
* 결정적 알고리즘 : 입력이 같으면 항상 같은 결과를 반환
* 확률적 알고리즘 : 같은 입력이라도 결과가 항상 다름

대칭 vs 비대칭
* 대칭 알고리즘 : 암호화할 때 사용하는 암호키와 복호화할 때 사용하는 암호키가 같은 암호알고리즘
* 비대칭 암호알고리즘 : 암호화할 때 사용하는 암호키가 복호화할 때 사용하는 암호키가 다른 암호알고리즘


## 대칭 암호 알고리즘
* 비밀키 알고리즘
* 암호화하는 사람과 복호화하는 사람이 같은 키를 가지고 있어야 함
* 종류
    * 스트림(stream) 암호방식 : 평문의 각 바이트를 하나씩 암호화하는 방식
    * 블록(block) 암호방식 : 평문을 일정한 블록 크기로 나누어, 각블록을 암호화 하는 방식

## 합성 암호 알고리즘

# 암호화 모드
블록 암호방식을 사용하는 대칭 알고리즘은 항상 고정된 크기의 블록을 입력으로 사용함

블록방식은 항상 입력의 크기가 같기 때문에 입력의 크기가 부족하면 평문을 블록크기로 만들기 위한 **채우기**가 필요하고 크면 나누어야 한다

* 암호화 모드 : 블록 암호방식에서 블록 크기보다 큰 평문을 암호화하는 방법을 말함

가장 단순한 암호화 모드는 나누어진 개별 평문 블록들을 독립적으로 암호화하는 ECB, 지금은 안씀

## 대칭 암호알고리즘의 사용 용도
* 공개 채널로 전달하는 메시지에 대한 비밀성 보장
    * 송수산자가 공유하는 비밀키로 메시지를 암호화하여 교환함으로써 제 3자가 도청하여도 내용을 알 수 없게 한다
* 기억장치에 저장하는 데이터에 대한 비밀성 보장 
    * 다른 사용자가 저장된 데이터를 열람할 수 없도록 데이터를 암호화하여 저장할 수 있음. 키의 백업이 중요하다(랜섬웨어)
* 개체 인증
    * 서로가 비밀키를 공유하고 있는 경우 서로가 서로임을 확신할 수 있음


## 법 강화를 위한 키 위탁
키 위탁은 키를 복구하기 위해서도 유용하게 사용될 수 있음

# 비대칭 알고리즘
공개키와 비밀키를 사용

각 사용자는 공개키는 공개하고 개인키는 비밀스럽게 유지함

공개키 알고리즘이라고도 한다.

## 사용용도
대칭 알고리즘과 같은 용도로 사용 가능하지만, 상대적 성능문제 때문에 보통 메시지 자체를 암호화하는데 사용되지 않는다.

이 때문에 다음과 같은 하이브리드 방식을 많이 사용함
* {M}.k, {K}.+Ka
* 공개키는 작은 정보만 암호화, 나머지는 개인키로

# 인증서
공개키를 인증할 때 사용되는 전자문서

신뢰할 수 있는 인증기관이 전자서명하여 생성함

인증기관이 공개키를 공증해 준다

## 인증서의 검증
사용자들은 다른 사용자의 공개키를 사용하기 전 인증서를 검증하여 공개키의 사용자를 확인해야 함

인증서를 검증하기 위한 절차
1. 인증서의 서명 확인
2. 인증서의 유효기간 확인
3. 인증서의 사용 용도 확인
4. 인증서의 폐지 여부

위 4가지 단계를 통해 한 번 확인된 인증서는 보통 캐시(또는 파일 시스템)에 보관하며, 이 인증서를 같은 용도로 다시 사용할 경우 유효기간과 폐지기간만 확인함


## 인증서 폐지


# 신원기반 암호시스템
* 공개키 암호알고리즘의 사용에서 공개키의 인증은 매우 중요함
* 인증서를 사용하기 위해서는 공개키 기반구조가 잘 확립되어 있어야 한다
* 인증서 외에 **신원기반 공개키 암호시스템**
* 결국 안씀

* 상대방의 독특한 신원정보로부터 공개키를 유도
* 인증서가 필요없고 다른 사용자의 공개키를 직접 생성 가능

## PKG
* 사용자는 자신의 개인키를 직접 만들 수 있음
    * 자신 뿐만 아니라 다른 사용자의 개인키도 생성 가능
* 이 때문에 신원기반 시스템에서는 사용자의 개인키를 발급하여 주는 PKG라는 신뢰 기관을 사용한다
* 사용자의 개인키는 누구나 생성할 수 있는 해당 사용자의 공개키와 PKG가 비밀로 유지하는 마스터키를 이용하여 생성한다
* PKG는 모든 사용자의 개인키를 만들 수 있으므로 모든 암호문을 복호화할 수 있고, 모든 사용자의 서명을 위조할 수 있다
    * 부인 방지에 취약하다
    * 임계 기반 비밀 공유 기법 활용
        * 여러 기관에 발급 권한을 분배하여 n명중 t명 이상이 협조해야 사용자의 개인키 생성 가능

## 사용자의 신원정보
공개키를 변경하고 싶다면, 신원정보나 PKG의 개인키를 변경해야 함

둘 다 힘듬

이 문제를 해결하기 위해 추가적인 값을 추가한다

대신 추가된 정보를 알아야 상대방의 공개키를 만들 수 있다는 문제가 생긴다


## 중앙집중 인증서 기반 PKI vs 신원기반


## DPKI
* 탈중앙 PKI
    * 중앙집중 인증기관이 인증서를 발급하는 것이 아님
    * 각 개체가 스스로 인증서를 발급하고 관리하는 형태
        * 기존 pki의 ca에 관한 집중 문제를 해결하는 것이 목적
        * 단일 실패점이 사라짐
* 동작 원리
    * 블록체인에 일정한 형식을 갖춘 ID와 공개키를 연결하는 문서를 저장
    * 블록체인이 기존 PKI에서 공개 디렉토리 역할을 한다
    * ID와 실제 개체와의 연결은 다른 방법을 사용
        * 보통 신뢰관계를 점진적으로 확장하는 방법 사용
            * 오프라인에서 서로 교환, 기관 홈페이지에 기관 ID 게시 등

* 블록체인의 특징
    * 불가역성 : 수정, 삭제 불가 삽입만 가능
    * 분산 저장
    * 합의 기술을 이용하여 일관성 유지

