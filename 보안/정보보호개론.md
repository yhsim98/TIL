# 보안 목적
1. 비밀성(confidentiality, secrecy. privacy) 
* 인가된 개인, 단체, 장치, 프로세스만 데이터의 내용을 볼 수 있도록 해주는 서비스

2. 무결성
* 비인가된 데이터의 변경을 발견할 수 있도록 해주는 서비스
* 변조가 된것을 알 수 있도록 한다

비밀성은 보장되어야 하는 서비스지만 무결성은 발견만 할 수 있으면 된다.

3. 인증
* 식별 + 검증
* 누구인지 신원을 증명하는 것
* 메시지 인증 : 무결성과 동일, 메시지가 변경되지는 않았는지 아는 것
* 메시지 원천지 인증 : 무결성 + 메시지가 송신된 위치 또는 송신자를 검증
* 개체 인증 : 주장된 신원을 검증
    * 개체 인증에 사용되는 요소3가지
        * 사용자만 알고 있는 지식 : 패스워드
        * 사용자만의 독특한 특징 : 생체정보
        * 사용자만이 가지고 있는 것 : ID 카드

4. 부인방지(non-repudiation)
* 개체가 지난 행위나 약속을 부인하지 못하도록 하는 서비스
* 송신 부인방지 : NRO
* 전달 부인방지 : NRD
* 제출 부인방지 : NRS
* 수신 부인방지 : NRR

* 토큰의 종류가 중요한 것은 아니다
* 직접 통신하는 경우와 중계자를 이용하여 통신하는 경우가 있다
* 부인방지 토큰은 보통 해당 행위를 부인할 수 있는 주체가 제공하는 것

 
 # 프라이버시
개인이나 집단이 자신 또는 자신의 정보를 선택적으로 노출할 수 있는 권리

디지털 서비스를 사용할 때 교환된 통신 메시지를 통한 노출을 고려한다.

프러이버시 종류
* 내용 프라이버시
    * 어떤 컨텐츠 사용
    * 비밀성 서비스를 통해 제공할 수 있다
* 행동 프라이버시
    * 어떤 서비스를 사용하는 것 자체를 숨김
* 위치 프라이버시
    * gps 막는거


행동 프라이버시 보장을 위한 요구사항
* 불관찰성 : 특정 메시지의 송수자 또는 수신자를 알 수 없어야 한다
* 불연결성 : 두 개의 메시지가 주어졌을 때, 두 개의 메시지가 동일 송신자가 전송한 것인지 또는 두 개의 메시지가 동일 수신자에게 보내는 것인지 연결할 수 없어야 한다는 것을 말함
* 불연결성은 특정 메시지의 불관찰성이 깨졌을 때 그 파급효과를 최소화하기 위해 제공되어야 한다

## 조건부 프라이버시
완전 프라이버시를 제공하면 사용자들에 의해 악용될 수 있기 때문에 대신 조건부 프라이버시를 제공함

필요한 경우 익명성 철회 가능

익명을 철회하는 권한 남용을 피하기 위해 여러 기관에 권한을 분산하는 것이 필요함
* 임계 기반 비밀 공유기법
* n명에게 특정 권한을 분산하고, 이 중에 t명 이상이 동의하면 해당 권한을 수행할 수 있도록 한다
* t는 보안 강도를 조절하기 위한 보안 변수이다
* 가용성 측면에서 (n, n)은 바람직하지 않은 형태의 서비스

# 통신 계층과 암호기술
통신 메시지의 비밀성/무결성을 보장하기 위한 암호기술의 적용과 통신 계층간의 관계

end-to-end
* 장점
    * 통신망과 독립적으로 수행 가능
    * 기반구조를 신뢰하지 않아도 됨
* 단점
    * 트래픽 분석이 가능
    * 메시지 단위로 암호화하기 때문에 오류 발생시 암호화하는 방식에 따라 재전송해야 하는 부분이 클 수 있음

hop-by-hop
* 장점
    * 트래픽 분석이 가능하지 않음
    * 패킷 단위로 암호화가 가능하므로 오류 발생시 해당 패킷만 재전송
* 단점
    * 통신망의 각 호스트/스위치에 기능이 포함되어야 함
    * 기반구조를 신뢰해야 함(중산 호스트/스위치는 평문을 볼 수 있음)
    * 반복적으로 암호기술을 적용하기 때문에 효율성이 떨어짐



기본 용어
* 평문
* 암호문
* 암호화
* 복호화

# 암호알고리즘
* 좁은 의미 : 암호화 복호화 과정에 사용하는 수학 함수
    * 비밀성 서비스 제공이 목적
* 넓은 의미 : 암호 기술에서 사용하는 모든 알고리즘
    * 다양한 목적
* 현대 암호화 함수와 복호화 함수는 모두 키를 사용
    * ``E. K(M) = C, D.K(C) = M
* 암호키(cryptographic key) : 암호화/복호하에 사용하는 키
    * 현대 알고리즘의 안성성은 키에 의존하고, 알고리즘 자체는 공개한다

## 제한적 알고리즘
현대 알고리즘의 안성성은 키에 의존해야 한다

키 대신에 알고리즘의 비밀성에 의존할 경우 **제한적 알고리즘**이라 한다.

제한적 알고리즘
* 장점
    * 해독하기가 힘듦
* 단점
    * 알고리즘을 공유할 수 없음
    * 역공학의 가능성이 존재함
    * 노출될 경우에는 알고리즘 자체를 변경해야 함

키 의존 알고리즘
* 장점
    * 알고리즘 공유가 가능
    * 키가 노출되면 키 자체만 변경 가능
    * 알고리즘이 공개되어 있으므로 허점의 발견이 용이함
        * 알고리즘 개선에 사용
* 단점
    * 알고리즘이 공개되어 있으므로 허점의 발견의 용이함
    * 악의적인 목적으로 사용 가능

## 키용어
사용 기간 또는 횟수에 의한 분류
* 단기간키, 세션키, 일회용키
    * 매우 제한적으로 사용하는 키
    * 생성 후 일시적으로 사용 후 폐기하는 키
    * 비휘발성 메모리에 유지할 필요가 없는 키
* 장기간키, 다중사용키
    * 여러 번 사용하는 키로 비휘발성 메모리에 유지해야 하며, 안전한 키 관리가 중요함

## 암호 알고리즘의 분류
결정적 vs 확률적
* 결정적 알고리즘 : 입력이 같으면 항상 같은 결과를 반환
* 확률적 알고리즘 : 같은 입력이라도 결과가 항상 다름

대칭 vs 비대칭
* 대칭 알고리즘 : 암호화할 때 사용하는 암호키와 복호화할 때 사용하는 암호키가 같은 암호알고리즘
* 비대칭 암호알고리즘 : 암호화할 때 사용하는 암호키가 복호화할 때 사용하는 암호키가 다른 암호알고리즘


## 대칭 암호 알고리즘
* 비밀키 알고리즘
* 암호화하는 사람과 복호화하는 사람이 같은 키를 가지고 있어야 함
* 종류
    * 스트림(stream) 암호방식 : 평문의 각 바이트를 하나씩 암호화하는 방식
    * 블록(block) 암호방식 : 평문을 일정한 블록 크기로 나누어, 각블록을 암호화 하는 방식

## 합성 암호 알고리즘

# 암호화 모드
블록 암호방식을 사용하는 대칭 알고리즘은 항상 고정된 크기의 블록을 입력으로 사용함

블록방식은 항상 입력의 크기가 같기 때문에 입력의 크기가 부족하면 평문을 블록크기로 만들기 위한 **채우기**가 필요하고 크면 나누어야 한다

* 암호화 모드 : 블록 암호방식에서 블록 크기보다 큰 평문을 암호화하는 방법을 말함

가장 단순한 암호화 모드는 나누어진 개별 평문 블록들을 독립적으로 암호화하는 ECB, 지금은 안씀

## 대칭 암호알고리즘의 사용 용도
* 공개 채널로 전달하는 메시지에 대한 비밀성 보장
    * 송수산자가 공유하는 비밀키로 메시지를 암호화하여 교환함으로써 제 3자가 도청하여도 내용을 알 수 없게 한다
* 기억장치에 저장하는 데이터에 대한 비밀성 보장 
    * 다른 사용자가 저장된 데이터를 열람할 수 없도록 데이터를 암호화하여 저장할 수 있음. 키의 백업이 중요하다(랜섬웨어)
* 개체 인증
    * 서로가 비밀키를 공유하고 있는 경우 서로가 서로임을 확신할 수 있음


## 법 강화를 위한 키 위탁
키 위탁은 키를 복구하기 위해서도 유용하게 사용될 수 있음

# 비대칭 알고리즘
공개키와 비밀키를 사용

각 사용자는 공개키는 공개하고 개인키는 비밀스럽게 유지함

공개키 알고리즘이라고도 한다.

## 사용용도
대칭 알고리즘과 같은 용도로 사용 가능하지만, 상대적 성능문제 때문에 보통 메시지 자체를 암호화하는데 사용되지 않는다.

이 때문에 다음과 같은 하이브리드 방식을 많이 사용함
* {M}.k, {K}.+Ka
* 공개키는 작은 정보만 암호화, 나머지는 개인키로

# 인증서
공개키를 인증할 때 사용되는 전자문서

신뢰할 수 있는 인증기관이 전자서명하여 생성함

인증기관이 공개키를 공증해 준다

## 인증서의 검증
사용자들은 다른 사용자의 공개키를 사용하기 전 인증서를 검증하여 공개키의 사용자를 확인해야 함

인증서를 검증하기 위한 절차
1. 인증서의 서명 확인
2. 인증서의 유효기간 확인
3. 인증서의 사용 용도 확인
4. 인증서의 폐지 여부

위 4가지 단계를 통해 한 번 확인된 인증서는 보통 캐시(또는 파일 시스템)에 보관하며, 이 인증서를 같은 용도로 다시 사용할 경우 유효기간과 폐지기간만 확인함


## 인증서 폐지


# 신원기반 암호시스템
* 공개키 암호알고리즘의 사용에서 공개키의 인증은 매우 중요함
* 인증서를 사용하기 위해서는 공개키 기반구조가 잘 확립되어 있어야 한다
* 인증서 외에 **신원기반 공개키 암호시스템**
* 결국 안씀

* 상대방의 독특한 신원정보로부터 공개키를 유도
* 인증서가 필요없고 다른 사용자의 공개키를 직접 생성 가능

## PKG
* 사용자는 자신의 개인키를 직접 만들 수 있음
    * 자신 뿐만 아니라 다른 사용자의 개인키도 생성 가능
* 이 때문에 신원기반 시스템에서는 사용자의 개인키를 발급하여 주는 PKG라는 신뢰 기관을 사용한다
* 사용자의 개인키는 누구나 생성할 수 있는 해당 사용자의 공개키와 PKG가 비밀로 유지하는 마스터키를 이용하여 생성한다
* PKG는 모든 사용자의 개인키를 만들 수 있으므로 모든 암호문을 복호화할 수 있고, 모든 사용자의 서명을 위조할 수 있다
    * 부인 방지에 취약하다
    * 임계 기반 비밀 공유 기법 활용
        * 여러 기관에 발급 권한을 분배하여 n명중 t명 이상이 협조해야 사용자의 개인키 생성 가능

## 사용자의 신원정보
공개키를 변경하고 싶다면, 신원정보나 PKG의 개인키를 변경해야 함

둘 다 힘듬

이 문제를 해결하기 위해 추가적인 값을 추가한다

대신 추가된 정보를 알아야 상대방의 공개키를 만들 수 있다는 문제가 생긴다


## 중앙집중 인증서 기반 PKI vs 신원기반


## DPKI
* 탈중앙 PKI
    * 중앙집중 인증기관이 인증서를 발급하는 것이 아님
    * 각 개체가 스스로 인증서를 발급하고 관리하는 형태
        * 기존 pki의 ca에 관한 집중 문제를 해결하는 것이 목적
        * 단일 실패점이 사라짐
* 동작 원리
    * 블록체인에 일정한 형식을 갖춘 ID와 공개키를 연결하는 문서를 저장
    * 블록체인이 기존 PKI에서 공개 디렉토리 역할을 한다
    * ID와 실제 개체와의 연결은 다른 방법을 사용
        * 보통 신뢰관계를 점진적으로 확장하는 방법 사용
            * 오프라인에서 서로 교환, 기관 홈페이지에 기관 ID 게시 등

* 블록체인의 특징
    * 불가역성 : 수정, 삭제 불가 삽입만 가능
    * 분산 저장
    * 합의 기술을 이용하여 일관성 유지

# FIDO
Fast Identity Online 지문 인증, 공개키 방식이다.

동작과정은
1. 공개키를 생성하여 서버에 등록한다.
2. 


# 해시함수
임의의 길이에 이진 문자열을 고정된 길이의 이진 문자열로 매핑하여 주는 결정적 함수 

특징
* 압축
* 계산의 용이성
    * x -> f(x) 는 편해야 함
* 일방향성
    * 입력을 모르는 해시값 y가 주어지면 ``H(x`) = H(x)`` 인 x`은 찾기 어려워야 함
* 약한 충돌회피성
    * x가 있을 때 H(x`) = H(x) 인 x를 찾는 것은 어려워야 함
    * x랑 해시값 같은 x` 값 찾기 어려워야 함
    * 같은 값이 나올 확률은 1/2????
* 강한 충돌회피성
    * H(x`) = H(x) 인 서로 다른 임의의 두 입력 x을 찾는 것은 어려워야 함
    * 해시값이 같은 두 값을 찾기 어려워야 함
  
## 생일 파라독스
N 명중 특정 사람 한명과 생일이 같은 사람을 찾기 위해서는 n 이 183명이 되야 하지만, n명중 생일 같은 두 사람을 찾으려면 23명만 있으면 된다

루트 씌우면 됨

## 해시함수의 용도
* 전자서명
    * 서명 크기와 계산 비용을 줄이기 위해 전체 메시지 대신에 메시지의 해시값에 서명함
    * 충돌 회피성이 그래서 중요함
 
 # MAC
* 해시함수는 보통 비밀키를 사용하지 않음
    * 단순히 메시지의 변경 여부를 판단하기 위해 사용하는 해시값을 조작 탐지 코드라 한다
* 비밀키를 추가로 사용하면 송신자의 인증과 무결성을 동시에 제공할 수 있으며, 결과 값을 메시지 인증 코드(MAC)라 한다
    * MAC을 사용하기 위해서는 생성자와 확인하는 사람이 동일한 **대칭키**를 공유하고 있어야 함
* MAC도 해시함수와 같은 요구사항을 충족해야 하며, 추가로 위조가 가능하지 않아야 한다
* MAC을 만드는 방법
    * MAC 전용 알고리즘을 이용하는 방법
    * 대칭 알고리즘을 이용하는 방법

# 무결성
메시지가 변조되지 않았다는 것을 확인하는 것

메시지랑 해시값을 전부 바꾸면 수신자는 변경사실을 알 수 없음

* 해결법 1. MAC
    * MAC값을 알아야 하기 때문에 변조 못함
    * 키를 사전에 공유해야 한다는 문제점
    * 같은 키가 여러개니 누가 만들었는지는 모른다
* 해결법 2. 전자 서명
    * 값이 바뀌면 전자서명이 유효하지 않아 변조하면 알 수 있다
    * 공개키만 수신자가 있으면 되므로 누구나 확인 가능
    * 누구나 만들수는 없다
    * 효율은 mac이 좋다

# 무결성과 비밀성을 동시에
* 인증 암호화 : 비밀성과 무결성을 동시에 제공하는 방법

1. 암호화할 때 해시값 또는 MAC값을 포함하는 방법
2. 메시지에 독립적으로 대칭암호알고리즘과 MAC을 적용하는 방법
    * JWT
    * 메시지는 알 수 있다
    * 무결성만 확인
3. 메시지를 암호화한 후 암호문에 대한 MAC 값을 계산하는 방법
    * encrypt-then-mac 
    * mac 값이 확인되지 않으면 복호화를 하지 않음
    * 암호화하고 암호문을 MAC 
    * 나머지는 복호화를 무조건 해야하지만 얘는 아님
    * 가장 안전

# 일반 서명과 전자서명의 차이점
* 전자서명은 수학적으로 서명자를 검증할 수 있음
* 전자서명의 안전성은 동일한 알고리즘을 사용할 경우에는 사용자마다 같은 안전성을 제공함
* 일반 서명은 문서 위에 하지만 전자서명은 보통 문서와 별도로 존재함
* 전자서명은 원본과 복사본을 구분하기가 힘듦


## 전자서명의 요구사항
* 인증(authntic) : 누가 서명했는지 확인이 가능해야 함
* 위조불가 : 위조불가
* 부인방지 : 나중에 부인할 수 없어야 함
* 재사용불가 : 서명은 다른 용도로 사용할 수 없어야 함
* 변경불가 : 서명된 문서의 내용을 변경할 수 없어야 함


# 전자서명 방식의 종류
* 직접 서명 방식 : 서명자가 홀로 서명 알고리즘을 수행하여 서명하는 방식
* 문제점. 서명키의 분실/도난
    * 서명자가 직접 서명 시간을 서명에 포함할 경우에는 서명키를 획득한 공격자의 부정을 증명할 방법이 없음
* 중재 서명 방식 : 중재자와 프로토콜을 수행하여 서명하는 방식
    * 중재자는 서명의 증인 역할을 하게 됨
    * 서명자가 시간에 대한 부정을 할 수 없음
    * 중재자는 신뢰기관이어야 함

# 전자서명 알고리즘의 분류
메시지 복구 여부에 따른 분류
* 메시지 복구 가능 전자서명 알고리즘
    * 작은 메시지에 대해서만 가능
* 첨부 형태 전자서명 알고리즘
    * 메시지와 서명 블록이 별도로 존재하며, 메시지와 서명 블록이 함께 제시되어야 검증 가능
    * 보통 해시함수를 이용함

결정 vs 확률 서명 알고리즘
* 결정 서명 알고리즘 : 메시지가 같으면 항상 결과 서명이 같은 알고리즘
* 확률 서명 알고리즘 : 메시지가 같아도 서명할 때마다 그 결과가 달라지는 알고리즘


# 암호알고리즘에 대한 안정성
* 암호알고리즘 : 복호하키를 모르는 상태에서 암호문으로부터 평문이나 키를 얻을 수 없어야 한다
    * 평문이나 키의 일부도 얻을 수 없어야 한다
    * 공개키 암호알고리즘은 공개키로부터 개인키를 얻을 수 없어야 한다

* 해시함수 : 해시값의 역이나 충돌을 찾을 수 없어야 한다
등등

# 현대 암호학의 특징
* 과거에는 오랫동안 허점이 발견되지 않은 것을 안전한 것으로 여긴다
* 오늘날에는 엄격한 안정성 증명을 중요하게 생각함

* 무조건적 안정성 : 무한한 컴퓨터 자원을 가져도 암호알고리즘을 해독할 수 없는 경우
* 계산적 안정성 : 공격자의 능력이 현실적일때 해독하기 위한 노력이 불합리하게 많은 컴퓨터 시간을 요구할 경우
    * 증명가능 안정성 : 어렵다고 알려진 문제와 등가임을 증명함

## 완벽한 안정성 vs 의미론적 안정성
완벽한 안정성은 현장에서는 사용 불가

계산적 안정성만 있어도 현장에서 사용 가능하다

이 때문에 등장한 개념이 의미론적 안정성

## 암호해독 공격의 분류
* 전사 공격 : 가능한 모든 키를 검사하는 방법
    * 암호해독 공격은 아님
* 암호문 단독 공격
    * 공격자가 암호문만 얻을 수 있는 경우
* 기지 평문 공격
    * 공격자가 특정한 개수의 평문과 암호문 쌍만을 얻을 수 있음
* 선택 평문 공격
    * 특정한 개수의 평문과 암호문 쌍을 얻을 수 있지만 공격자는 원하는 평문을 선택할 수 있음
* 선택 암호문 공격
    * 원하는 암호문
* 적응적 선택 평문 공격 
    * 이전에 얻은 쌍들을 바탕으로 추가적으로 원하는 평문을 얻을 수 있음
* 적응적 선택 암호문 공격 
    * 이전에 얻은 쌍들을 바탕으로 추가적으로 원하는 암호문을 선택할 수 있ㅇ듬



## 공격의 복잡성 척도
* 데이터 복잡성 : 공격이 성공하기 위해 필요한 데이터의 양
    * 공격에 성공하기 위해 필요한 평문/암호문 쌍
* 처리 복잡성 : 공격이 성공하기 위해 필요한 시간
    * 병렬처리 가능 여부
* 저장공간 요구사항 : 공격하기 위해 필요한 메모리 공간

## 알고리즘에 대한 공격 결과
* 완전 성공 : 암호키 발견
* 광역 성공 : 암호키를 발견하지 못했지만 복호하할 수 있는 알고리즘 발견
* 인스턴스 성공 : 어떤 암호문으로부터 그것의 평문을 얻어냄
* 정보 추출 : 암호문으로부터 평문의 일부나 암호문의 일부를 알아냄

## 부채널 공격
부채널 : 알고리즘의 입력과 출력 외에 다른 정보를 이용하는 것

암호화에 걸리는 시간이나 걸리는 전력양 계산

## 양자컴퓨팅과 암호기술
* 아직 현실화되지는 않음


# 암호프로토콜
## 프로토콜
어떤 목적을 달성하기 위해 2명 이상이 참여하는 유한한 일련의 단계

프로토콜의 특성
* 사전에 서로 알아야 함
* 참여자 간에 동의하고 있어야 함
* 모호하지 않아야 함
* 완정성 : 완전해야 함

프로토콜 : 어떤 목적을 달성하기 위해 2명 이상이 참여하는 유한한 일련의 단계

트랜스크립트 : 한 수행에서 교환된 메시지들

암호 프로토콜 : 암호 기술을 사용하는 프로토콜

일반 프로토콜과의 차이점 : 공격자의 존재를 가정하고 만든다

일반 프로토콜 : 완전성

암호프로토콜 : 완정성 + 안정성


## 암호프로토콜에 대한 공격
공격의 종류
* 수동 공격 : 프로토콜의 진행을 방해하지 않는 공격
* 능동 공격 : 프로토콜의 진행에 개입하는 공격

공격 방어의 기본은 공격 사실을 인지하는 것

## 프로토콜의 참여자
실제 사용자를 의미할 수 있고, 사용자가 사용하는 장치 또는 소프트웨어일 수 있음

참여자의 분류
* 일반 참여자
    * 프토콜을 통해 얻고자 하는 것이 있는 이해 당사자
* 제 3기관
    * 프로토콜의 실행 결과에 대한 어떤 이해 관계가 없고, 어떤 참여자와도 특별한 협력 관계가 없지만 원할한 프로토콜의 수행을 위해 참여하는 참여자
    * 신뢰 : 프로토콜이 정한 규칙대로 프로토콜을 수행함
    * 부정행위를 하지 않는다는 것은 아님
    * 다른 말로 중재자
* 암호프로토콜에서는 항상 공격자의 존재를 가정함

## TTP의 종류
* 인라인 TTP : 프로토콜의 모든 과정에 참여
    * 모든 메시지는 항상 TTP를 경유함
* 온라인 TTP : 프토코로의 일부 과정에서는 항상 참여
* 오프라인 TTP : 실제 프로토콜 수행과정에서 참여하지 않지만 사전에 또는 사후에 필요에 따라 참여


## 암호프로토콜의 분류
* 자체 강화 프로토콜
    * 중재자가 필요 없는 프로토콜
* 중재 프로토콜
    * 중재자가 프로토콜에 항상 참여
* 판결 프로토콜
    * 분쟁이 발생한 경우에만 판결자가 참여
    * 프로토콜은 분쟁을 해결할 수 있도록 증거를 남겨야 함
    * 중재자는 증거를 검사하여 분쟁을 명확히 해결할 수 있어야 함

신뢰하는 제 3의 중재자를 사용할 경우 발생할 수 있는 문제
* 프로토콜 자체가 수행불가
    * 이 문제를 단일 실패점이라 한다
* 중재자의 신뢰성 문제
* 중재자를 유지하고 관리하는 추가 비용 소요
* 추가적인 통신 지연
* 모든 프로토콜 수행에 관여하여야 하므로 병목현상 발생 가능


## 암호프로토콜 설계 절차
* 설계 순서
    * 달성 목적을 포함한 프로토콜의 정의
        * 환경, 참여자, 사용 장치 등등
    * 요구사항 분석
        * 목적, 요구사항
    * 가정 분석
        * 참여자 가정 : 참여빈도, 신뢰관계
        * 환경에 대한 가정 : 네트워크, 장치, 이동성
        * 공격자에 대한 가정 : 공모 공격 포함
    * 설계
    * 증명 : 요구사항이 충족됨을 증명해야 함
    * 구현
        * 소프트웨어 구현 결과에 대한 검증이 반드시 필요함

* 참여자에 대한 가정
    * 보통 일반 참여자들은 서로를 신뢰하지 않음
    * 신뢰 서버는 보통 서버가 수행해야 하는 모든 기능에 대해 신뢰 있게 행동한다고 가정함
* 공격자에 대한 가정
    * 가정 1. 프로토콜을 통해 교화되는 모든 메시지를 확보할 수 있음
    * 가정 2. 진행을 방해 가능, 메시지 변경 삽입 차단 등등
    * 가정 3. 정상적 참여자가 아닐 수 있다
    * 가정 4. 오래된 세션키는 공격자에게 노출 가능
    * 가정 5. 공모 공격을 할 수 있음


## 키 확립 프로토콜
두 사용자가 대칭 암호 알고리즘을 사용하여 원격에서 메시지를 비밀스럽게 교환하기 위한 전제조건은? 동일 대칭키의 공유

* 키 확립 프로노콜 : 둘 이상의 참여자 간의 비밀키를 공유할 수 있도록 해주는 암호프로토콜

* 키 확립 프로토콜을 통해 얻어지는 비밀키는 단일 세션에 사용하기 위한 세션키이다
    * 한번 쓰면 사라짐



# 블록 방식의 대칭 암호알고리즘의 특성
블록 암호방식 : 정해진 크기의 입력 입력과 같은 크기의 출력
* 평문이 블록크기보다 작으면 채우기가 필요하다, 크면 암호화 모드

단일블록크기의 서로 다른 메시지 M과 M`의 암호화

    E.K(M) = C, E.K(M`) = C`

C와 C`, M도 서로 어떤 상관관계도 없음

서로를 가지고 어떤 예측도 불가능


## 키 확립 프로토콜
두 사용자가 대칭 알고리즘을 통해 원격에서 메시지를 비밀스럽게 교환하기 위해서는 동일 대칭키의 공유가 필요하다

키 확립 프로토콜 : 둘 이상의 참여자 간의 비밀키를 공유할 수 있도록 해주는 암호 프로토콜

프로토콜을 통해 얻어지는 키는 세션키

세션키를 사용하는 이유
* 같은 키로 암호화된 암호문을 제한
* 키가 노출되었을 때 누설되는 정보의 양을 제한
* 키 저장에 관한 안전성 문제를 해결
* 세션 간 또는 응용프로그램 간의 독립성 제공

## 키 확립 프로토콜의 요구사항
1. 참여자는 의도한 다른 참여자들과 사용할 수 있는 새로운 키를 얻어야함
    * 의도한 참여자
        * 키의 용도를 확인할 수 있어야 함
            * 누구와 사용하기 위한 키인지
        * 참여자의 인증이 필요할 수 있음
            * 키 생성자 인증
                * 키를 누가 생성하였는지, 누가 보냈는지 확인할 수 있어야 함
                * 키를 인증서버가 대신 생성해 줄텐데 인증서버가 발급한 키가 밎는지 확인할 수 있어야 한다
    * 키 확인
        * 다른 참여자도 나와 같은 키를 가지고 있다는 것을 확인할 수 있어야 함
        * 참여상대에 대한 인증이 필요할 수 있음
    * 키의 최근성
        * 키가 최근에 생성되었다는 것을 확인할 수 있어야 함

2. 새로운 키는 의도된 참여자 외에 다른 참여자들은 얻을 수 없어야 함
    * 키의 비밀성이라 한다
    * 사실 키의 인증을 도와주는 서버는 알 수 있다

### 키 교환 시도
중재 서버를 사용하는 키 전송 프로토콜

문제점
* 공격자는 도청하여 세션키를 얻을 수 있음
* Alice와 Bob은 K가 둘 간 공유하기 위해 생성된 키인지 알 수 없음
    * 키의 용도
* 최근성도 알 수 없음
* K를 중재 서버가 생성하였다는 것을 확인할 수 없음
    * 생성 주체에 대한 인증 기능이 없음
* 서로 같은 키를 가지고 있는지 확인 할 수 없음


### 키 교환 시도 2
서버와 사용자들이 사전에 키를 공유

해당 키로 각자 암호화하여 A에게 전송

A가 B의 키를 B로 전송

키의 비밀성만 보장된다.

키를 누가 생성했는지 유효기간은 아직 남았는지 알 수 없다

시도 2에 대한 공격
* A에서 B로 키를 보낼 때 중간에서 C가 탈취 가능
* 키와 같이 통신 상대방에 대한 정보를 보내는데 이것을 변경 가능하다

공격2
* A가 서버로 키를 요청할 경우 C가 중간에 탈취
* 서버는 A와 C가 통신하는 데 필요한 키로 착각 
* A는 AC 를 AB로 착각함

공격3
* 이미 유효기간이 지난 키를 전송

## 시도 3
키와 키의 주인을 나타내는 값을 같이 암호화

암호문에 식별자까지 포함시킨다 이것을 **naming 기법**이라 한다.

암호문내에 식별자가 들어있으니 중간에 탈취하여 사용자를 변경하는 것이 불가능하다

근데 아직 유효기간은 안넣음

그리고 BCP의 한계로 안됨

암호화를 블록 단위로 진행하는데 블록 순서를 주무를 수 있다

그래서 무결성을 보장해 줘야 한다 그래서 인증 암호화가 필요하다

## 시도 4
랜덤 수 Na를 넣는다

이제 풀어서 볼 수 없고 조작도 하면 알 수 있다

1. A가 서버로 A, B, Na 보냄
2. 서버가 A용 B용 키 반환
3. A가 B에게 사용할 키 전송
4. B는 키 확인 후 해당 키가 맞는지 A에게 확인 요청
5. A는 확인하여 반환

## 시도 5
둘 중 하나가 자기 N 다른 애한테 전송

받은 애는 자기 N까지 같이 서버에 전송하여 키를 받는다

N은 통신할 때 생성함으로 N을 갖고있다는 것은 최근에 생성한 토큰


## 암호화의 용도
* 비밀성을 보장하기 위해 사용
    * 누가 복호화할 수 있는지가 중요하다
    * Ka 면 a만 복호화
    

* 인증을 제공하기 위해 사용
    * 누가 암호화할 수 있는지가 중요
    * A만 만들 수 있으면 A가 만든 것이라고 한다
    * A와 B만 생성할 수 있는 비밀키의 경우
    * A가 자기가 생성하지 않았다면 이건 B가 생성했다고 확신할 수 있음
    * A와 Server만 만들 수 있다면 A입장에서 서버에서 만들었다는 것을 확신할 수 있음


* 메시지의 구성요소를 바인딩 하기 위해 사용
    * 실제 비밀성이 요구되는 요소는 Kab 뿐이다
    * 하지만 같이 묶여서 암호화된 것으로 연관되어 있다는 것을 알 수 있음
    * 꼭 같이 암호화되야 하는것이 아닌 해싱 등과 같이 같이 묶여있으면 바인딩된 것

* {B||Na||Kab}.Kas를 MAC을 사용해서 변경하면 다음과 같은 효과를 얻을 수 있다
    * {Kab}Kas, MAC.K`as{B||Na||Kab}
    * 비밀성이 요구되는 정보만 암호화하였고
    * 바인딩은 MAC을 통해 제공하고 있고
    * Kab의 무결성을 확인할 수 있다
    * MAC을 사용함으로써 무결성을 얻을 수 있고, Kab를 검증할 수 있다

## 인증 암호화


## 대칭 암호알고리즘의 사용
* 대칭키로 암호화의 의미
    * 인증
        * Kab의 경우 B가 생성하지 않았다면 A가 생성한 것
    * 비밀성
        * Bob과 Alice만 암호문을 복호화하여 M을 얻을 수 있다

* 대칭키 사용의 가장 큰 이슈
    * 대칭키를 어떻게 안전하게 공유할 것인가?
* 대칭/비대칭 암호알고리즘은 기본적으로 무결성을 제공하지 않음
    * 무결성까지 필요하면 인증 암호화

## 비대칭 암호알고리즘의 사용
* 공개키 암호알고리즘에서 개인키로 암호화
    * A가 개인키로 M을 암호화하여 전달
    * 인증
        * A의 공개키로 메시지를 복호화하는데 상공했다면 B는 해당 메시지를 A가 생성했다고 확신할 수 있다

* 공개키 암호알고리즘에서 공개키로 암호화
    * A가 B의 공개키 +Kb로 메시지 M을 암호화하여 전달
    * 비밀성
        * 오직 B만 암호문을 복호화하여 M을 얻을 수 있음
    * 인증
        * B는 누가 이 메시지를 생성하였는지 확인할 수 없음

* 두 경우 모두 대응되는 공개키가 확실히 A또는 B 것임을 확신할 수 있어야 함

## 암호프로토콜의 안정성
* 암호프로토콜은 그것의 보안 요구사항을 모두 충족하였을 때 안전한 프로토콜이라 한다
    * 암호프로토콜은 물론 안전성도 중요하지만, 효율성도 중요함
* 암호프로토콜의 안전성을 증명하기 위해 다양한 방법을 사용하고 있지만 쉽지 않다
    * 보통 지금까지 알려진 공격에 대해서만 안전함
    * 여러 가정 하에서만 증명이 가능한 경우가 많으며, 특정 요구사항 충족에 대해서만 증명이 가능한 경우도 있다
* 암호프로토콜만 안전하다고 하여 전체 시스템이 안전한 것은 아님
    * 서버, 클라이언트 해킹, 서비스 거부 공격 등 프로토콜의 설계를 통해서 방지할 수 없는 위협이 존재함

## 안전성 증명
* 암호프로토콜에 대한 증명은 보통 프로토콜의 보안 요구사항을 고려하여 보안 모델을 세우고, 이 모델에서 증명함
* 보안 모델이란 프로토콜의 안정성을 논하기 위해 세우는 가정들의 집합
    * 가정 중에 가장 중요한 것은 공격자의 능력ㅋㅋ
    * 능력에 따라 공격의 성공 가능성이 다름
    * 공모 공격에 대한 검토가 있어야 함

* 공격자의 능력
    1. 모든 참여자 간의 통신을 제어
    2. 지난 프로토콜 수행을 통해 확립된 세션키를 얻을 수 있음
    3. 공격자가 참여자의 장기간 키를 알고 있음

* 공격자의 종류
    * 제3의 공격자와 내부공격자로 나눌 수 있고, 내부공격자에 대해서는 다음과 같은 가정을 할 수 있음
        * 가정1. 악의적인 내부자의 존재 : 프로토콜의 적법한 참여자가 악의적인 행동을 할 수 있음
        * 가정2. 정직한 내부자 : 적법한 참여자는 항상 정직하게 행동함
    * 보통은 가정 1 

## 프로토콜의 효율성
* 두 측면에서 효율성을 고려
    * 계산 효율성 : 프로토콜의 참여자가 프로토콜을 완료하기 위해 계산해야 하는 양에 의해 측정됨
    * 통신 효율성 : 메시지의 수와 각 메시지의 크기에 의해 측정됨
* 계산 효율성
    * 사용하는 암호기술에 의해 결정됨
    * 공개키를 사용하는 프로토콜은 공개키 연산을 최소화하는 것이 필요함

* 통신 효율성
    * 필요한 라운드의 수를 줄이는 것이 가장 효과적
    * 프로토콜의 한 라운드는 한 시점에서 병렬로 전달할 수 있는 모든 메시지를 포함함
    * 메시지가 서로 독립적이지 않으면 서로 다른 라운드에 포함됨
        * 메시지가 이전 메시지의 구성요소를 포함하면 이 두 메시지는 서로 의존하는 메시지

    

# 암호프로토콜 기초 설계 기술
## 블록방식의 대칭 암호알고리즘의 특성
1. 메시지와 암호화된 데이터 사이에는 어떤 상관관계도 없다
2. 암호화한 데이터를 다른 키로 복호화한 결과 예측 불가
3. 암호화된 데이터가 조작되면 복호화한 결과 예측 불가
4. 메시지가 수신자가 알고 있는 내용이 아니면 복호화해도 이게 제대로 된건지 알 수 없다
    * 수신자가 복호화해서 메시지를 얻었을 때,
    * 메시지에서 알아볼 수 있는 무언가가 있어야 함
5. 메시지의 일부가 확인할 수 있는 값이고, 복호화 후 그것이 확인되면 C가 K를 이용하여 생성한 암호문인지 확인 가능
    * 즉 복호하하여 얻은 메시지에 대해 무결성 확인 가능
    * 이처럼 암호문을 생성할 때 사용한 암호키를 확인할 수 있게 해주는 평문의 요소를 여분 정보라 한다
    * 인증 암호화 생기고 나서는 사용하지 않는다?


다중 블록의 경우
* M1과 M2가 있다면 M1,M2 모두에 여분 정보가 있어야 K로 암호화된 블록임을 확신할 수 있다
* 둘 다 여분정보가 있어도 서로 연결할 수 있는 부분이 없다면 M1과 M2가 M을 쪼개서 암호화하여 만든 암호 블록임을 확신할 수 없다
    * 공격자는 전송되는 메시지를 다양하게 조작 가능
    * 여분 정보의 유무에 따라 할 수 있는 조작이 달라짐


인증 암호화 방법을 사용한 경우
* MAC(encrypt then mac) : 메시지를 암호화한 후 mac값을 계산  
* MAC값이 확인된 경우에만 복호화 시도
    * MAC 값이 확인되면 C의 무결성을 확신할 수 있음
* MAC값이 확인되고 상대방을 신뢰하면 C가 특정키를 이용하여 생성한 암호문인지 여부를 확신할 수 있다
    * C가 단일 블록이 아니라도 성립한다
    * 상대가 애당초 이상한 것 보내면 그거는 알 수 없다

* 인증 암호화를 하지 않으면 블록 크기, 평문의 각 요소의 크기, 평문의 구성 등이 바인딩에 영향을 준다
    * 실제 바인딩되었다고 확신하기 어려울 수 있다
* 인증 암호화를 하면 전송 과정의 조작은 발견할 수 있다
    * 송신자가 애초에 메시지를 엉뚱하게 구성하면 문제
        * 이때문에 신뢰할 수 있어야 함
    * 상대방을 신뢰할 수 있다면 여분 정보 없이 수신한 암호문이 어떤 키로 암호화되었는지 확신할 수 있다
    * 상대방을 신뢰할 수 있다면 바인딩에 대해서도 확신할 수 있다
* 인증 암호화가 모든 문제를 해결하는 것은 아님

## 여분 정보
* 평문에 여분 정보가 없다면 올바른 키를 이용하여 복호하하였는지 판단할 수 없음
    * 여분 정보란 복호화의 정확성을 확인할 수 있도록 해주는 요소

* 여분 정보의 분류
    * 명백한 여분 정보 : 누구나 확인할 수 있는 정보
        * 식별자
        * 수동적인 암호해독 공격을 용이하게 해줌
        * 특히 패스워드와 같이 사전 공격이 가능하거나, 비교적 작은 공간에서 선택된 암호키를 이용하여 암호화한 암호문 내에는 명백한 여분 정보를 포함하지 않는 것이 바람직함
            * 추측 가능함
    * 함축적 여분 정보 : 오직 수신자와 송신자만이 알고 있는 정보


## 명명 기법
메시지의 의미를 명확하게 하기 위해 참여자의 식별자를 암호문 내에 포함하는 방법

식별자는 항상 명백한 여분 정보

근데 인증 암호화 쓰면 전부 해결된다

키를 받았으면 사용할 상대, 생성시간 등이 있어야 함

* 명명기법의 적용 : 대칭 암호알고리즘을 사용하는 경우
    * {A||B||Kab}.Kas 
    * A는 생략가능 Kas 로부터 유추 가능하다
        * 최근성을 제공하지는 못한다
    * 실제 인증 암호화를 하지 않으면 B와 Kab의 바인딩을 확신할 수는 없다

* 비대칭 암호알고리즘을 사용하는 경우
    * 서버가 생성하였다는 것이 전달되야하고, 비밀성이 보장되야 한다
    * 밖에 +는 비밀성, 안에 -는 서버가 만들었다는 것을 알려줌
    * {A||B||Kab}.-Ks}.+Ka
    * 대칭 암호알고리즘과 달리 A를 생략할 수 없다
    * 생략하면 다음과 같은 공격이 가능하다
        * 위에서 직접적으로 암호화하는 것은 Ks이다
        * 직접적으로 암호화하는 경우에만 생략 가능하다


## 메시지의 최근성/시기적절성
암호프로토콜에서 암호문을 수신하면 정해진 다음 행동을 취하기 위해 여러 검사를 하게 된다

이때 보통 **최근성**검사를 진행하게 된다.

메시지의 최근성을 검사한다는 것은 메시지가 이전 또는 다른 세션에 사용된 메시지가 아니라 현재 프로토콜 수행을 위해 새롭게 만든 메시지임을 확인하는 것

최근성은 메시지의 구성요소로부터 유추해야 하며, 어떤 매커니즘을 사용하건 재전송 메시지와 그렇지 않은 메시지 간의 구별이 가능해야 한다

식별자로 사용되는 요소는 시간과 인과성이 있다.

* 타임스탬프 기반 기법 
    * 시간적 관계를 통해 메시지의 최근성을 보장하는 기법
    * 타임스탬프를 메시지에 포함시킨다
* 난스 기반 기법
    * challenge(request)와 response를 통해 수행한다
    * request에 난스를 만들어 보내면 상대방이 난스를 포함하여 response한다
    * 난스를 생성한 사람이 자신이 만든 난스가 포함되어있는지 확인하여 최근성 확인한다?? 
    * 응답이 시도 이후에 만들어질 수 밖에 없도록 하여 응답의 최근성 확인

* 제공자 : 식별자를 제공하는 참여자
* 입증자 : 제공된 식별자를 메시지에 포함하는 참여자
* 검증자 : 메시지에 포함된 식별자를 통해 메시지의 최근성을 확인하는 참여자

* 타임스탬프 기법 : 제공자와 입장자가 같은 참여자
* 난스 기법 : 제공자와 검증자가 같은 참여자

* 최근성 식별자로 적합하기 위해서 반드시 예측할 수 없어야 하는 것은 아님
* 어떻게 식별자를 사용하느냐에 따라 불예측성이 필요할 수 있고, 필요하지 않을 수 있음


## 타임스탬프
수신자가 자신의 지역 시간의 현재값을 비교하여 차이가 허용 범위라면 메시지가 최근에 생성된 메시지로 인식

취약점
* 허용 윈도우 내에 재전송하는 공격
    * 메시지 중복 검사가 반드시 필요하다
    * 그래서 최근 t내에 수신한 모든 메시지를 보관함
* 제공자는 쉽게 특정 순간을 가리키는 타임스탬프를 사용할 수 있음
    * 모든 참여자가 메시지에 타임스탬프를 첨부하고 확인하기 위해서는 타임스탬프의 형태를 알아야 한다
        * 그래서 타임스탬프 형태는 공개되어 있을 수 밖에 없다
    * 타임스탬프의 값은 미래 또는 과거의 어느 한 순간을 나타낸다
    * 검증자는 제공자가 정직하게 타임스탬프를 제공한다고 **신뢰**해야 한다

* 타임스탬프를 유효한 값으로 허용하는 범위를 허용 윈도우라 한다.



**선행 메시지**
* 수신자의 시간이 송신자의 시간보다 상대적으로 앞선다
* 이 경우 송신자가 올바른 타임스탬프를 보내더라도 거부하게 된다
* 이것을 선행 메시지라 한다
    * 과거 시간이 포함된 메시지
    * 미래 시간은 사후 메시지
* 그래서 시간은 항상 절대 시간과 동기화되어야 한다

장점
* 제공자와 입증자가 동일인이며, 일방향 통신으로 최근성을 보장할 수 있음
    * 메시지 하나만 있어도 됨

단점
* 입증자를 신뢰할 수 있어야 함
* 타임스탬프의 사용은 시스템 간의 시간 동기화가 요구됨
    * 시간 동기화 메커니즘이 시스템 보안상에 미치는 영향이 크다
    * 그래서 시간 동기화 메커니즘을 구현해야 한다
* 사후 메시지 문제를 해결할 수 없다
* 하여튼 이래서 안씀


## 난스
난스란 특정한 순간을 증명하기 위해 생성된 값

제공자와 입증자가 다른사람

제공자는 한번도 사용하지 않은 난스를 제공하고, 그 난스가 회신되야지만 최근성 보장

이전에 사용한 난스를 다시 사용해서는 안된다.  
그래서 **키를 자주 바꿔줄 필요**가 있다. 키가 바뀌면 똑같은 난스를 사용해도 괜찮음

난스 값으로 사용하는 것
* 타임스탬프, 카운터, pesudo-random number

장점
* 검증자는 입증자의 정직성과 능력에 대해 신뢰할 필요가 없다

사용 방식
* 난스는 항상 명백한 여분 정보
* 인증 측면에서 방식2의 경우에는 Na를 예측할 수 없어야 함
    * 예측이 가능하면 누구나 응답할 수 있음
    * 최근성 보장이 목적이 아닐 수 있음
* 방식2 외에는 예측해도 되지만 이전에 사용한 키면 안된다
    * 그래서 키를 자주 바꿔줘야 함
    * 해당 키에서 이전에 사용하면 안되는 거임

## Timestamp vs Nonce

## 최근성을 보장하는 기타 다른 방법
* 카운터
    * 쌍방간의 동기화된 카운터의 존재를 가정하며, 실제 사용은 타임스탬프와 차이가 없다
    * 장점
        * 실제 시간과 독립적 동기화
    * 단점 
        * 모든 사용자간에 동기화된 별도의 카운터가 필요, 사용자 간에는 힘들지만 서버와 사용자 간에는 활용 가능
    * 무한 카운터를 사용할 수는 없음
    * 카운터도 중요한 보호 자산
* 최근성이 보장된 암호키 사용
    * 최근에 생성된 키를 사용하여 생성된 메시지는 기본적으로 최근에 생성된 메시지




# 키 확립 프로토콜
n명의 사용자가 서로 메시지를 비밀스럽게 교환하고 싶다면, 사용자 쌍마다 메시지를 암/복호화 할 수 있는 서로 다른 대칭키가 필요하다

그래서 대칭키 방식만을 사용하는 방법과, 공개키를 활용하는 방법이 있다.

참고로 분류 2는 대칭키랑 공개키 같이 쓰는 것


## 비밀키만 사용하는 방식
3가지 방법을 살펴본다

1. n(n - 1)/2 개의 비밀키를 생성한 후 사용자에게 n-1개의 키를 오프라인으로 주는 것
    * 확정성도 없고 키 갱신 수단도 없다

2. 신뢰 기관을 사용하는 방법
    * 각 사용자는 신뢰기관과 비밀키를 공유
    * 사용자 간의 비밀키는 필요시 신뢰 기관을 통해 확립
    * 신뢰 기관과 최초 장기간 키를 확립하는 문제
    * 필요시 장기간 키를 갱신하는 문제

3. 보안 변수 t를 결정하고 각 사용자는 t에 비례한 정보를 유지
    * t로부터 n - 1명의 다른 사용자와 사용할 수 있는 독특한 비밀키 생성 가능
    * 이 비밀키로 세션키를 확립하여 사용
    * Blom의 키 분배 기법을 이용하여 키를 계산한다
    * 클 수록 안전함
    * 확장성은 미리 만들어놓는 방식으로 사용
    * 200명 정도 있을 것 같으면 200개 정도 만들고 사용자 추가하면 미리 만들어놓은거 제공


## 공개키를 사용하는 방식
2자간 공개키를 사용하여 세션키를 확립하고 싶으면 한 사용자가 세션키를 생성하여 다른 사용자의 공개키로 암호화하여 전달하면 된다.

이때 그냥 키만 보내는 것이 아니라, 메시지를 해당 키로 암호화한 다음 같이 보낼 수 있다.


``Msg 1. A → B : C = {M}.K1, MAC.K2(C), {TA||K}.+KB``

이때 K1과 K2는 K로부터 계산한 서로 독립적인 값이다.

물론 A가 서명하지 않았기 때문에 B의 입장에서 이걸 A가 보냈다고 확신할 수 없다.

하지만 비교적 비용이 크다. 

그래서 메시지는 대칭키 방식으로 주고받고 신뢰 기관과 장기간 키를 확립하는 것은 공개키 방식으로 하면 해결된다.



## 키 확립 프로토콜
키 확립 프로토콜이란 둘 이상의 참여자들이 비밀키를 고융할 수 있도록 해주는 암호프로토콜

확립 프로토콜을 통해 얻어지는 비밀키는 보통 단일 세션에 사용하는 세션키

키 확립 프로토콜은
* 키 전송 또는 동의 과정
* 키 확인 과정
    * 상대방이 자신과 같은 키를 가지고 있는지 확인하는 과정  
으로 구성되어 있다.

키 확립 프로콜은 3가지로 분류된다

### 키 생성 주체에 따른 분류
* 키 전송 프로토콜 : 한 참여자가 홀로 키를 생성하여 다른 참여자에게 주는 방식
    * 보통 서버가 생성해서 준다
    * 대칭키만을 사용할 경우 보통 TTP를 사용하는 중재 방식의 프로토콜
    * 이때 TTP는 크게 키 중계 센터와 키 분배 센터로 구분한다

* 키 동의 프로토콜 : 특정 사용자가 아닌 다 같이 키를 생성하는 방식
    * 키를 확립하는 모든 참여자들이 동등하게 키 생성에 기여
    * 보통 랜덤값을 서로 교환한 후 이를 이용하여 각자 생성에 기여
    * 자체 강화 방식 : 별도 서버를 사용하지 않고 서로 정보들을 교환해서, 교환된 정보들로 세션키를 계산
    * 그래서 우리가 사용하는 프로토콜들은 보안을 위해 공개키 기술을 사용한다

### 키를 확립하는 사용자 수에 따른 분류
2자간, 3자간, 다자 간으로 나뉜다.

가장 많이 사용되는 것은 2자간


## 키 확립 프토토콜의 요구사항
* 키의 비밀성 : 참여자 외에는 비밀키를 얻을 수 없어야 함, 신뢰기관 제외
* 키의 최근성 : 이전에 사용한 적 없어야 함
* 키의 용도 : 참여자는 수신한 키가 본인이 생각하고 있는 상대방과 사용하기 위한 키인지 확인할 수 있어야 함
* 생성 주체 확인, 참여자 확인 : 키 전송 프로토콜의 경우 키를 수신한 참여자는 이 키를 프로토콜에서 정의한 주체가 생성한 것인지 확인할 수 있어야 함
* 키 확인 : 키를 확립하는 참여자는 상대방이 같은 키를 가졌는지 확인할 수 있어야 함

* 무결성
    * 무결성의 경우 다른 것보다 중요하지는 않다
    * 확인이 더 중요함
    * 보통 확인은 라운드의 증가가 필요함

    
## 이산대수 문제
군은 이항연산에 의해 닫혀있는 대수구조를 말함

닫혀있다는 것은 집합에 있는 두 원소를 빼서 특정한 연산을 적용시키면 그 결과가 다시 집합에 들어가는 것

그러니까 집합안에 있는 거 두개 랜덤으로 골라서 특정 연산 적용하면 결과값이 집합에 있다..

* 항등원 : 어떤한 원소랑 항등원이랑 연산 적용시키면 자기 자신이 나옴

* 역원 : a와 b를 연산 적용시키면 항등원이 나온다, 그러면 a와 b는 서로의 역원

역원을 곱하여 나눗셈 효과를 얻을 수 있다
``4 * x = 5`` 에서 x를 구하고 싶다면 양 변에 4의 역원을 곱하면 된다.  
-> ``x = 5 * 2``

* 생성자 : 거듭제곱하면 군에 있는 모든 원소가 나오는 원소
* 순환군 : 생성자가 있는 군

``5^2 = 4`` 에서 2는 기저 5에서 4에 대한 이산대수. ``log5(4) = 2``

2는 생성자 5에서 4를 구하기 위한 제곱의 횟수

* 이산대수 문제 : 순환군의 정보, 생성자 g, 임의의 군 원소 y가 주어졌을 때 기저 g에 대한 y의 이산대수를 찾는 문제

순환군의 크기가 크면 이산대수 문제를 해결하기 어렵다.


## 키 동의 프로토콜
### Diffie-Hellman 키 동의 프로토콜
* g : 유한순환군의 생성자

이 군에서 이산대수 문제와 Diffie-Hellman계산 및 결정 문제는 계산적으로 어렵다

1 ~ t-1에서 각자 하나씩 고른다. A는 a를 골랐고, B는 b를 골랐다.

* DH 계산 문제 : 군 정보, g^a, g^b 가 주어졌을 때 g^ab를 계산하는 문제
* DH 결정 문제 : 군 정보, g^a, g^b, g^c가 주어졌을 때 g^c, g^ab가 같은지 결정하는 문제

Alice와 Bob만 g^ab를 계산할 수 있다

g^ab를 직접 세션키로 사용하지 않고, 키 유도 함수에 g^ab를 입력하여 세션키를 계산함

* 문제점 : 서로 g^a와 g^b가 상대방이 보낸 값인지 알 수 없다
* 공개키 기술을 사용하고 자체 강화 방식


### 키 동의 프로토콜(2)
* 키 동의 프로토콜은 특정 참여자가 홀로 키를 결정하지 않는다.
    * 보통 모든 참여자가 동등하게 참여한다
    * 각 참여자들이 랜덤 값을 교환하고, 이 값들을 통해 키를 결정
* 각 참여자 입장에서 자기가 선택한 요소가 랜덤하고 최근이면 세션키도 랜덤이고 최근인 것이다

## 키 제어 요구사항
참여자 중 어느 누구도 공유되는 세션키가 사전에 미리 계산되거나 선택되어진 값이 되도록 만드는 것은 계산적으로 어려워야 함














# 암호 알고리즘


## 암호화 모드
대칭 암호알고리즘은 크게 블록과 스트림 암호방식으로 분류한다

* 블록 암호방식 : 메시지를 일정한 크기로 나누어 각 블록을 암호화
    * 크면 암호화 모드, 작으면 채우기가 필요하다

* ECB 모드 
    * 암호화 모드 중 하나
    * 블록 단위로 메시지를 나누어 각 블록을 독립적으로 암호화
    * 평문 패턴이 암호문에 그대로 나타날 수 있다
        * 평문이 우연히 같으면 암호화된 블럭도 같다
        * 그래서 평문이 같아도 암호화된 블럭은 다르게 할 필요가 있다
        * 이것을 *피드백*이라 한다

* 피드백 : 한 블록을 독립적으로 암호화하지 않고, 추가적인 요소를 사용하여 암호화하여 평문 블록이 같더라도 결과가 달라지도록 해주는 요소


암호화 모드의 분석
* 평문오류 : 암호화하기 전에 평문에 오류가 있을 때 암호문에 미치는 파급효과
* 암호화 조작 : 암호화한 후에 암호문을 조작하였을 때 평문 블록과 전체 평문에 미치는 영향(복호화 시 영향)
    * 복호화 시 조작된 일부만 깨지고 나머지는 멀쩡하면 좋겠다
    * 공격자가 의미있는 변화를 줄 수 있어서는 안된다
        * 이것을 NM특성이라고 한다
* 추가 보안 문제 : 암호화 모드 사용에 따른 추가적인 보안 문제의 유무
* 효율성 : 모드 연산의 비용, 병행성, 다중 프로세서의 활용 가능 여부 등을 분석

## 채우기
평문 메시지의 크기가 정확하게 블록 크기의 배수가 아닌 경우에 필요

채우기(padding) : 완전하지 않은 마지막 블록 끝에 규칙적인 일련의 비트를 추가하여 완전한 블록을 만드는 것

복호화한 사용자는 채워진 부분을 정확하게 제거할 수 있어야 함

방법 2가지
1. 암호문과 별도로 원 평문의 크기를 전달
2. 채우기를 한 부분에 채운 부분을 제거할 수 있는 요소를 포함

일반 채우기
* 채워야하는 부분 끝에 채우는 바이트 수를 적는다
* 3바이트면 3 적고 앞에 2바이트 채움
* 만약 블록크기의 배수로 딱 맞다면 오직 채우기만 있는 블럭 하나 추가해야 한다
* 아니면 멀쩡한 데이터를 채우기로 오해할 수 있음
* 그래서 최대 1블럭이 기존 데이터에 비해서 늘어난다 


* PKCS #7 : 채우기를 해야 하는 모든 부분을 채워야 하는 바이트 수의 값으로 채움

이 방법이나 일반적인 방법이나 모든 메시지에 대해 향상 채우기를 해야 한다.

평문이 블록 크기의 배수가 되어도 무조건 채우기 들어가야 한다

* 문제점 : 그래서 암호문이 평문보다 항상 큼
    * 채운 데이터는 여분 정보 역할을 할 수 있기는 하다


## 암호문 훔침 기법
채우기를 해도 평문의 크기와 암호문의 크기를 일치하도록 하는 방법

바로 전 암호문 블록을 이용하여 채우기를 하는 방식

n개의 블럭이 있으면 n-1번째의 블록이로 채운데

불필요한 데이터가 아니라 필요한 데이터로 채운다.


## ECB 모드
피드백을 사용하지 않는 모드

피드백 : 같은 평문이 똑같이 암호화되지 않는 것

평문 오류 : 한 평문 블록의 오류는 해당 암호문 블록에만 영향을 줌

유사한 평문을 암호화 하면 비슷하게 암호화 됨

그래서 암호문이 비슷하면 평문도 비슷함을 알 수 있다

암호화된 메시지의 블록들의 위치를 바꾸면 복호화된 평문 메시지의 블록 위치들도 동일하게 바뀌게 된다.(NM특성 불만족)

병렬처리 가능

## CBC(Cipher Block Chaining) 모드
Pi를 암호화할 때 이전 블록을 xor 해서 암호화

i를 암호화하려먼 i - 1이 필요한 순차적 암호화 모드이다.

그래서 멀티스레드 환경에서 못돌림

첫 블록은 이전 블록이 없다 그래서 사용하는 것이 초기 벡터(IV)

* C0 : 초기 벡터(IV, Initalization Vector)

보통 랜덤 블록을 사용한다. 비밀성을 유지할 필요는 없다

IV로 한블럭 채우기로 한 블록, 이렇게 최대 2블록이 늘어날 수 있다.

CBC 모드와는 다르게 첫 암호화 블록(IV)이 랜덤 블록이기 때문에 같은 메시지를 다시 암호화하여도 결과가 다르다

만약 하나의 블록이 변한다면, 뒤의 다른 블록들에게도 영향을 미쳐 전부 변하게 된다.

복호화할 때는 마지막 블록이 변경되면 다른 모든 블록에 영향을 미친다.

그래서 마지막 블록을 MAC으로 사용할 수 있다.

* 암호화 조작
    * 하나의 블록의 비트가 변경되면 해당 블록이 아예 깨진다
    * 해당 블록과 그 다음 블록은 영향을 받지만
    * 다른 블록은 영향을 받지 않는다
    * 이런 특성을 자체 회복 기능을 지니고 있다고 한다

* 자체 회복 : 하나의 암호문 블록에 오류가 발생하면 나머지 모든 블록의 복호화에 영향을 주지 않음

복호화다 복호화

여기서는 Ci 에 문제가 생기면 i랑 i+1만 영향을 받는다.

XOR를 사용하기 때문에 두 개의 암호문을 조합하여 새 암호문을 만들 수 있다

암호문 블록을 변경하여 예측할 수 있는 변경을 도입할 수 있음

i의 특정 비트를 조작하면 i+1의 해당 비트도 변경되게 된다(NM특성 불만족)

우연히 Ci랑 Cj가 같을 수 있다...

이 경우 두개 xor 하면 Pi랑 Pj랑 xor 한 값을 얻을 수 있다

이것을 통해서 평문을 유추할 수 있음


## CTR(Counter) 모드
CBC보다 많이 사용하는 암호모드

CBC보다 속도가 빨라졌다. 병행 처리가 가능함

이전 블록이 아닌 카운터를 xor 해서 계산

N0만 알면 Ni는 바로 알 수 있다.

평문이 아닌 카운터를 암호화하여 평문이랑 XOR 하는 것으로 암호화 블록 생성

굳이 암호알고리즘을 사용하지 않아도 괜찮다?? MAC만 하면 된다??

복호화가 필요없고, 암호화 함수만 있으면 된다

복호화시 카운터에 암호화한 다음 다시 암호블록에 xor해주면 끝

IV를 사용하게 되는데 만약 초기값이 겹치게 된다면 심각한 문제가 생긴다

같은 IV면 Si 가 같아진다. 카운터라서...

Si가 같다면 같은 Si의 암호화 블록 두개를 XOR 하면 **평문을 XOR 한 것**을 얻을 수 있다!! 

IV가 같지 않더라도 카운터이니 중첩될 수 있다.

그래서 128비트의 경우 앞에 **96비트는 랜덤으로 정하고 뒤에 32비트만 카운터**로 사용한다.

그러면 앞에 96비트는 다르니까 중첩될일이 없다

생일 파라독스대로 루트 씌워 2^48 의 확률로 충돌이 일어날 수 있다.

채우기가 필요 없다. 조금 남으면 원래 크기만큼의 스트림 방식으로 암호화하면 된다.

하여튼 암호문의 크기는 증가함 IV 때문에

무조건 한 블럭이 증가함

얘도 한 비트를 바꾸면 그대로 그 비트만 영향이 감, NM특성은 만족안됨

NM특성이 만족되지 않는다. 그래서 무결성이 중요하고 인증 암호화를 해야 한다.

특정 블럭에 원하는 변화를 줄 수 있다. 그리고 한 블럭의 오류가 다른 블럭에 영향을 미치지 않는다.

3개다 NM특성은 만족안함

NM특성을 만족하지 못한다는 것은 무결성을 제공하기 어렵다는 측면이 있다

그래서 메시지를 암호화 뿐만이 아니라 인증 암호화 해줘야 한다.


## 인증 암호화 모드
* encrypt then mac : 암호화한 다음 암호화문에 대한 mac

mac then 쓸 때는 CCM 사용함

CBC에서 마지막 블록 MAC으로 사용한 다음 CTR모드로 암호화??


encrypt then mac 에서는 EAX

그 외에도 
* AEAD : 암호화와 별도 평문을 함께 전달하고, 암호문과 별도 평문의 무결성을 제공함
* GCM 모드


보통 CTR 사용하고 병렬로 실행 가능하기 때문에 더 빠르고, 복호화 없이 암호화 만 있으면 되기 때문에 하드웨어로 만들면 더 작게 만들 수 있다.


## CBC모드 Padding Oracle 공격



## DES(Data Encryption Standard)
블록 크기가 64비트, 키의 길이는 56비트



# 키 확립 프로토콜 대표 사례
## 꼭 일회용 세션키를 사용해야 하나?
세션키를 여러번 사용하는 방식을 티켓 방식,

한번에 여러 세션키를 확립하는 방법을 다중 벡터 방식

두 방식 모두 세션키를 장기간 유지해야 함, 키 관리해야 하고 공간이 필요함

## 티켓 기반 프로토콜
매번 새로 세션키를 확립하는 비용을 줄이기 위해 **확립된 세션키를 일정한 기간 사용**할 수 있도록 함

티켓 : 세션키, 세션키 용도, 유효기간 등 정보를 암호화한 암호문



# 암호 알고리즘2
## 블록 암호화를 이용한 충돌회피 함수

## Secure Hash Algorithm
SHA-1 
* 2^69의 확률로 충돌을 찾을 수 있다
* 해시값의 길이가 2^80 이므로 안정성은 2^80
* 이 때문에 SHA-2가 주로 사용된다
    * 해시값의 길이가 224, 256, 386, 512
* 2015년에 KECCAK이라는 알고리즘을 사용한 SHA-3이 채택됨

## SHA-1
160비트, 2^80의 안정성, 사실 이것보다는 작다

Merkle-Damgard 구조

## SHA-3
스펀지 구조, 몰라도 된ㄷ


## MAC을 구성하는 방법
* 전용 알고리즘 사용
* 일반 대칭 암호알고리즘을 사용
    * CBC-MAC, NMAC, CMAC, PMAC
* 일반 해시함수를 사용
    * HMAC
* 전자서명을 사용하는 것과 MAC을 사용하는 것 차이 중요

### CBC-MAC, CMAC
* 이전 블록의 변경이 MAC값에 영항을 주기 때문에 중요



# 해시함수의 활용
* 해시함수 : 임의의 길이에 이진 문자열을 고정된 짧은 길이의 이진 문자열로 매핑해 주는 함수
* 압축, 계산용이, 일방향성, 약한충돌회피, 강한충돌회피 등의 특성이 있다

활용
* 전자서명
    * 전자서명의 비용을 줄인다
    * 메시지 대신에 메시지 해시값에 전자서명
    * 충돌회피 해시함수이어야 함
* 무결성 서비스 
    * 해시함수보다는 MAC을 사용하는 것이 안전
* 비트 약속
    * 값을 전달할 때 먼저 해시값 전달, 나중에 필요한 시점에 공개함
    * 값은닉 : 일방향성 특성 때문에 해시값을 받은 참여자는 어떤 값을 받았는지 알 수 없음
    * 바인딩 : 충돌회피 특성 때문에 최초 해시값을 계산할 때 사용한 입력이 아닌 다른 값을 나중에 공개할 수 없음

## 패스워드 인증
다양하게 사용되지만 

패스워드는 쉽게 예측이 가능하다는 문제가 있다.

### 패스워드 해싱
* 유닉스, 웹 서비스 등에서 패스워드 관리
    * 패스워드를 그대로 저장 : 패스워드가 저장된 파일에 대한 비밀성 유지가 필수
    * 그래서 패스워드의 해시값 보관
    * 사전공격(dictionary) : 흔하게 사용하는 패스워드에 대한 해시값을 구한 후 저장되어 있는 해시값과 비교
    * salt의 사용 : 해시값을 구할 때 임의의 랜던값인 salt를 포함하여 계산
    * 보통 해시값과 salt를 같이 보관
    * 같은 패스워드라도 salt값에 따라 해시값이 달라짐
    * 사전공격이 어려워진다, 단어 m개 salt n개면 해시를 mn번 해봐야 함
        * 각 salt에 따라 m개 일일히 다 해봐야 하니까

### BCrypt
해시함수는 빠른 연산이기 때문에 수행 속도를 느리게 한 것

* 패스워드를 해싱할 때 Salt를 사용하는 것은 물론 기존 다른 암호알고리즘과 달리 알고리즘 수행 속도를 느리게 만들 수 있음
    * 수행 속도를 느리게 한다는 것은?
    * 해시 여러번 함

### 패스워드의 안정성 강화 방법
Abadi
* 클라이언트에서 서버로 패스워드 전송 시 랜덤 비트(a) 추가하여 해싱 후 전송
* 서버는 패스워드 자체를 유지해야 함
* 서버는 패스워드를 받아 모든 가능한 경우를 확인하여 패스워드 확인
* 외부 공격자는 a와 패스워드 모두 몰라 추측 공격하기 어렵다
* 서버 부담은 크다

SSO나 브라우저가 패스워드 기억 등등

## Weakest Link Principle
가장 취약 요소 원리
* 시스템 전체의 안정성은 가장 취약한 부분의 안정성과 같다
* 가장 취약한 부분은 보통 사람이다(social engineering)

## 장기간 키의 보호
* 장기간 키는 비휘발성 메모리에 유지되야 하며, 불법적인 접근이 있더라도 노출되지 않도록 보호되야 함
* 보통 패스워드로부터 대칭키를 생성하고 이 키로 장기간 키를 암호화하여 유지함
    * 공동인증서에서 개인키의 보호 등
* 저장된 파일이 노출되면 키 자체가 노출될 가능성이 높음
* 이 문제를 해결하기 위해 **화이트박스 암호기술**을 사용할 수 있음
    * 변하지 않는 암호키를 별도 파일에 저장하는 것이 아니라 
    * 암호화 알고리즘 소프트웨어 코드 자체에 포함한 후 해당 코드를 난독화하여 코드로부터 키를 추출할 수 없도록 만드는 기술

## 키 관리와 하드웨어 
* 장기간 키의 탈취 방지를 위해 키를 특수 하드웨어에 유지할 수 있음
    * USIM 등
* 하드웨어를 이용한 키 관리
    * 기본적으로 2-factor 인증 : 기기+(PIN 또는 password)
    * 종류에 따라 기기 내에서 암호 연산 수행




## 패스워드 기반 프로토콜
* 패스워드 기반 키를 이용하여 랜덤 값을 암호화한다고 무조건적으로 패스워드 추측 공격에 강건한 것은 아니다
    * 암호화된 랜덤 값을 향후 어떻게 사용하는지에 따라 강건하지 않을 수 있다
    * 암호화된 랜덤 값이 패스워드 추측 공격에 사용 가능한 특성을 가지고 있으면 강건하지 않다

1. `NB, {K}.Kp`
2. `{NB}.K`

패스워드를 추측해서 키를 만듬, 1번을 복호화해서 K를 얻음, 여기까지는 제대로 복호화했는지 알 수 없다. 2번을 K로 복호화해서 NB가 나오면 제대로 추측한 것

### Original EKE, 1992
난스가 아니라 랜덤 값을 사용해 추측이 맞는지 확인할 수 없도록 한 것

### 패스워드 기반 프로토콜(2)
* 정확하게 추측했는지 알 수 없도록 하는 것도 중요하지만
* 추측이 틀렸다는 것을 알 수 없도록 하는 것도 중요
* 패스워드 기반 키는 로컬에서만 사용해야 한다
* 로컬에서 사용하는 것이 아닌 네트워크를 탄다면, 랜덤값만 암호화하고, 암호화한 랜덤값을 올바르게 사용하고, 암호화한 값을 패스워드 추측 공격에 취약하지 않도록 특징들을 가지고 있으면 안됨

## 일회용 패스워드
OTP
* 매번 새로운 패스워드를 사용
    * 매번 패스워드를 변경하면 노출되도 안정성에 문제가 없음
* 클라이언트와 서버는 매번 새롭지만 같은 패스워드를 생성하기 위해 둘 간의 대칭키를 공유하고 있어야 함
    * 대칭키를 사용하기 때문에 부인방지는 약함
    * 클라이언트와 서버가 대칭키를 이용하여 매번 다르지만 동일한 패스워드를 생성해야 함
    * 대칭키와 매번 바뀌는 값을 이용하여 패스워드를 생성해야 함

OTP의 종류
비동기화 vs 동기화

비동기화 방식
* 계산할 때 사용할 랜덤 값을 서버가 제공하는 방식
* 장치와 클라이언트 기기 간 통신이 가능하지 않으면 사용자가 직접 시도값을 장치에 입력해야 함

동기화 방식

 
## HOTP


## KDF(Key Derivation Function)
* 대칭키를 랜덤하게 생성하여 사용하는 경우도 있지만
* 패스워드나 키 동의 프로토콜을 수행한 후, 확보한 비밀값을 이용하여 대칭키를 생성하는 경우가 많음
* 이때 사용하는 함수를 KDF
* 패스워드로부터 대칭키를 생성할 경우 패스워드 추측 공격 때문에 salt와 반복 횟수라는 기법을 사용함

## HKDF
* HMAC 기반 KDF를 말하며, 보통 키 동의 프로토콜 수행을 통해 얻은 랜덤 비밀 정보로부터 대칭키를 생성할 때 사용함

## PBKDF
c는 반복횟수(속도를 느리게 하는 요소)

해싱을 여러 번 반복

`Ti = F(Pi, salt, c, i), c는 반복횟수

## Lamport의 해시체인 기법
랜덤한 seed를 이용하여 연속적으로 해시값을 계산하여 생성함

seed가 s이면 길이가 n인 해시체인을 생성하기 위해서는 다음을 차례로 계산함

c0=H^(n+1)(S)는 이 해시체인의 루트 값이라 함

해시의 일방향성 때문에 Hi를 알아도 H(i-1)은 계산할 수 없음

Hi를 알면 H(i-1)은 연산 한번만 하면 유효성 확인 가능

연속적으로 인증 가능

비용을 들어 루트만 계산해 놓으면 다음부터는 저렴한 연산으로 인증 가능

## Hash Puzzle


## Merkle Tree
해시 트리

균형 이진 트리

자기 두 자식을 합쳐서 해시

4개의 메시지에 서명을 해야 할 경우, 루트 값 h에만 서명하면 모두에 서명하는 것과 같다.


# 다자간 키 확립 프로토콜
특정 그룹에 속한 멤버들에게만 비밀스럽게 데이터를 전송해야 하는 경우가 있다.

사용자 쌍마다 다른 비밀키를 사용하여 암호화하여 전달하는 것은 네트워크 대역폭 측면과 연산량 측면에서 비효율적
* 어차피 각 사용자에게 동일 메시지 전송

해결책
* 그룹에 속한 모든 멤버들이 같은 비밀키를 공유하도록 한다
* 해당 비밀키로 데이터를 암호화하고, **IP 멀티캐스트**기법을 이용하여 전달한다
    * IP 멀티캐스트 : 같은 경로에는 메시지가 1번만 가는 것
* IP 멀티캐스트 기법은 가장 적은 네트워크 대역폭을 사용하여 동시에 여러 수신자에게 패킷을 전달하여 준다

## 다자칸 키 확립 프로토콜의 요구사항
요구사항에 영향을 주는 요소
* 응용의 종류(실시간 방송, 다자간 회의, 메신저 단톡 등)
* 그룹의 크기와 *동적성*(그룹 멤버의 변화)
    * 그룹 멤버의 추가나 탈퇴 시 키의 변경이 필요함
* 확장성
* 신뢰 모델

* 그룹키를 변경하기 위해 모든 참여자가 프로토콜에 참여해야 하면 확장성에 문제 때문에 현실성이 떨어질 수 있다

* 그룹키 확립도 키 확립 프로토콜의 한 종류이므로 비밀성, 확인, 최근성의 요구사항을 충족해야 하지만 현실적으로 힘들다
    * 비밀성 : 그룹 멤버만 알아야 함
    * 확인 : 모든 그룹 멤버가 동일한 키를 가졌는지 확인하기 힘들다
    * 최근성 : 난스 기법을 사용하기 힘들다

* 동적 그룹(멤버가 자주 바뀜)의 경우 다음과 같은 추가 요구사항이 필요
    * 전방향 안정성 : 그룹을 탈퇴한 멤버를 포함하여 이전 그룹키를 알고 있는 공격자는 새 그룹키를 알 수 없어야 함
        * 꼭 필요하다
    * 후방향 안정성 : 그룹에 새롭게 가입한 멤버를 포함하여 현재 그룹키를 알고 있는 공격자는 이전 그룹키를 알 수 없어야 함
        * 꼭 필요하지 않을 수 있다
        * 응용에 따라서 요구되지 않을 수 있다
        * 실시간 방송 등

* 키 독립성 : 몇 개의 그룹키를 알고 있는 공격자는 이 키들을 제외한 다른 그룹키들을 알 수 없어야 함
    * 전방향, 후방향 안정성을 포함한 개념
* 전방향, 후방향 안정성을 보장하기 위해서는 그룹 멤버가 변할 때 그룹키를 다시 확립해야 함

## 다자간 키 확립 프로토콜의 종류
* 중앙집중형 : 단일 키 분배 서버 사용
* 탈중앙형 : 전체 그룹이 소그룹으로 분리, 각 소그룹의 키 분배 서버
* 분산형 : 키 분배 서버를 전혀 이용하지 않는다

* 단일 시스템이 모든 것을 제어하면 중앙집중
* 한 서버가 모든 것을 통제하지 않고 서버가 여러개거나 없거나 하면 탈 중앙
* 분산은 여러 곳에서 하는 것, 중앙집중은 한 곳에서 하는 것

### Stateless vs Stateful
* Stateful : 모든 키 갱신 세션에 빠짐없이 참여할 경우에만 최신 그룹키를 계산할 수 있는 방식
    * 모든 키 갱신 세션에 참가해야 그룹키 계산 가능
* Stateless : 현재 세션에 전달된 키 갱신 메시지와 초기 상태에 대한 정보만 있으면 과거 여러 세션 동안 키 갱신 메시지를 수신하지 못하였어도 최신 그룹키를 계산할 수 있는 방식
    * 모든 키 갱신 세션에 참여하지 않았더라도 몇몇 정보만 있으면 그룹키 계산 가능

### 유니캐스트 vs 멀티캐스트
서로 다른 m개의 데이터를 n개의 노드로 전송할 때 유니캐스트 멀티캐스트 어떤 것이 이득일까?

m개의 데이터를 다 합친 mn데이터를 n개의 노드로 전송하는 경우
* 유니캐스트 : 특정 노드는 nm 특정 노드는 n크기의 메시지 수신
* 멀티캐스트 : 모든 노드가 크기가 m인 메시지 대신 nm 크기의 메시지 수신

결론적으로 서로 다른 메시지 m개를 n명한테 보내는 경우 mn으로 합쳐서 멀티캐스트로 보내는 것보다 각자 유니캐스트 하는 것이 좋다.

같은 메시지의 경우만 멀티캐스트가 좋다.

### 중앙집중형 키 확립 프로토콜
* 단순 접근 방법 1
    * 중앙 서버는 각 멤버와 장기간 비밀키를 공유하고 있음
    * 설정 프로토콜
        * 중앙 서버는 각 멤베에게 그룹키를 각각의 멤버와 공유한 비밀키로 암호화하여 전달함
    * 가입 프로토콜과 탈퇴 프로토콜
        * 설정 프로토콜을 다시 수행함
    * 설정/가입/탈퇴 비용   
        * 셋 모두 통신비용 O(n) 유니캐스트
        * 서버의 계산비용 : O(n)
        * n은 멤버 수 
* 단순 접근 방법2
    * 중앙 서버는 각 멤버와 장기간 비밀키를 공유
    * 설정 프로토콜 : 단순 접근 방법1과 동일
    * 가입 프로토콜
        * 기존 그룹키로 새 키를 암호화하여 기존 멤버들에게 제공
            * 키는 하나만 쓰면 된다
        * 새롭게 가입한 사용자에게는 그 멤버와 공유한 비밀키로 암호화하여 전달
    * 탈퇴 프로토콜
        * 설정 프로토콜 다시 수행
    * 비용
        * 설정/탈퇴 비용은 방법 1과 동일
        * 가입 비용 : O(1)
        * 통신비용 O(1), 유니캐스트 + O(1) 멀티캐스트
        * 서버의 계산비용 : O(1)

### LKH
중앙집중 방식에서 설정 비용을 줄이고자 제안된 상태 기반 프로토콜

* 중앙 서버가 이진 트리를 내부적으로 유지함
* 단말을 각 사용자의 비밀키
* 모든 노드에 독립적인 키 부여
* 루트 노드에 할당된 키가 그룹키
* 각 사용자는 하나의 단말 노드와 연관되며, 그 노드와 그 노드의 조상 노드에 있는 모든 키를 유지해야 함
    * 사용자 1은 K1, K12, K14, K18 등 자신의 모든 조상 노드의 키를 유지해야 함
* 사용자가 유지하는 키의 개수는 O(log n)
* 중간 노드 키를 부분 그룹키로 활용 가능

#### 가입
* 단말노드의 형제 노드로 가입
* 단말 노드 하나가 층이 하나 낮아짐

트리의 높이 * 2 만큼의 암호문이 있으면 모든 사용자에게 변경된 암호문을 알려줄 수 있다

#### 탈퇴
나간 사람의 조상 노드 키 다 변경

트리의 높이 * 2 만큼의 메시지 필요

### OFT
LKH와 비슷하지만 자식을 해시해서 부모를 계산

* 각 조상노드의 형제 노드들의 해시값을 유지

트리 높이만큼 메시지 필요

기존 사용자는 중간노드 키를 계산하기 위한 절반 정보를 이미 알고 있음

덕분에 LKH대비 절반의 키만 있으면 된다.

### broadcast encryption 기법
LKH, OFT 기법과 동일하게 논리적 키 계층 구조를 사용하지만 루트 노드에 할당된 값이 그룹키가 아님

### 탈중앙형 키 확립 프로토콜
* GSC : 전체 그룹을 관리하는 서버
* GSA : 각 부분 그룹을 관리하는 서버
* 각 사용자는 GSC와 비밀 키 공유
* GSA들은 GSC를 통해 그룹키를 형성하고
* 각 사용자는 자신이 속한 부분 그룹의 GSA를 통해 부분 그룹키를 생성함
* 한 사용자가 전체 그룹 멤버들에게 메시지를 전송하는 과정
    * 부분 그룹키로 멀티캐스트
    * 사용자가 속한 그룹의 GSA는 다른 GSA에게 멀티캐스트
    * 수신한 GSA는 부분 그룹키를 이용하여 그룹 멤버들에게 전송



## CAS(Conditional Access System)
* 유료 방송 환경에서는 가입자만 해당 방송을 볼 수 있어야 함
* CAS는 해당 요구사항을 충족하기 위해 사용하는 정보보호 기술
    * 기존 통신 환경이 일방향(방송국->가입자)만을 사용할 수 있다는 제한점을 고려하여 개발된 기술
    * CAS는 통신 채널에 대한 보호만을 제공함
* 방송 콘텐츠를 암호화하여 전달, 가입자만 이것을 복호화 가능
    * 가입자가 다수이므로 그룹키 개념 필요
    * 가입자에게 적절한 키가 포함된 스마트카드를 발급하며, 사용자는 스마트카드를 자신의 셋톱박스에 설치
    * 지금은 설치된 소프트웨어에 내장되어 사용됨

* 가입/탈퇴 시 그룹키 갱신이 필요하다
    * 매번 그룹키를 갱신하는 것은 현실적으로 어렵다
    * 후방향을 고려하지 않는다고 하여도 전방향은 반드시 제공해야 한다, 따라서 탈퇴시 갱신은 필수
        * 탈퇴 시 즉시 갱신까지는 필요없다?

    * 가입자는 항상 기기를 켜 놓고있지 않으므로 갱신 메시지를 항상 수신할 수 있다고 보장하기 어렵다
        * 비상태기반이 필요
    * 모든 채널의 컨텐츠는 항상 전달되고 있는 방식

* CAS는 세 종류의 키를 사용함(3계층 키)
    * 사용자별 마스터 개인키(MPK) : 공개키 방식
        * 사용자의 스마트카드에 저장되어 있거나 소프트웨어에 안전하게 내장되어 있다
    * AK(Authorization Key) : 보통 채널별 대칭키이며, 갱신 주기는 몇 주
    * CW(Control Word) : 콘텐츠를 스크램블/디스크램블할 때 사용하는 대칭키, 갱신 주기는 5-20초


## 메신저 그룹 채팅 보안
???

* LKH나 OFT를 사용할 수는 없다
* 서버가 그룹키를 관리하는 것은 목적에 어긋난다
    * 중앙 서버가 메시지를 보게 하면 안됨
* 그룹을 만든 멤버가 관리
    * 나머지 멤버에게 키 분배 해야 함
    * 멤버의 추가와 탈퇴가 이뤄지면 갱신되야 함
    * 그룹 관리자가 탈퇴하면?


# 암호화폐

## 암호 화폐 특징
* 위조 어려움
* 휴대가능
* 익명성 보장
    * 완벽한 익명성은 아님, 당사자 외에는 모름
* 양도 가능
* 분할가능
    * 그냥 나누는 것이 아닌, 분할 트랜잭션 있어야 함
* 오프라인 지불 방식
    * 제 3의 중재자의 참여 없이 지불할 수 있음
    * 중재자가 있는 경우는 대표적으로 신용카드
* 범용 지불
    * 지불에 제3의 중재자의 참여가 항상 필요함

## 기존 암호화폐의 유통 시나리오
## 기존 암호화폐 특성 및 문제


## 익명서명기술
발행했다는 사실은 알고있지만

어떤 것을 발행했는지는 모른다

## 은닉성을 이용한 온라인 전자화폐
은행에서는 화폐발급 후 일렬번호로 서명

나눠줄때는 익명서명기술로 서명

몇번 일렬번호에 서명했는지는 모름

단지 50원짜리 2개 줬다고만 기록

## 비트코인
* 자체 강화 방식(탈중앙)
* 오프라인 방식
    * 지불 과정에서 특정 서버의 도움을 받지 않음
    * 하지만 지불 내용은 전체 비트코인 네트워크에 전달하여야 하며, 확정되기까지 일정 시간이 필요함
        * 지불하겠나고 거래 내역 뿌리면
        * OK되면 홍길동 자산이 늘어남
        * 홍길동한테 얘기 안해도 된다
* 양도가능
    * 고객과 상점 간 뿐만 아니라 고객 간에도 화폐를 양도할 수 있다
* 분할 및 통합 가능 
    * 하나의 화폐가 여러 화폐로 나눌 수 있으며, 여러 화폐를 하나로 통합할 수 있다
    * 수수료가 필요하다
* 익명 지불 가능
    * 불관찰성은 제공하지 않는다
    * 지갑 주소만 알면 어디다 사용했는지 알 수 있음
    * 물론 지갑 인당 하나만 사용하라는 법은 없다
* 첨삭만 가능한 분상 원장 사용 : 공개 분산 원장
    * 수정만 가능

## 한기코인(예제)
* 규칙
    * 총장만 코인 제작 가능
    * 코인 양도 가능
    * 거래는 전체 공개
        * 첨삭만 가능한 공개 원장
* 모든 참여자는 공개키 쌍을 가지고 있음
    * 거래를 진행하기 위해서는 상대방의 공개키를 확보해야 함
    * 익명성 때문에 인증서를 사용하지 않음
    * 총장은 인증서를 사용한다고 가정함
* 화폐를 나타내는 별도 디지털 정보는 없다
    * 거래를 원장에 기록해, 이 기록이 화폐의 역할
* 한기코인에서 거래는 헤더, 입력, 출력, 서명으로 구성됨
    * 헤더 : 트랜잭션 타입, 인아웃 개수, 크기 등
    * 입력 : 입력 코인 
    * 출력 : 출력 코인, 수취인
        * 수취인의 공개키로 암호화되어 있다
    * 입력과 출력 모두 여러 개일 수 있음
    * 입력의 소유자는 모두 같은 사람이라 가정함

* 공개 원장에 입력 출력이 있다
    * 출력은 수취인의 공개키로 암호화되어 있다
* 수취인이 사용하고자 하면 개인키로 암호화를 풀면 된다?
* 이전에 사용했던 것 사용하면 안돼니 확인해야 함
    * 누군가는 한단다

* IN으로 들어온 것 중 아직 사용하지 않은 코인이 해당 사용자의 재산
    * 유효히지 않은 거래는 원장에 표함될 수 없어야 한다

* 한기코인 거래의 유효성 확인
    * 하나의 거래를 확인하려고 끝까지 올라가지 않아도 된다
    * 하나의 거래가 확정됬다면 걔는 문제가 없는 것
        * 그 거래의 출력은 무조건 유효한 것
        * 이중사용만 확인하면 된다
    * 그래서 한 사용자의 자산은 트랜잭션의 출력 중 아직 사용하지 않은 것
        * 이것을 UTXO, 사용하지 않은 거래의 출력의 총합
    * 각 **지갑은 자기 주소의 UTXO가 어디있는지 관찰하고 있다**
        * 수시로 갱신한다
    
## 한기코인 문제점
* 발행 문제
    * 총장만 가능, 서명하기 때문에 다른 참여자는 발행할 수 없음
* 거래 내용 변경 문제, 이중 사용 문제
    * 원장 변경 불가
    * 유효하지 않으면 원장에 기록 부락
* 어떻게?
    * 중앙집중식
        * 총장이 유효성 검증 후 유효하면 원장에 반영
        * 원장을 서명하여 수정못하게 함
    * 비트코인은 이것을 탈중앙 방식으로 제공함
        * 블록체인과 보상체계로 구현했다
        * 전자서명, 블록체인, 보상체계, 규칙

## 비트코인의 일반 참여자
* 일반 참여자는 비트코인 지갑을 만들어야 하며, 이 지갑을 만들기 위해서는 공개키 쌍이 필요함
    * 공개키 쌍이 내 지갑의 주소
    * 인증서 기반은 아님
        * 익명성을 위해
    * 공개키는 지갑의 주소 역할을 함
        * 누군지 몰라도 이 주소가 소유주로 되어 있는 코인은
        * 대응되는 개인키 없이는 지불에 사용할 수 없음
    * 한 참여자는 여러 지갑 사용 가능
        * 불연결성 제공
    * 개인키 분실 시 가지고 있던 모든 코인 사용 불가
* 비트코인 지갑은 비트코인 소프트웨어와 달리 다양한 업체가 다양한 형태로 제공

## 비트코인 네트워크와 참여 노드 종류
* 비트코인 네트워크 : P2P 네트워크(모은 노드가 동등 역할)
* 종류
    * 완전 노드(full node)
        * 최초 블록부터 지금까지 모든 블록에 포함된 정보를 유지해야 함
        * 채굴자는 완전 노드를 운영해야 함
        * 완전 노드 운영 동기 
            * 비트코인 건정성에 기여, 투표권 획득
    * 부분 노드 
        * 본인의 거래를 위해 필요한 최소한의 정보만 유지
        * 블록 헤더들만 유지

## 비트코인에서 통신 방식
* 각 사용자는 자신이 생성한 트랜잭션을 전체 네트워크에 전달해야 함
    * 모든 완전 노드에 전파해야 함
* P2P 네트워크에서 한 메시지를 전체 네트워크에 전달하는 방법
    * 에드훅 네트워크에서는 이와 같은 통신 방법을 flooding이라고 한다
        * 한 노드가 메시지를 전송하면 그것을 수신한 모든 노드는 다시 전송함
            * 이미 전송한 메시지는 다시 중계하지 않음

## 비트코인 트랜잭션
입력과 출력으로 구성됨

* 입력 
    * 입력과 출력은 여러 개 일 수 있다
    * 입력의 합은 출력의 합보다 같거나 커야 함
    * 각 입력마다 전자서명 필요
        * 같은 지갑의 UTXO를 사용하더라도 별도 서명 필요
* 출력  
    * 출력의 대상이 지불자와 같게 하여 거스름을 구현함
    * 입력과 출력의 차액은 수수료
        * 수수료는 지불자가 결정
        * 채굴자는 수수료 높은 트랜잭션을 블록에 포함하는 것이 유리
* 비트코인 네트워크에 도움을 주면 수수료
* 다중 입력, 다중 출력 가능
    * 보통 출력은 수수료를 포함하기 때문에 기본적으로 다중

## 탈중앙 암호화폐
탈중앙이기 위해 필요한 것들
* 화폐 발행 문제
    * 탈중앙 적으로 화폐 발행 가능, 임의로는 불가
* 거래 위조 문제
    * 자신이 가지고 있는 만큼만 지불 가능
    * 소유자만 사용 가능
        * 전자서명 기술
    * 유효한 거래만 기록되어야 함
* 이중 사용 문제
    * 한번 기록된 거래는 변경 불가
    * 이전 기록에 대해 수정, 삭제 등이 불가해야 함

## 불가역성의 보장
* 트랜잭션은 전자서명되어 전체 네트워크로 전파됨
* 이 트랜잭션들을 모아 블록을 구성하고 확정
    * 블록의 구성은 채굴자 마음대로
    * 블록에 포함된 트랜잭션은 채굴자가 수정 및 삭제 불가
    * 트랜잭션 수정은 개인키가 있어야 함
    * 기본적으로 수정은 전자서명 때문에 지불자만 가능
        * 블록에 포함된 트랜잭션 삭제 불가
        * 유효 트랜잭션은 블록에 시기적절하게 포함되야 함

* 중앙집중 방식이 아니라 탈중앙 방식으로 불가역성을 제공하고 싶다
* 무결성 보장 기법부터 검토해보자
    * 해시함수, MAC, 전자서명
    * 누구든지 무결성을 안전하게 확인하기 위해서는 3가지 기술 중 전자서명이 유일한 대안
    * 탈중앙 방식으로 전자서명을 활용하여 무결성을 제공 가능?
* 해시함수 문제
    * 원본과 해시값 같이 바꿔버릴 수 있다
* MAC
    * 키 소유자 외에는 무결성 확인 불가
* 전자서명
    * 해시함수보다 비용이 높다
    * 서명자의 권한이 막대
        * 데이터 삭제 가능, 데이터 포함 거부 가능

* 비트코인에서는?
    * 해시값을 사용
    * 일정 기간 동안 발생한 모든 기록을 블록이라는 문서로 통합, 블록에 대한 해시값 계산
        * 블록 크기는 1MB, 전파의 용이성 때문
        * P2P(peer to peer), 모든 노드들이 동등한 역할을 해야 한다
        * 매번 블록이 확정될 때마다 모든 노드에 전파해야 함
        * 크기가 크면 전파하기 힘드니 크기를 1MB로 제한
    * 트랜잭션의 크기는 가변적이지만 대략 0.3KB
    * 최대 3000개 정도 블록에 기록 가능
        * 거래 처리 용량이 제한적
        * 처리 속도가 느리다
* 수정 가능한 것 아닌가?
    * 단순히 H(B)하는 것은 아님
    * 암호퍼즐 사용
        * 랜덤한 난스를 붙여가며 특정한 해시값이 나와야 사용
        * 해시값이 앞에 0이 일정 이상 있어야 한다던가
    * 블록 값 외에 랜덤값 추가, 원하는 형태의 해시값이 나올 때까지 반복
    * 이 반복에 필요한 시간을 조절할 수 있다
        * 현재는 10분정도
        * 0의 개수를 바꾸면 된다
        * 10분정도 걸리면 우연히 동시에 블럭 생성할 가능성 적음

* 트랜잭션을 모아 블록을 만들어 해싱하면 비트코인을 준다??
* 암호 퍼즐을 해결하면 비트코인을 얻을 수 있다!!!
    * 블록에 코인베이스(coin-base) 트랜잭션을 포함됨!!
        * 입력 없이 정해진 금액을 채굴자에게 지급하는 형태의 트랜잭션
* 10분 정도의 노력을 하면 계산 가능
    * 이 때문에 이를 작업 증명(proof-of-work)이라 함
        * 작업을 했으니 얻을 수 있었을거니까
        * 작업의 증명
* 아직 시간이 오래걸릴 뿐 수정은 가능

* 불가역성을 제공하기 위해 블록들을 연결함
    * 블록에 대한 해시값을 계산할 때 이전 블록의 해시값을 포함
    * 이 체인은 중단없이 계속 생성되는 성질이 있다
        * 게속 생성되서 조작하기 힘들다
    * 중간 체인값이 바뀌면 그 이후 모든 값이 무효
    * 한 블록만 바꾼다고 수정이 가능한 것이 아님

* 비트코인 암호 퍼즐 해결은 확률적인 프로세스
    * 조건 맞춘 헤시값 계산이니까?
* 동시에 여러 사람이 해결 가능
    * 일시적 포크라 한다
    * 일시적으로 여러 갈래로 나뉨, 사람들은 둘 중 아무데나 붙는다
    * 언젠가는 더 긴 체인이 나타남
    * 그러면 짧은 쪽은 무효화된다
    * 블록 깊이가 6보다 커지면 취소될 확률 거의 없어짐
* 그래서 비트코인에서는 **가장 긴 체인을 운선**하는 원칙이 있다
    * 이처럼 암호화폐는 규칙을 통해 문제를 해결하는 경우가 많음
    * 유효 체인에 자신이 생성된 블록이 들어가야 보상을 받을 수 있음

* 비트코인 문제점
    * 한 블록에 들어가는 트랜잭션도 적다
    * 10분마다 블록이 생성되서 느리다
    * 블록이 생성되도 확정되러면 1시간은 있어야 함

## 채굴자의 역할과 프로세스
* 트랜잭션 수신
    * 트랜잭션 유효성 확인
        * 이중사용
    * 유효하면 풀에 넣는다
* 블록 수신
    * 블록 유효성 확인
        * 안에 유효한 트랜잭션만 들어가있는지
        * 해시값들이 올바른지 확인
    * 유효하면 새 블록 시작
* 블록 생성 경쟁
    * 풀에서 블록에 포함될 트랜잭션 선택
    * 암호 퍼즐 해결
        * 난스값 합쳐서 해싱해서 0이 일정 이상
    * 블록 수신 전 해결하면 블록 전파
        * 누가 먼저 보내면 실패한 것
        * 새로운 블럭 생성 시작
        * 새로운 블록에는 이번에 온 블록에 포함되지 않은 트랜잭션 넣는다

## 채굴 보상
* 신규 비트코인 + 블록의 트랜잭션 수수료
* 현재는 채굴에 성공하면 6.25BTC
    * 확률적인듯
* 일정 주기마다 채굴 성공 비트코인 절반으로 준다
* 총 발행될 코인수는 21,000,000

* 수수료는 지불자 마음대로 정할 수 있다
* 하지만 해당 거래 트랜잭션을 블록에 넣을지는 채굴자 맘
* 수수료 높으면 거래가 빨리 될 수 있다

## 51% 공격
* 한 주체가 전체 해시 파워의 51% 차지
* 더 빨리 계산할 수 있어 생태계 교란이 가능하다

* 이중 사용
    * 이전 트랜잭션에서 블록 제거하고, 해당 트랜잭션의 사용된 코인으로 새 트랜잭션 구성
* 서비스 교란
    * 기존 유효한 트랜잭션 무효화 가능

## 작업 증명
* 비트코인에서 사용하는 **분산 합의 기술**
    * 전세게 모든 노드는 똑같은 블록값을 유지한다
    * **똑같은 블록값을 유지하도록 해주는 기술**
    * 비트코인은 **작업 증명이라는 블록체인**으로 구현
    * 채굴자가 수행
* 작업 증명의 문제
    * 전기 소비로 인한 환경 파괴
* 그래서 지분 증명(PoS)과 같은 새 방법이 제안됨

## 하드포크 vs 소프트포크
* 노드마다 사용하는 소프트웨어 버전이 다를 수 있다

* 하드포크 : 규칙 변경이 과거와 호환되지 않음
    * 새로운 블록체인
    * 같이 진행한다
    * 합치려면 다른 한쪽이 이때까지 얻었던 이득을 포기해야 하기 때문에 합치기 쉽지 않다
* 소프트포크 : 규칙 변경이 과거와 호환

## 비트코인 개선
* 세그윗
    * 서명값은 따로 거래하자
    * 트랜잭션에는 서명값이 가장 큰 공간을 차지함
    * 서명값은 별도 전파
    * 소프트포크

* 지불 채널
    * 거래할 경우 모든 내용을 기록하는 것이 아닌 최종 결과만 기록하자

## 지불 채널
* 다중 서명 지갑
    * 여러 공개키를 하나의 지갑과 임계 기반 형태로 연결
    * 여러 공개키를 지불자, 판매자, 중재자 이렇게 나눠가짐
* 공통 지갑
    * 참여자 모두 또는 다수 서명해야 사용 가능
    * 지불자는 미리 일정금액 지갑에 지불
    * 사용하는 것에 따라 트랜잭션 게속 생성
    * 마지막 트랜잭션을 닫고 거래
* 문제점
    * 지불자와 받는 사람이 있다, a와 b라 한다
    * b가 트랜잭션을 끝까지 닫지 않는 경우
        * a와 b 모두 손해
        * a는 지갑에 미리 지불한 금액을 전부 날린다
        * 그래서 b는 a에게 패널티 트랜잭션 주어야 함
    * a가 패널티 트랜잭션을 블록에 등록하는 경우
        * b는 손해
        * 잠금 장치를 걸어, 일정 시간이 지나야 등록할 수 있도록 해야 한다
        * 시간이나 일정 블록 길이 후에 유효하도록 잠금
    * 시험에는 안나올듯???

## 비트코인 블록체인의 특성
* 10분마다 게속 생성됨
    * 그래야 안전하고 가치가 유지된다
    * 누군가 수정할 수 없다, 이중지불도 이래서 불가능
    * 가장 긴 체인을 사용하기 때문
* 첨삭만 가능
* 분산 저장
* 공개형 블록체인
    * 누군든지 저장, 열람, 참여 가능
* 오픈소스

## 비트코인 안정성
* 발행
    * 채굴을 통해서만 가능
* 기존 거래 내역 수정
    * 수정하면, 그 내역이 포함된 블록을 새롭게 채굴해야 함
    * 이후 모든 블록까지 다시 채굴
    * 긴 체인이 우선되는데, 10분마다 게속 채굴되기 때문에 따라잡을 수 없다
    * 강력한 채굴자 등장 시 위험

## 문제점
* 화폐 기능
    * 가치가 변동심함
* 코인 거래소 등장
    * 기존 시스템과 차이가 줄어듬
* 채굴의 중앙 집중화    
    * 채굴자와 사용자가 명백하게 구분
* 환경파괴
* 확장성 문제
    * 세그윗, 지불채널 등 다양한 확장 방안이 도입되거나 검토되고 있다
* 블록크기의 제한과 블록 생성 속도


# 블록체인 2.0
* 일반 데이터 대신 프로그래밍 코드를 블록체인에 기록하자
* 특정 조건이 충족되면 자동으로 실행된다
* 장점
    * 실행될 것이 모호하지 않다
    * 무결성 측면에서 안전하다
        * 일관성, 정확성, 유효성이 보장
* 이더리움

## 이더리움
* 이더리움은 암호화폐가 아닌 프로그램을 실행할 때 지불할 돈
* 15초마다 새 블록 생성, 각 블록마다 5개 발행
* 지속적 발행, 제한이 없음
* 코드를 블록체인에 등록 가능
    * 코드는 모호하지 않고, 무결성까지 보장
    * 이 소스는 각 참여자의 컴퓨터에서 실행 가능
        * 자바와 비슷한 EVM을 사용

## UTXO Model vs Account Model
* UTXO 방식
    * 거래위해서는 지불자가 비트코인이 있는지 블록체인 뒤져서 알아내야 함
    * 각 UTXO는 개별적, 독립적으로 검증 가능
* Account 모델(계정 기반 모델)
    * 한 사람이 보유한 총액을 별도 DB화
    * 카운터 값이 있고, **카운터값을 이용하여 이중사용 여부 확인**
    * 병행으로 불가, 순차적으로 해야 함
    * 각 계정들이 순차적

차이
* UTXO
    * 트랜잭션 내용 복잡
    * 지갑이 주소 관련 UTXO를 관리
    * 병행으로 처리 및 검증
    * 여러 주소를 사용하여 강한 프라이버시 제공 가능
    * 모든 입력은 유효해야 함
        * 아직 지불에 사용하지 않았다는 뜻
    * 모든 입력 소유자의 유효한 서명이 있어야 함
    * 입력의 총액이 출력의 총액보다 커야 함
        * 참고로 통째로 사용하고 거스름돈을 받던가
        * 트랜잭션을 사용해서 쪼개든가 해야하지
        * 일점 BTC만 사용하고 그런 것 없다
* 계정 기반
    * 기존 은행 모델과 같다
    * 트랜잭션 내용이 단순함
    * 잔액만 유지
    * 모든 노드가 모든 계정의 잔액 정보를 유지해야 함
    * 한 계정의 거래는 순차적으로 처리
    * 프로그래밍하기 용이
    * 여러 계정을 사용할 수 있지만, 보통 같은 계정을 계속 사용하도록 유도
    * 거래
        * 한 계정에서 다른 계정으로 금액 이동
        * 계정에 충분한 금액이 있으면 유효한 지불

## Gas Limit, Gas Price
* 처리 비용은 가스 상한과 가스 비를 통해 제시한다
    * 수수료는 EVM에서 코드 실행 비용
        * 비트코인은 입력과 출력의 차로 수수료를 나타낸다면
        * 이더리움은 별개로 수수료를 나타내야 함
            * Gas Limit, Gas Price
        * 이더리움의 트랜잭션은 코드
        * 코드를 수행하기 위해서는 가스가 필요
            * 수행해달라는 의뢰자가 가스비 결정
        * 특정 코드 실행 비용은 예측할 수 있음
    * 소요되는 가스는 limit보다 적어야 함
        * 초과하면 취소되지만 수수료는 그대로 지급됨
        * ???

## 이더리움의 트랜잭션
* 구성요소
    * 카운터
    * 수수료 정보 : 가스 상한, 기스 비
    * 대상 계정 정보 : EOA계정 또는 스마트 계약 계정
    * 금액
    * 데이터 : 스마트 계약 실행을 위한 정보(함수 호출)
    * 전자서명 값(ECDSA)
        * Sender 정보 포함
    
## 이더리움 채굴과 작업 증명
* 채굴 단계
    * 새 트랜잭션을 수신하면 mempool에 저장
    * 블록 생성에 15초 소요됨
        * 비트코인은 10분
        * 10분이라 우연히 겹치는 일시적 포크가 적지만
        * 확정되는 속도 느리고 1MB라 초당 처리가능한 트랜잭션 수도 적다
        * 15초라 빠르다
    * 블록의 크기가 어느 정도 제한되어야 변경 사실을 빠르게 전파할 수 있다
        * 이더리움에서는 포함가능한 가스를 적게 하므로써 제한
            * 얻을 수 있는 수수료 제한
    * 새 블록을 채굴할 시점이 되면 블록에 추가할 트랜잭션을 선별한다
    * 15초마다 새 블록이 생성되기 때문에 임시 포크가 빈번히 발생
        * 유효하지만 블록에 포함되지 못한 블록을 Uncle이라 한다
* 가장 긴 체인 원칙
    * 가장 긴 것을 사용하지만 Uncle 블록에 대해서도 보상한다
    * 채굴 보상 7/8 정도는 준다

## 스마트 계약
프로그래밍을 통해 스마트 계약을 작성하여 블록체인에 등록 가능

* 자율성 : 중재자 없이 자동 실행
* 신뢰 : 계약이 투명하고 자동 실행되기 때문에 안전
* 백업 : 자동으로 중복 저장
* 안정성 : 계약의 조작 가능성이 계산적으로 힘듦

* 잘못 올라간 경우 수정할 수 없다는 단점이 있다

## 계정의 종류
* EOA
    * 비트코인 계정과 유사
        * 공개키 쌍으로 제어
    * 이더 잔액 유지
    * 다른 EOA로 ETH전송 가능
    * CA로 트랜잭션을 보내 코드 활성화
    * 스마트 계약 저장 가능
* CA
    * 단순 계약 계정
    * 이더 잔액 유지
    * 스마트 계약이 저장
        * 프로그래밍 코드가 저장
    * 스스로 트랜잭션 생성 불가
    * 다른 EOA나 CA로부터 트랜잭션을 받으면 계약이 실행
        * 스스로 활성화되지 않는다
        * 수행하기 위해 비용 지불이 필요하다

## DApp
* 탈중앙 앱
* 수수료로 이더리움
* 스마트 계약을 

## 토큰과 ICO


## 지분 증명
* 블록을 생성할 수 있는 검증자를 결정적 방법으로 결정한다
    * 블록 생성을 통해 화폐를 발행하는 것이 아님 
* 검증자를 선출, 결정적 방법으로
    * 검증자를 선출한다
        * 기준을 정하든 랜덤으로 하든
    * 검증자가 블록이상여부를 확인한다
    * 검증자가 블록 생성하여 넣는다
        * 검증자 서명
    * 입회자는 이상없나 확인하고 투표한다
        * 입회자도 서명
* 경쟁하지 않는다
    * 불가역성은 여전히 제공

* 검증자는 이더리움 예치하고 헛짓하면 날림
    * 이걸 슬래싱
* 결정방법에 따라 다양한 PoS 가능
* 하여튼 이렇게 검증자 뽑아서 투표

## 공간 증명
* 일정한 크기의 디스크 공간을 소모하였음을 증명하는 방법
    * 작업 증명은 일정 연산을 수행하였음을 증명
    * 가지고 있는 디스크 공간에 랜덤한 데이터를 저장해야 하며, 정기적으로 이 데이터를 계속 해당 공간에 유지하고 있다는 것을 증명해야 함


## DAG