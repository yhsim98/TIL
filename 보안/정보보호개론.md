# 보안 목적
1. 비밀성(confidentiality, secrecy. privacy) 
* 인가된 개인, 단체, 장치, 프로세스만 데이터의 내용을 볼 수 있도록 해주는 서비스

2. 무결성
* 비인가된 데이터의 변경을 발견할 수 있도록 해주는 서비스
* 변조가 된것을 알 수 있도록 한다

비밀성은 보장되어야 하는 서비스지만 무결성은 발견만 할 수 있으면 된다.

3. 인증
* 식별 + 검증
* 누구인지 신원을 증명하는 것
* 메시지 인증 : 무결성과 동일, 메시지가 변경되지는 않았는지 아는 것
* 메시지 원천지 인증 : 무결성 + 메시지가 송신된 위치 또는 송신자를 검증
* 개체 인증 : 주장된 신원을 검증
    * 개체 인증에 사용되는 요소3가지
        * 사용자만 알고 있는 지식 : 패스워드
        * 사용자만의 독특한 특징 : 생체정보
        * 사용자만이 가지고 있는 것 : ID 카드

4. 부인방지(non-repudiation)
* 개체가 지난 행위나 약속을 부인하지 못하도록 하는 서비스
* 송신 부인방지 : NRO
* 전달 부인방지 : NRD
* 제출 부인방지 : NRS
* 수신 부인방지 : NRR

* 토큰의 종류가 중요한 것은 아니다
* 직접 통신하는 경우와 중계자를 이용하여 통신하는 경우가 있다
* 부인방지 토큰은 보통 해당 행위를 부인할 수 있는 주체가 제공하는 것

 
 # 프라이버시
개인이나 집단이 자신 또는 자신의 정보를 선택적으로 노출할 수 있는 권리

디지털 서비스를 사용할 때 교환된 통신 메시지를 통한 노출을 고려한다.

프러이버시 종류
* 내용 프라이버시
    * 어떤 컨텐츠 사용
    * 비밀성 서비스를 통해 제공할 수 있다
* 행동 프라이버시
    * 어떤 서비스를 사용하는 것 자체를 숨김
* 위치 프라이버시
    * gps 막는거


행동 프라이버시 보장을 위한 요구사항
* 불관찰성 : 특정 메시지의 송수자 또는 수신자를 알 수 없어야 한다
* 불연결성 : 두 개의 메시지가 주어졌을 때, 두 개의 메시지가 동일 송신자가 전송한 것인지 또는 두 개의 메시지가 동일 수신자에게 보내는 것인지 연결할 수 없어야 한다는 것을 말함
* 불연결성은 특정 메시지의 불관찰성이 깨졌을 때 그 파급효과를 최소화하기 위해 제공되어야 한다

## 조건부 프라이버시
완전 프라이버시를 제공하면 사용자들에 의해 악용될 수 있기 때문에 대신 조건부 프라이버시를 제공함

필요한 경우 익명성 철회 가능

익명을 철회하는 권한 남용을 피하기 위해 여러 기관에 권한을 분산하는 것이 필요함
* 임계 기반 비밀 공유기법
* n명에게 특정 권한을 분산하고, 이 중에 t명 이상이 동의하면 해당 권한을 수행할 수 있도록 한다
* t는 보안 강도를 조절하기 위한 보안 변수이다
* 가용성 측면에서 (n, n)은 바람직하지 않은 형태의 서비스

# 통신 계층과 암호기술
통신 메시지의 비밀성/무결성을 보장하기 위한 암호기술의 적용과 통신 계층간의 관계

end-to-end
* 장점
    * 통신망과 독립적으로 수행 가능
    * 기반구조를 신뢰하지 않아도 됨
* 단점
    * 트래픽 분석이 가능
    * 메시지 단위로 암호화하기 때문에 오류 발생시 암호화하는 방식에 따라 재전송해야 하는 부분이 클 수 있음

hop-by-hop
* 장점
    * 트래픽 분석이 가능하지 않음
    * 패킷 단위로 암호화가 가능하므로 오류 발생시 해당 패킷만 재전송
* 단점
    * 통신망의 각 호스트/스위치에 기능이 포함되어야 함
    * 기반구조를 신뢰해야 함(중산 호스트/스위치는 평문을 볼 수 있음)
    * 반복적으로 암호기술을 적용하기 때문에 효율성이 떨어짐



기본 용어
* 평문
* 암호문
* 암호화
* 복호화

# 암호알고리즘
* 좁은 의미 : 암호화 복호화 과정에 사용하는 수학 함수
    * 비밀성 서비스 제공이 목적
* 넓은 의미 : 암호 기술에서 사용하는 모든 알고리즘
    * 다양한 목적
* 현대 암호화 함수와 복호화 함수는 모두 키를 사용
    * ``E. K(M) = C, D.K(C) = M
* 암호키(cryptographic key) : 암호화/복호하에 사용하는 키
    * 현대 알고리즘의 안성성은 키에 의존하고, 알고리즘 자체는 공개한다

## 제한적 알고리즘
현대 알고리즘의 안성성은 키에 의존해야 한다

키 대신에 알고리즘의 비밀성에 의존할 경우 **제한적 알고리즘**이라 한다.

제한적 알고리즘
* 장점
    * 해독하기가 힘듦
* 단점
    * 알고리즘을 공유할 수 없음
    * 역공학의 가능성이 존재함
    * 노출될 경우에는 알고리즘 자체를 변경해야 함

키 의존 알고리즘
* 장점
    * 알고리즘 공유가 가능
    * 키가 노출되면 키 자체만 변경 가능
    * 알고리즘이 공개되어 있으므로 허점의 발견이 용이함
        * 알고리즘 개선에 사용
* 단점
    * 알고리즘이 공개되어 있으므로 허점의 발견의 용이함
    * 악의적인 목적으로 사용 가능

## 키용어
사용 기간 또는 횟수에 의한 분류
* 단기간키, 세션키, 일회용키
    * 매우 제한적으로 사용하는 키
    * 생성 후 일시적으로 사용 후 폐기하는 키
    * 비휘발성 메모리에 유지할 필요가 없는 키
* 장기간키, 다중사용키
    * 여러 번 사용하는 키로 비휘발성 메모리에 유지해야 하며, 안전한 키 관리가 중요함

## 암호 알고리즘의 분류
결정적 vs 확률적
* 결정적 알고리즘 : 입력이 같으면 항상 같은 결과를 반환
* 확률적 알고리즘 : 같은 입력이라도 결과가 항상 다름

대칭 vs 비대칭
* 대칭 알고리즘 : 암호화할 때 사용하는 암호키와 복호화할 때 사용하는 암호키가 같은 암호알고리즘
* 비대칭 암호알고리즘 : 암호화할 때 사용하는 암호키가 복호화할 때 사용하는 암호키가 다른 암호알고리즘


## 대칭 암호 알고리즘
* 비밀키 알고리즘
* 암호화하는 사람과 복호화하는 사람이 같은 키를 가지고 있어야 함
* 종류
    * 스트림(stream) 암호방식 : 평문의 각 바이트를 하나씩 암호화하는 방식
    * 블록(block) 암호방식 : 평문을 일정한 블록 크기로 나누어, 각블록을 암호화 하는 방식

## 합성 암호 알고리즘

# 암호화 모드
블록 암호방식을 사용하는 대칭 알고리즘은 항상 고정된 크기의 블록을 입력으로 사용함

블록방식은 항상 입력의 크기가 같기 때문에 입력의 크기가 부족하면 평문을 블록크기로 만들기 위한 **채우기**가 필요하고 크면 나누어야 한다

* 암호화 모드 : 블록 암호방식에서 블록 크기보다 큰 평문을 암호화하는 방법을 말함

가장 단순한 암호화 모드는 나누어진 개별 평문 블록들을 독립적으로 암호화하는 ECB, 지금은 안씀

## 대칭 암호알고리즘의 사용 용도
* 공개 채널로 전달하는 메시지에 대한 비밀성 보장
    * 송수산자가 공유하는 비밀키로 메시지를 암호화하여 교환함으로써 제 3자가 도청하여도 내용을 알 수 없게 한다
* 기억장치에 저장하는 데이터에 대한 비밀성 보장 
    * 다른 사용자가 저장된 데이터를 열람할 수 없도록 데이터를 암호화하여 저장할 수 있음. 키의 백업이 중요하다(랜섬웨어)
* 개체 인증
    * 서로가 비밀키를 공유하고 있는 경우 서로가 서로임을 확신할 수 있음


## 법 강화를 위한 키 위탁
키 위탁은 키를 복구하기 위해서도 유용하게 사용될 수 있음

# 비대칭 알고리즘
공개키와 비밀키를 사용

각 사용자는 공개키는 공개하고 개인키는 비밀스럽게 유지함

공개키 알고리즘이라고도 한다.

## 사용용도
대칭 알고리즘과 같은 용도로 사용 가능하지만, 상대적 성능문제 때문에 보통 메시지 자체를 암호화하는데 사용되지 않는다.

이 때문에 다음과 같은 하이브리드 방식을 많이 사용함
* {M}.k, {K}.+Ka
* 공개키는 작은 정보만 암호화, 나머지는 개인키로

# 인증서
공개키를 인증할 때 사용되는 전자문서

신뢰할 수 있는 인증기관이 전자서명하여 생성함

인증기관이 공개키를 공증해 준다

## 인증서의 검증
사용자들은 다른 사용자의 공개키를 사용하기 전 인증서를 검증하여 공개키의 사용자를 확인해야 함

인증서를 검증하기 위한 절차
1. 인증서의 서명 확인
2. 인증서의 유효기간 확인
3. 인증서의 사용 용도 확인
4. 인증서의 폐지 여부

위 4가지 단계를 통해 한 번 확인된 인증서는 보통 캐시(또는 파일 시스템)에 보관하며, 이 인증서를 같은 용도로 다시 사용할 경우 유효기간과 폐지기간만 확인함


## 인증서 폐지


# 신원기반 암호시스템
* 공개키 암호알고리즘의 사용에서 공개키의 인증은 매우 중요함
* 인증서를 사용하기 위해서는 공개키 기반구조가 잘 확립되어 있어야 한다
* 인증서 외에 **신원기반 공개키 암호시스템**
* 결국 안씀

* 상대방의 독특한 신원정보로부터 공개키를 유도
* 인증서가 필요없고 다른 사용자의 공개키를 직접 생성 가능

## PKG
* 사용자는 자신의 개인키를 직접 만들 수 있음
    * 자신 뿐만 아니라 다른 사용자의 개인키도 생성 가능
* 이 때문에 신원기반 시스템에서는 사용자의 개인키를 발급하여 주는 PKG라는 신뢰 기관을 사용한다
* 사용자의 개인키는 누구나 생성할 수 있는 해당 사용자의 공개키와 PKG가 비밀로 유지하는 마스터키를 이용하여 생성한다
* PKG는 모든 사용자의 개인키를 만들 수 있으므로 모든 암호문을 복호화할 수 있고, 모든 사용자의 서명을 위조할 수 있다
    * 부인 방지에 취약하다
    * 임계 기반 비밀 공유 기법 활용
        * 여러 기관에 발급 권한을 분배하여 n명중 t명 이상이 협조해야 사용자의 개인키 생성 가능

## 사용자의 신원정보
공개키를 변경하고 싶다면, 신원정보나 PKG의 개인키를 변경해야 함

둘 다 힘듬

이 문제를 해결하기 위해 추가적인 값을 추가한다

대신 추가된 정보를 알아야 상대방의 공개키를 만들 수 있다는 문제가 생긴다


## 중앙집중 인증서 기반 PKI vs 신원기반


## DPKI
* 탈중앙 PKI
    * 중앙집중 인증기관이 인증서를 발급하는 것이 아님
    * 각 개체가 스스로 인증서를 발급하고 관리하는 형태
        * 기존 pki의 ca에 관한 집중 문제를 해결하는 것이 목적
        * 단일 실패점이 사라짐
* 동작 원리
    * 블록체인에 일정한 형식을 갖춘 ID와 공개키를 연결하는 문서를 저장
    * 블록체인이 기존 PKI에서 공개 디렉토리 역할을 한다
    * ID와 실제 개체와의 연결은 다른 방법을 사용
        * 보통 신뢰관계를 점진적으로 확장하는 방법 사용
            * 오프라인에서 서로 교환, 기관 홈페이지에 기관 ID 게시 등

* 블록체인의 특징
    * 불가역성 : 수정, 삭제 불가 삽입만 가능
    * 분산 저장
    * 합의 기술을 이용하여 일관성 유지

# FIDO
Fast Identity Online 지문 인증, 공개키 방식이다.

동작과정은
1. 공개키를 생성하여 서버에 등록한다.
2. 


# 해시함수
임의의 길이에 이진 문자열을 고정된 길이의 이진 문자열로 매핑하여 주는 결정적 함수 

특징
* 압축
* 계산의 용이성
    * x -> f(x) 는 편해야 함
* 일방향성
    * 입력을 모르는 해시값 y가 주어지면 ``H(x`) = H(x)`` 인 x`은 찾기 어려워야 함
* 약한 충돌회피성
    * x가 있을 때 H(x`) = H(x) 인 x를 찾는 것은 어려워야 함
    * x랑 해시값 같은 x` 값 찾기 어려워야 함
    * 같은 값이 나올 확률은 1/2????
* 강한 충돌회피성
    * H(x`) = H(x) 인 서로 다른 임의의 두 입력 x을 찾는 것은 어려워야 함
    * 해시값이 같은 두 값을 찾기 어려워야 함
  
## 생일 파라독스
N 명중 특정 사람 한명과 생일이 같은 사람을 찾기 위해서는 n 이 183명이 되야 하지만, n명중 생일 같은 두 사람을 찾으려면 23명만 있으면 된다

루트 씌우면 됨

## 해시함수의 용도
* 전자서명
    * 서명 크기와 계산 비용을 줄이기 위해 전체 메시지 대신에 메시지의 해시값에 서명함
    * 충돌 회피성이 그래서 중요함
 
 # MAC
* 해시함수는 보통 비밀키를 사용하지 않음
    * 단순히 메시지의 변경 여부를 판단하기 위해 사용하는 해시값을 조작 탐지 코드라 한다
* 비밀키를 추가로 사용하면 송신자의 인증과 무결성을 동시에 제공할 수 있으며, 결과 값을 메시지 인증 코드(MAC)라 한다
    * MAC을 사용하기 위해서는 생성자와 확인하는 사람이 동일한 **대칭키**를 공유하고 있어야 함
* MAC도 해시함수와 같은 요구사항을 충족해야 하며, 추가로 위조가 가능하지 않아야 한다
* MAC을 만드는 방법
    * MAC 전용 알고리즘을 이용하는 방법
    * 대칭 알고리즘을 이용하는 방법

# 무결성
메시지가 변조되지 않았다는 것을 확인하는 것

메시지랑 해시값을 전부 바꾸면 수신자는 변경사실을 알 수 없음

* 해결법 1. MAC
    * MAC값을 알아야 하기 때문에 변조 못함
    * 키를 사전에 공유해야 한다는 문제점
    * 같은 키가 여러개니 누가 만들었는지는 모른다
* 해결법 2. 전자 서명
    * 값이 바뀌면 전자서명이 유효하지 않아 변조하면 알 수 있다
    * 공개키만 수신자가 있으면 되므로 누구나 확인 가능
    * 누구나 만들수는 없다
    * 효율은 mac이 좋다

# 무결성과 비밀성을 동시에
* 인증 암호화 : 비밀성과 무결성을 동시에 제공하는 방법

1. 암호화할 때 해시값 또는 MAC값을 포함하는 방법
2. 메시지에 독립적으로 대칭암호알고리즘과 MAC을 적용하는 방법
    * JWT
    * 메시지는 알 수 있다
    * 무결성만 확인
3. 메시지를 암호화한 후 암호문에 대한 MAC 값을 계산하는 방법
    * encrypt-then-mac 
    * mac 값이 확인되지 않으면 복호화를 하지 않음
    * 암호화하고 암호문을 MAC 
    * 나머지는 복호화를 무조건 해야하지만 얘는 아님
    * 가장 안전

# 일반 서명과 전자서명의 차이점
* 전자서명은 수학적으로 서명자를 검증할 수 있음
* 전자서명의 안전성은 동일한 알고리즘을 사용할 경우에는 사용자마다 같은 안전성을 제공함
* 일반 서명은 문서 위에 하지만 전자서명은 보통 문서와 별도로 존재함
* 전자서명은 원본과 복사본을 구분하기가 힘듦


## 전자서명의 요구사항
* 인증(authntic) : 누가 서명했는지 확인이 가능해야 함
* 위조불가 : 위조불가
* 부인방지 : 나중에 부인할 수 없어야 함
* 재사용불가 : 서명은 다른 용도로 사용할 수 없어야 함
* 변경불가 : 서명된 문서의 내용을 변경할 수 없어야 함


# 전자서명 방식의 종류
* 직접 서명 방식 : 서명자가 홀로 서명 알고리즘을 수행하여 서명하는 방식
* 문제점. 서명키의 분실/도난
    * 서명자가 직접 서명 시간을 서명에 포함할 경우에는 서명키를 획득한 공격자의 부정을 증명할 방법이 없음
* 중재 서명 방식 : 중재자와 프로토콜을 수행하여 서명하는 방식
    * 중재자는 서명의 증인 역할을 하게 됨
    * 서명자가 시간에 대한 부정을 할 수 없음
    * 중재자는 신뢰기관이어야 함

# 전자서명 알고리즘의 분류
메시지 복구 여부에 따른 분류
* 메시지 복구 가능 전자서명 알고리즘
    * 작은 메시지에 대해서만 가능
* 첨부 형태 전자서명 알고리즘
    * 메시지와 서명 블록이 별도로 존재하며, 메시지와 서명 블록이 함께 제시되어야 검증 가능
    * 보통 해시함수를 이용함

결정 vs 확률 서명 알고리즘
* 결정 서명 알고리즘 : 메시지가 같으면 항상 결과 서명이 같은 알고리즘
* 확률 서명 알고리즘 : 메시지가 같아도 서명할 때마다 그 결과가 달라지는 알고리즘


# 암호알고리즘에 대한 안정성
* 암호알고리즘 : 복호하키를 모르는 상태에서 암호문으로부터 평문이나 키를 얻을 수 없어야 한다
    * 평문이나 키의 일부도 얻을 수 없어야 한다
    * 공개키 암호알고리즘은 공개키로부터 개인키를 얻을 수 없어야 한다

* 해시함수 : 해시값의 역이나 충돌을 찾을 수 없어야 한다
등등

# 현대 암호학의 특징
* 과거에는 오랫동안 허점이 발견되지 않은 것을 안전한 것으로 여긴다
* 오늘날에는 엄격한 안정성 증명을 중요하게 생각함

* 무조건적 안정성 : 무한한 컴퓨터 자원을 가져도 암호알고리즘을 해독할 수 없는 경우
* 계산적 안정성 : 공격자의 능력이 현실적일때 해독하기 위한 노력이 불합리하게 많은 컴퓨터 시간을 요구할 경우
    * 증명가능 안정성 : 어렵다고 알려진 문제와 등가임을 증명함

## 완벽한 안정성 vs 의미론적 안정성
완벽한 안정성은 현장에서는 사용 불가

계산적 안정성만 있어도 현장에서 사용 가능하다

이 때문에 등장한 개념이 의미론적 안정성

## 암호해독 공격의 분류
* 전사 공격 : 가능한 모든 키를 검사하는 방법
    * 암호해독 공격은 아님
* 암호문 단독 공격
    * 공격자가 암호문만 얻을 수 있는 경우
* 기지 평문 공격
    * 공격자가 특정한 개수의 평문과 암호문 쌍만을 얻을 수 있음
* 선택 평문 공격
    * 특정한 개수의 평문과 암호문 쌍을 얻을 수 있지만 공격자는 원하는 평문을 선택할 수 있음
* 선택 암호문 공격
    * 원하는 암호문
* 적응적 선택 평문 공격 
    * 이전에 얻은 쌍들을 바탕으로 추가적으로 원하는 평문을 얻을 수 있음
* 적응적 선택 암호문 공격 
    * 이전에 얻은 쌍들을 바탕으로 추가적으로 원하는 암호문을 선택할 수 있ㅇ듬



## 공격의 복잡성 척도
* 데이터 복잡성 : 공격이 성공하기 위해 필요한 데이터의 양
    * 공격에 성공하기 위해 필요한 평문/암호문 쌍
* 처리 복잡성 : 공격이 성공하기 위해 필요한 시간
    * 병렬처리 가능 여부
* 저장공간 요구사항 : 공격하기 위해 필요한 메모리 공간

## 알고리즘에 대한 공격 결과
* 완전 성공 : 암호키 발견
* 광역 성공 : 암호키를 발견하지 못했지만 복호하할 수 있는 알고리즘 발견
* 인스턴스 성공 : 어떤 암호문으로부터 그것의 평문을 얻어냄
* 정보 추출 : 암호문으로부터 평문의 일부나 암호문의 일부를 알아냄

## 부채널 공격
부채널 : 알고리즘의 입력과 출력 외에 다른 정보를 이용하는 것

암호화에 걸리는 시간이나 걸리는 전력양 계산

## 양자컴퓨팅과 암호기술
* 아직 현실화되지는 않음


# 암호프로토콜
## 프로토콜
어떤 목적을 달성하기 위해 2명 이상이 참여하는 유한한 일련의 단계

프로토콜의 특성
* 사전에 서로 알아야 함
* 참여자 간에 동의하고 있어야 함
* 모호하지 않아야 함
* 완정성 : 완전해야 함

프로토콜 : 어떤 목적을 달성하기 위해 2명 이상이 참여하는 유한한 일련의 단계

트랜스크립트 : 한 수행에서 교환된 메시지들

암호 프로토콜 : 암호 기술을 사용하는 프로토콜

일반 프로토콜과의 차이점 : 공격자의 존재를 가정하고 만든다

일반 프로토콜 : 완전성

암호프로토콜 : 완정성 + 안정성


## 암호프로토콜에 대한 공격
공격의 종류
* 수동 공격 : 프로토콜의 진행을 방해하지 않는 공격
* 능동 공격 : 프로토콜의 진행에 개입하는 공격

공격 방어의 기본은 공격 사실을 인지하는 것

## 프로토콜의 참여자
실제 사용자를 의미할 수 있고, 사용자가 사용하는 장치 또는 소프트웨어일 수 있음

참여자의 분류
* 일반 참여자
    * 프토콜을 통해 얻고자 하는 것이 있는 이해 당사자
* 제 3기관
    * 프로토콜의 실행 결과에 대한 어떤 이해 관계가 없고, 어떤 참여자와도 특별한 협력 관계가 없지만 원할한 프로토콜의 수행을 위해 참여하는 참여자
    * 신뢰 : 프로토콜이 정한 규칙대로 프로토콜을 수행함
    * 부정행위를 하지 않는다는 것은 아님
    * 다른 말로 중재자
* 암호프로토콜에서는 항상 공격자의 존재를 가정함

## TTP의 종류
* 인라인 TTP : 프로토콜의 모든 과정에 참여
    * 모든 메시지는 항상 TTP를 경유함
* 온라인 TTP : 프토코로의 일부 과정에서는 항상 참여
* 오프라인 TTP : 실제 프로토콜 수행과정에서 참여하지 않지만 사전에 또는 사후에 필요에 따라 참여


## 암호프로토콜의 분류
* 자체 강화 프로토콜
    * 중재자가 필요 없는 프로토콜
* 중재 프로토콜
    * 중재자가 프로토콜에 항상 참여
* 판결 프로토콜
    * 분쟁이 발생한 경우에만 판결자가 참여
    * 프로토콜은 분쟁을 해결할 수 있도록 증거를 남겨야 함
    * 중재자는 증거를 검사하여 분쟁을 명확히 해결할 수 있어야 함

신뢰하는 제 3의 중재자를 사용할 경우 발생할 수 있는 문제
* 프로토콜 자체가 수행불가
    * 이 문제를 단일 실패점이라 한다
* 중재자의 신뢰성 문제
* 중재자를 유지하고 관리하는 추가 비용 소요
* 추가적인 통신 지연
* 모든 프로토콜 수행에 관여하여야 하므로 병목현상 발생 가능


## 암호프로토콜 설계 절차
* 설계 순서
    * 달성 목적을 포함한 프로토콜의 정의
        * 환경, 참여자, 사용 장치 등등
    * 요구사항 분석
        * 목적, 요구사항
    * 가정 분석
        * 참여자 가정 : 참여빈도, 신뢰관계
        * 환경에 대한 가정 : 네트워크, 장치, 이동성
        * 공격자에 대한 가정 : 공모 공격 포함
    * 설계
    * 증명 : 요구사항이 충족됨을 증명해야 함
    * 구현
        * 소프트웨어 구현 결과에 대한 검증이 반드시 필요함

* 참여자에 대한 가정
    * 보통 일반 참여자들은 서로를 신뢰하지 않음
    * 신뢰 서버는 보통 서버가 수행해야 하는 모든 기능에 대해 신뢰 있게 행동한다고 가정함
* 공격자에 대한 가정
    * 가정 1. 프로토콜을 통해 교화되는 모든 메시지를 확보할 수 있음
    * 가정 2. 진행을 방해 가능, 메시지 변경 삽입 차단 등등
    * 가정 3. 정상적 참여자가 아닐 수 있다
    * 가정 4. 오래된 세션키는 공격자에게 노출 가능
    * 가정 5. 공모 공격을 할 수 있음


## 키 확립 프로토콜
두 사용자가 대칭 암호 알고리즘을 사용하여 원격에서 메시지를 비밀스럽게 교환하기 위한 전제조건은? 동일 대칭키의 공유

* 키 확립 프로노콜 : 둘 이상의 참여자 간의 비밀키를 공유할 수 있도록 해주는 암호프로토콜

* 키 확립 프로토콜을 통해 얻어지는 비밀키는 단일 세션에 사용하기 위한 세션키이다
    * 한번 쓰면 사라짐



# 블록 방식의 대칭 암호알고리즘의 특성
블록 암호방식 : 정해진 크기의 입력 입력과 같은 크기의 출력
* 평문이 블록크기보다 작으면 채우기가 필요하다, 크면 암호화 모드

단일블록크기의 서로 다른 메시지 M과 M`의 암호화

    E.K(M) = C, E.K(M`) = C`

C와 C`, M도 서로 어떤 상관관계도 없음

서로를 가지고 어떤 예측도 불가능


## 키 확립 프로토콜
두 사용자가 대칭 알고리즘을 통해 원격에서 메시지를 비밀스럽게 교환하기 위해서는 동일 대칭키의 공유가 필요하다

키 확립 프로토콜 : 둘 이상의 참여자 간의 비밀키를 공유할 수 있도록 해주는 암호 프로토콜

프로토콜을 통해 얻어지는 키는 세션키

세션키를 사용하는 이유
* 같은 키로 암호화된 암호문을 제한
* 키가 노출되었을 때 누설되는 정보의 양을 제한
* 키 저장에 관한 안전성 문제를 해결
* 세션 간 또는 응용프로그램 간의 독립성 제공

## 키 확립 프로토콜의 요구사항
1. 참여자는 의도한 다른 참여자들과 사용할 수 있는 새로운 키를 얻어야함
    * 의도한 참여자
        * 키의 용도를 확인할 수 있어야 함
            * 누구와 사용하기 위한 키인지
        * 참여자의 인증이 필요할 수 있음
            * 키 생성자 인증
                * 키를 누가 생성하였는지, 누가 보냈는지 확인할 수 있어야 함
                * 키를 인증서버가 대신 생성해 줄텐데 인증서버가 발급한 키가 밎는지 확인할 수 있어야 한다
    * 키 확인
        * 다른 참여자도 나와 같은 키를 가지고 있다는 것을 확인할 수 있어야 함
        * 참여상대에 대한 인증이 필요할 수 있음
    * 키의 최근성
        * 키가 최근에 생성되었다는 것을 확인할 수 있어야 함

2. 새로운 키는 의도된 참여자 외에 다른 참여자들은 얻을 수 없어야 함
    * 키의 비밀성이라 한다
    * 사실 키의 인증을 도와주는 서버는 알 수 있다

### 키 교환 시도
중재 서버를 사용하는 키 전송 프로토콜

문제점
* 공격자는 도청하여 세션키를 얻을 수 있음
* Alice와 Bob은 K가 둘 간 공유하기 위해 생성된 키인지 알 수 없음
    * 키의 용도
* 최근성도 알 수 없음
* K를 중재 서버가 생성하였다는 것을 확인할 수 없음
    * 생성 주체에 대한 인증 기능이 없음
* 서로 같은 키를 가지고 있는지 확인 할 수 없음


### 키 교환 시도 2
서버와 사용자들이 사전에 키를 공유

해당 키로 각자 암호화하여 A에게 전송

A가 B의 키를 B로 전송

키의 비밀성만 보장된다.

키를 누가 생성했는지 유효기간은 아직 남았는지 알 수 없다

시도 2에 대한 공격
* A에서 B로 키를 보낼 때 중간에서 C가 탈취 가능
* 키와 같이 통신 상대방에 대한 정보를 보내는데 이것을 변경 가능하다

공격2
* A가 서버로 키를 요청할 경우 C가 중간에 탈취
* 서버는 A와 C가 통신하는 데 필요한 키로 착각 
* A는 AC 를 AB로 착각함

공격3
* 이미 유효기간이 지난 키를 전송

## 시도 3
키와 키의 주인을 나타내는 값을 같이 암호화

암호문에 식별자까지 포함시킨다 이것을 **naming 기법**이라 한다.

암호문내에 식별자가 들어있으니 중간에 탈취하여 사용자를 변경하는 것이 불가능하다

근데 아직 유효기간은 안넣음

그리고 BCP의 한계로 안됨

암호화를 블록 단위로 진행하는데 블록 순서를 주무를 수 있다

그래서 무결성을 보장해 줘야 한다 그래서 인증 암호화가 필요하다

## 시도 4
랜덤 수 Na를 넣는다

이제 풀어서 볼 수 없고 조작도 하면 알 수 있다

1. A가 서버로 A, B, Na 보냄
2. 서버가 A용 B용 키 반환
3. A가 B에게 사용할 키 전송
4. B는 키 확인 후 해당 키가 맞는지 A에게 확인 요청
5. A는 확인하여 반환

## 시도 5
둘 중 하나가 자기 N 다른 애한테 전송

받은 애는 자기 N까지 같이 서버에 전송하여 키를 받는다

N은 통신할 때 생성함으로 N을 갖고있다는 것은 최근에 생성한 토큰


## 암호화의 용도
* 비밀성을 보장하기 위해 사용
    * 누가 복호화할 수 있는지가 중요하다
    * Ka 면 a만 복호화
    

* 인증을 제공하기 위해 사용
    * 누가 암호화할 수 있는지가 중요
    * A만 만들 수 있으면 A가 만든 것이라고 한다
    * A와 B만 생성할 수 있는 비밀키의 경우
    * A가 자기가 생성하지 않았다면 이건 B가 생성했다고 확신할 수 있음
    * A와 Server만 만들 수 있다면 A입장에서 서버에서 만들었다는 것을 확신할 수 있음


* 메시지의 구성요소를 바인딩 하기 위해 사용
    * 실제 비밀성이 요구되는 요소는 Kab 뿐이다
    * 하지만 같이 묶여서 암호화된 것으로 연관되어 있다는 것을 알 수 있음
    * 꼭 같이 암호화되야 하는것이 아닌 해싱 등과 같이 같이 묶여있으면 바인딩된 것

* {B||Na||Kab}.Kas를 MAC을 사용해서 변경하면 다음과 같은 효과를 얻을 수 있다
    * {Kab}Kas, MAC.K`as{B||Na||Kab}
    * 비밀성이 요구되는 정보만 암호화하였고
    * 바인딩은 MAC을 통해 제공하고 있고
    * Kab의 무결성을 확인할 수 있다
    * MAC을 사용함으로써 무결성을 얻을 수 있고, Kab를 검증할 수 있다

## 인증 암호화


## 대칭 암호알고리즘의 사용
* 대칭키로 암호화의 의미
    * 인증
        * Kab의 경우 B가 생성하지 않았다면 A가 생성한 것
    * 비밀성
        * Bob과 Alice만 암호문을 복호화하여 M을 얻을 수 있다

* 대칭키 사용의 가장 큰 이슈
    * 대칭키를 어떻게 안전하게 공유할 것인가?
* 대칭/비대칭 암호알고리즘은 기본적으로 무결성을 제공하지 않음
    * 무결성까지 필요하면 인증 암호화

## 비대칭 암호알고리즘의 사용
* 공개키 암호알고리즘에서 개인키로 암호화
    * A가 개인키로 M을 암호화하여 전달
    * 인증
        * A의 공개키로 메시지를 복호화하는데 상공했다면 B는 해당 메시지를 A가 생성했다고 확신할 수 있다

* 공개키 암호알고리즘에서 공개키로 암호화
    * A가 B의 공개키 +Kb로 메시지 M을 암호화하여 전달
    * 비밀성
        * 오직 B만 암호문을 복호화하여 M을 얻을 수 있음
    * 인증
        * B는 누가 이 메시지를 생성하였는지 확인할 수 없음

* 두 경우 모두 대응되는 공개키가 확실히 A또는 B 것임을 확신할 수 있어야 함

## 암호프로토콜의 안정성
* 암호프로토콜은 그것의 보안 요구사항을 모두 충족하였을 때 안전한 프로토콜이라 한다
    * 암호프로토콜은 물론 안전성도 중요하지만, 효율성도 중요함
* 암호프로토콜의 안전성을 증명하기 위해 다양한 방법을 사용하고 있지만 쉽지 않다
    * 보통 지금까지 알려진 공격에 대해서만 안전함
    * 여러 가정 하에서만 증명이 가능한 경우가 많으며, 특정 요구사항 충족에 대해서만 증명이 가능한 경우도 있다
* 암호프로토콜만 안전하다고 하여 전체 시스템이 안전한 것은 아님
    * 서버, 클라이언트 해킹, 서비스 거부 공격 등 프로토콜의 설계를 통해서 방지할 수 없는 위협이 존재함

## 안전성 증명
* 암호프로토콜에 대한 증명은 보통 프로토콜의 보안 요구사항을 고려하여 보안 모델을 세우고, 이 모델에서 증명함
* 보안 모델이란 프로토콜의 안정성을 논하기 위해 세우는 가정들의 집합
    * 가정 중에 가장 중요한 것은 공격자의 능력ㅋㅋ
    * 능력에 따라 공격의 성공 가능성이 다름
    * 공모 공격에 대한 검토가 있어야 함

* 공격자의 능력
    1. 모든 참여자 간의 통신을 제어
    2. 지난 프로토콜 수행을 통해 확립된 세션키를 얻을 수 있음
    3. 공격자가 참여자의 장기간 키를 알고 있음

* 공격자의 종류
    * 제3의 공격자와 내부공격자로 나눌 수 있고, 내부공격자에 대해서는 다음과 같은 가정을 할 수 있음
        * 가정1. 악의적인 내부자의 존재 : 프로토콜의 적법한 참여자가 악의적인 행동을 할 수 있음
        * 가정2. 정직한 내부자 : 적법한 참여자는 항상 정직하게 행동함
    * 보통은 가정 1 

## 프로토콜의 효율성
* 두 측면에서 효율성을 고려
    * 계산 효율성 : 프로토콜의 참여자가 프로토콜을 완료하기 위해 계산해야 하는 양에 의해 측정됨
    * 통신 효율성 : 메시지의 수와 각 메시지의 크기에 의해 측정됨
* 계산 효율성
    * 사용하는 암호기술에 의해 결정됨
    * 공개키를 사용하는 프로토콜은 공개키 연산을 최소화하는 것이 필요함

* 통신 효율성
    * 필요한 라운드의 수를 줄이는 것이 가장 효과적
    * 프로토콜의 한 라운드는 한 시점에서 병렬로 전달할 수 있는 모든 메시지를 포함함
    * 메시지가 서로 독립적이지 않으면 서로 다른 라운드에 포함됨
        * 메시지가 이전 메시지의 구성요소를 포함하면 이 두 메시지는 서로 의존하는 메시지

    

# 암호프로토콜 기초 설계 기술
## 블록방식의 대칭 암호알고리즘의 특성
1. 메시지와 암호화된 데이터 사이에는 어떤 상관관계도 없다
2. 암호화한 데이터를 다른 키로 복호화한 결과 예측 불가
3. 암호화된 데이터가 조작되면 복호화한 결과 예측 불가
4. 메시지가 수신자가 알고 있는 내용이 아니면 복호화해도 이게 제대로 된건지 알 수 없다
    * 수신자가 복호화해서 메시지를 얻었을 때,
    * 메시지에서 알아볼 수 있는 무언가가 있어야 함
5. 메시지의 일부가 확인할 수 있는 값이고, 복호화 후 그것이 확인되면 C가 K를 이용하여 생성한 암호문인지 확인 가능
    * 즉 복호하하여 얻은 메시지에 대해 무결성 확인 가능
    * 이처럼 암호문을 생성할 때 사용한 암호키를 확인할 수 있게 해주는 평문의 요소를 여분 정보라 한다
    * 인증 암호화 생기고 나서는 사용하지 않는다?


다중 블록의 경우
* M1과 M2가 있다면 M1,M2 모두에 여분 정보가 있어야 K로 암호화된 블록임을 확신할 수 있다
* 둘 다 여분정보가 있어도 서로 연결할 수 있는 부분이 없다면 M1과 M2가 M을 쪼개서 암호화하여 만든 암호 블록임을 확신할 수 없다
    * 공격자는 전송되는 메시지를 다양하게 조작 가능
    * 여분 정보의 유무에 따라 할 수 있는 조작이 달라짐


인증 암호화 방법을 사용한 경우
* MAC(encrypt then mac) : 메시지를 암호화한 후 mac값을 계산  
* MAC값이 확인된 경우에만 복호화 시도
    * MAC 값이 확인되면 C의 무결성을 확신할 수 있음
* MAC값이 확인되고 상대방을 신뢰하면 C가 특정키를 이용하여 생성한 암호문인지 여부를 확신할 수 있다
    * C가 단일 블록이 아니라도 성립한다
    * 상대가 애당초 이상한 것 보내면 그거는 알 수 없다

* 인증 암호화를 하지 않으면 블록 크기, 평문의 각 요소의 크기, 평문의 구성 등이 바인딩에 영향을 준다
    * 실제 바인딩되었다고 확신하기 어려울 수 있다
* 인증 암호화를 하면 전송 과정의 조작은 발견할 수 있다
    * 송신자가 애초에 메시지를 엉뚱하게 구성하면 문제
        * 이때문에 신뢰할 수 있어야 함
    * 상대방을 신뢰할 수 있다면 여분 정보 없이 수신한 암호문이 어떤 키로 암호화되었는지 확신할 수 있다
    * 상대방을 신뢰할 수 있다면 바인딩에 대해서도 확신할 수 있다
* 인증 암호화가 모든 문제를 해결하는 것은 아님

## 여분 정보
* 평문에 여분 정보가 없다면 올바른 키를 이용하여 복호하하였는지 판단할 수 없음
    * 여분 정보란 복호화의 정확성을 확인할 수 있도록 해주는 요소

* 여분 정보의 분류
    * 명백한 여분 정보 : 누구나 확인할 수 있는 정보
        * 식별자
        * 수동적인 암호해독 공격을 용이하게 해줌
        * 특히 패스워드와 같이 사전 공격이 가능하거나, 비교적 작은 공간에서 선택된 암호키를 이용하여 암호화한 암호문 내에는 명백한 여분 정보를 포함하지 않는 것이 바람직함
            * 추측 가능함
    * 함축적 여분 정보 : 오직 수신자와 송신자만이 알고 있는 정보


## 명명 기법
메시지의 의미를 명확하게 하기 위해 참여자의 식별자를 암호문 내에 포함하는 방법

식별자는 항상 명백한 여분 정보

근데 인증 암호화 쓰면 전부 해결된다

키를 받았으면 사용할 상대, 생성시간 등이 있어야 함

* 명명기법의 적용 : 대칭 암호알고리즘을 사용하는 경우
    * {A||B||Kab}.Kas 
    * A는 생략가능 Kas 로부터 유추 가능하다
        * 최근성을 제공하지는 못한다
    * 실제 인증 암호화를 하지 않으면 B와 Kab의 바인딩을 확신할 수는 없다

* 비대칭 암호알고리즘을 사용하는 경우
    * 서버가 생성하였다는 것이 전달되야하고, 비밀성이 보장되야 한다
    * 밖에 +는 비밀성, 안에 -는 서버가 만들었다는 것을 알려줌
    * {A||B||Kab}.-Ks}.+Ka
    * 대칭 암호알고리즘과 달리 A를 생략할 수 없다
    * 생략하면 다음과 같은 공격이 가능하다
        * 위에서 직접적으로 암호화하는 것은 Ks이다
        * 직접적으로 암호화하는 경우에만 생략 가능하다


## 메시지의 최근성/시기적절성
암호프로토콜에서 암호문을 수신하면 정해진 다음 행동을 취하기 위해 여러 검사를 하게 된다

이때 보통 **최근성**검사를 진행하게 된다.

메시지의 최근성을 검사한다는 것은 메시지가 이전 또는 다른 세션에 사용된 메시지가 아니라 현재 프로토콜 수행을 위해 새롭게 만든 메시지임을 확인하는 것

최근성은 메시지의 구성요소로부터 유추해야 하며, 어떤 매커니즘을 사용하건 재전송 메시지와 그렇지 않은 메시지 간의 구별이 가능해야 한다

식별자로 사용되는 요소는 시간과 인과성이 있다.

* 타임스탬프 기반 기법 
    * 시간적 관계를 통해 메시지의 최근성을 보장하는 기법
    * 타임스탬프를 메시지에 포함시킨다
* 난스 기반 기법
    * challenge(request)와 response를 통해 수행한다
    * request에 난스를 만들어 보내면 상대방이 난스를 포함하여 response한다
    * 난스를 생성한 사람이 자신이 만든 난스가 포함되어있는지 확인하여 최근성 확인한다?? 
    * 응답이 시도 이후에 만들어질 수 밖에 없도록 하여 응답의 최근성 확인

* 제공자 : 식별자를 제공하는 참여자
* 입증자 : 제공된 식별자를 메시지에 포함하는 참여자
* 검증자 : 메시지에 포함된 식별자를 통해 메시지의 최근성을 확인하는 참여자

* 타임스탬프 기법 : 제공자와 입장자가 같은 참여자
* 난스 기법 : 제공자와 검증자가 같은 참여자

* 최근성 식별자로 적합하기 위해서 반드시 예측할 수 없어야 하는 것은 아님
* 어떻게 식별자를 사용하느냐에 따라 불예측성이 필요할 수 있고, 필요하지 않을 수 있음


## 타임스탬프
수신자가 자신의 지역 시간의 현재값을 비교하여 차이가 허용 범위라면 메시지가 최근에 생성된 메시지로 인식

취약점
* 허용 윈도우 내에 재전송하는 공격
    * 메시지 중복 검사가 반드시 필요하다
    * 그래서 최근 t내에 수신한 모든 메시지를 보관함
* 제공자는 쉽게 특정 순간을 가리키는 타임스탬프를 사용할 수 있음
    * 모든 참여자가 메시지에 타임스탬프를 첨부하고 확인하기 위해서는 타임스탬프의 형태를 알아야 한다
        * 그래서 타임스탬프 형태는 공개되어 있을 수 밖에 없다
    * 타임스탬프의 값은 미래 또는 과거의 어느 한 순간을 나타낸다
    * 검증자는 제공자가 정직하게 타임스탬프를 제공한다고 **신뢰**해야 한다

* 타임스탬프를 유효한 값으로 허용하는 범위를 허용 윈도우라 한다.



**선행 메시지**
* 수신자의 시간이 송신자의 시간보다 상대적으로 앞선다
* 이 경우 송신자가 올바른 타임스탬프를 보내더라도 거부하게 된다
* 이것을 선행 메시지라 한다
    * 과거 시간이 포함된 메시지
    * 미래 시간은 사후 메시지
* 그래서 시간은 항상 절대 시간과 동기화되어야 한다

장점
* 제공자와 입증자가 동일인이며, 일방향 통신으로 최근성을 보장할 수 있음
    * 메시지 하나만 있어도 됨

단점
* 입증자를 신뢰할 수 있어야 함
* 타임스탬프의 사용은 시스템 간의 시간 동기화가 요구됨
    * 시간 동기화 메커니즘이 시스템 보안상에 미치는 영향이 크다
    * 그래서 시간 동기화 메커니즘을 구현해야 한다
* 사후 메시지 문제를 해결할 수 없다
* 하여튼 이래서 안씀


## 난스
난스란 특정한 순간을 증명하기 위해 생성된 값

제공자와 입증자가 다른사람

제공자는 한번도 사용하지 않은 난스를 제공하고, 그 난스가 회신되야지만 최근성 보장

이전에 사용한 난스를 다시 사용해서는 안된다.  
그래서 **키를 자주 바꿔줄 필요**가 있다. 키가 바뀌면 똑같은 난스를 사용해도 괜찮음

난스 값으로 사용하는 것
* 타임스탬프, 카운터, pesudo-random number

장점
* 검증자는 입증자의 정직성과 능력에 대해 신뢰할 필요가 없다

사용 방식
* 난스는 항상 명백한 여분 정보
* 인증 측면에서 방식2의 경우에는 Na를 예측할 수 없어야 함
    * 예측이 가능하면 누구나 응답할 수 있음
    * 최근성 보장이 목적이 아닐 수 있음
* 방식2 외에는 예측해도 되지만 이전에 사용한 키면 안된다
    * 그래서 키를 자주 바꿔줘야 함
    * 해당 키에서 이전에 사용하면 안되는 거임

## Timestamp vs Nonce

## 최근성을 보장하는 기타 다른 방법
* 카운터
    * 쌍방간의 동기화된 카운터의 존재를 가정하며, 실제 사용은 타임스탬프와 차이가 없다
    * 장점
        * 실제 시간과 독립적 동기화
    * 단점 
        * 모든 사용자간에 동기화된 별도의 카운터가 필요, 사용자 간에는 힘들지만 서버와 사용자 간에는 활용 가능
    * 무한 카운터를 사용할 수는 없음
    * 카운터도 중요한 보호 자산
* 최근성이 보장된 암호키 사용
    * 최근에 생성된 키를 사용하여 생성된 메시지는 기본적으로 최근에 생성된 메시지




# 키 확립 프로토콜
n명의 사용자가 서로 메시지를 비밀스럽게 교환하고 싶다면, 사용자 쌍마다 메시지를 암/복호화 할 수 있는 서로 다른 대칭키가 필요하다

그래서 대칭키 방식만을 사용하는 방법과, 공개키를 활용하는 방법이 있다.

참고로 분류 2는 대칭키랑 공개키 같이 쓰는 것


## 비밀키만 사용하는 방식
3가지 방법을 살펴본다

1. n(n - 1)/2 개의 비밀키를 생성한 후 사용자에게 n-1개의 키를 오프라인으로 주는 것
    * 확정성도 없고 키 갱신 수단도 없다

2. 신뢰 기관을 사용하는 방법
    * 각 사용자는 신뢰기관과 비밀키를 공유
    * 사용자 간의 비밀키는 필요시 신뢰 기관을 통해 확립
    * 신뢰 기관과 최초 장기간 키를 확립하는 문제
    * 필요시 장기간 키를 갱신하는 문제

3. 보안 변수 t를 결정하고 각 사용자는 t에 비례한 정보를 유지
    * t로부터 n - 1명의 다른 사용자와 사용할 수 있는 독특한 비밀키 생성 가능
    * 이 비밀키로 세션키를 확립하여 사용
    * Blom의 키 분배 기법을 이용하여 키를 계산한다
    * 클 수록 안전함
    * 확장성은 미리 만들어놓는 방식으로 사용
    * 200명 정도 있을 것 같으면 200개 정도 만들고 사용자 추가하면 미리 만들어놓은거 제공


## 공개키를 사용하는 방식
2자간 공개키를 사용하여 세션키를 확립하고 싶으면 한 사용자가 세션키를 생성하여 다른 사용자의 공개키로 암호화하여 전달하면 된다.

이때 그냥 키만 보내는 것이 아니라, 메시지를 해당 키로 암호화한 다음 같이 보낼 수 있다.


``Msg 1. A → B : C = {M}.K1, MAC.K2(C), {TA||K}.+KB``

이때 K1과 K2는 K로부터 계산한 서로 독립적인 값이다.

물론 A가 서명하지 않았기 때문에 B의 입장에서 이걸 A가 보냈다고 확신할 수 없다.

하지만 비교적 비용이 크다. 

그래서 메시지는 대칭키 방식으로 주고받고 신뢰 기관과 장기간 키를 확립하는 것은 공개키 방식으로 하면 해결된다.



## 키 확립 프로토콜
키 확립 프로토콜이란 둘 이상의 참여자들이 비밀키를 고융할 수 있도록 해주는 암호프로토콜

확립 프로토콜을 통해 얻어지는 비밀키는 보통 단일 세션에 사용하는 세션키

키 확립 프로토콜은
* 키 전송 또는 동의 과정
* 키 확인 과정
    * 상대방이 자신과 같은 키를 가지고 있는지 확인하는 과정  
으로 구성되어 있다.

키 확립 프로콜은 3가지로 분류된다

### 키 생성 주체에 따른 분류
* 키 전송 프로토콜 : 한 참여자가 홀로 키를 생성하여 다른 참여자에게 주는 방식
    * 보통 서버가 생성해서 준다
    * 대칭키만을 사용할 경우 보통 TTP를 사용하는 중재 방식의 프로토콜
    * 이때 TTP는 크게 키 중계 센터와 키 분배 센터로 구분한다

* 키 동의 프로토콜 : 특정 사용자가 아닌 다 같이 키를 생성하는 방식
    * 키를 확립하는 모든 참여자들이 동등하게 키 생성에 기여
    * 보통 랜덤값을 서로 교환한 후 이를 이용하여 각자 생성에 기여
    * 자체 강화 방식 : 별도 서버를 사용하지 않고 서로 정보들을 교환해서, 교환된 정보들로 세션키를 계산
    * 그래서 우리가 사용하는 프로토콜들은 보안을 위해 공개키 기술을 사용한다

### 키를 확립하는 사용자 수에 따른 분류
2자간, 3자간, 다자 간으로 나뉜다.

가장 많이 사용되는 것은 2자간


## 키 확립 프토토콜의 요구사항
* 키의 비밀성 : 참여자 외에는 비밀키를 얻을 수 없어야 함, 신뢰기관 제외
* 키의 최근성 : 이전에 사용한 적 없어야 함
* 키의 용도 : 참여자는 수신한 키가 본인이 생각하고 있는 상대방과 사용하기 위한 키인지 확인할 수 있어야 함
* 생성 주체 확인, 참여자 확인 : 키 전송 프로토콜의 경우 키를 수신한 참여자는 이 키를 프로토콜에서 정의한 주체가 생성한 것인지 확인할 수 있어야 함
* 키 확인 : 키를 확립하는 참여자는 상대방이 같은 키를 가졌는지 확인할 수 있어야 함

* 무결성
    * 무결성의 경우 다른 것보다 중요하지는 않다
    * 확인이 더 중요함
    * 보통 확인은 라운드의 증가가 필요함

    
## 이산대수 문제
군은 이항연산에 의해 닫혀있는 대수구조를 말함

닫혀있다는 것은 집합에 있는 두 원소를 빼서 특정한 연산을 적용시키면 그 결과가 다시 집합에 들어가는 것

그러니까 집합안에 있는 거 두개 랜덤으로 골라서 특정 연산 적용하면 결과값이 집합에 있다..

* 항등원 : 어떤한 원소랑 항등원이랑 연산 적용시키면 자기 자신이 나옴

* 역원 : a와 b를 연산 적용시키면 항등원이 나온다, 그러면 a와 b는 서로의 역원

역원을 곱하여 나눗셈 효과를 얻을 수 있다
``4 * x = 5`` 에서 x를 구하고 싶다면 양 변에 4의 역원을 곱하면 된다.  
-> ``x = 5 * 2``

* 생성자 : 거듭제곱하면 군에 있는 모든 원소가 나오는 원소
* 순환군 : 생성자가 있는 군

``5^2 = 4`` 에서 2는 기저 5에서 4에 대한 이산대수. ``log5(4) = 2``

2는 생성자 5에서 4를 구하기 위한 제곱의 횟수

* 이산대수 문제 : 순환군의 정보, 생성자 g, 임의의 군 원소 y가 주어졌을 때 기저 g에 대한 y의 이산대수를 찾는 문제

순환군의 크기가 크면 이산대수 문제를 해결하기 어렵다.


## 키 동의 프로토콜
### Diffie-Hellman 키 동의 프로토콜
* g : 유한순환군의 생성자

이 군에서 이산대수 문제와 Diffie-Hellman계산 및 결정 문제는 계산적으로 어렵다

1 ~ t-1에서 각자 하나씩 고른다. A는 a를 골랐고, B는 b를 골랐다.

* DH 계산 문제 : 군 정보, g^a, g^b 가 주어졌을 때 g^ab를 계산하는 문제
* DH 결정 문제 : 군 정보, g^a, g^b, g^c가 주어졌을 때 g^c, g^ab가 같은지 결정하는 문제

Alice와 Bob만 g^ab를 계산할 수 있다

g^ab를 직접 세션키로 사용하지 않고, 키 유도 함수에 g^ab를 입력하여 세션키를 계산함

* 문제점 : 서로 g^a와 g^b가 상대방이 보낸 값인지 알 수 없다
* 공개키 기술을 사용하고 자체 강화 방식


### 키 동의 프로토콜(2)
* 키 동의 프로토콜은 특정 참여자가 홀로 키를 결정하지 않는다.
    * 보통 모든 참여자가 동등하게 참여한다
    * 각 참여자들이 랜덤 값을 교환하고, 이 값들을 통해 키를 결정
* 각 참여자 입장에서 자기가 선택한 요소가 랜덤하고 최근이면 세션키도 랜덤이고 최근인 것이다

## 키 제어 요구사항
참여자 중 어느 누구도 공유되는 세션키가 사전에 미리 계산되거나 선택되어진 값이 되도록 만드는 것은 계산적으로 어려워야 함














# 암호 알고리즘


## 암호화 모드
대칭 암호알고리즘은 크게 블록과 스트림 암호방식으로 분류한다

* 블록 암호방식 : 메시지를 일정한 크기로 나누어 각 블록을 암호화
    * 크면 암호화 모드, 작으면 채우기가 필요하다

* ECB 모드 
    * 암호화 모드 중 하나
    * 블록 단위로 메시지를 나누어 각 블록을 독립적으로 암호화
    * 평문 패턴이 암호문에 그대로 나타날 수 있다
        * 평문이 우연히 같으면 암호화된 블럭도 같다
        * 그래서 평문이 같아도 암호화된 블럭은 다르게 할 필요가 있다
        * 이것을 *피드백*이라 한다

* 피드백 : 한 블록을 독립적으로 암호화하지 않고, 추가적인 요소를 사용하여 암호화하여 평문 블록이 같더라도 결과가 달라지도록 해주는 요소


암호화 모드의 분석
* 평문오류 : 암호화하기 전에 평문에 오류가 있을 때 암호문에 미치는 파급효과
* 암호화 조작 : 암호화한 후에 암호문을 조작하였을 때 평문 블록과 전체 평문에 미치는 영향(복호화 시 영향)
    * 복호화 시 조작된 일부만 깨지고 나머지는 멀쩡하면 좋겠다
    * 공격자가 의미있는 변화를 줄 수 있어서는 안된다
        * 이것을 NM특성이라고 한다
* 추가 보안 문제 : 암호화 모드 사용에 따른 추가적인 보안 문제의 유무
* 효율성 : 모드 연산의 비용, 병행성, 다중 프로세서의 활용 가능 여부 등을 분석

## 채우기
평문 메시지의 크기가 정확하게 블록 크기의 배수가 아닌 경우에 필요

채우기(padding) : 완전하지 않은 마지막 블록 끝에 규칙적인 일련의 비트를 추가하여 완전한 블록을 만드는 것

복호화한 사용자는 채워진 부분을 정확하게 제거할 수 있어야 함

방법 2가지
1. 암호문과 별도로 원 평문의 크기를 전달
2. 채우기를 한 부분에 채운 부분을 제거할 수 있는 요소를 포함

일반 채우기
* 채워야하는 부분 끝에 채우는 바이트 수를 적는다
* 3바이트면 3 적고 앞에 2바이트 채움
* 만약 블록크기의 배수로 딱 맞다면 오직 채우기만 있는 블럭 하나 추가해야 한다
* 아니면 멀쩡한 데이터를 채우기로 오해할 수 있음
* 그래서 최대 1블럭이 기존 데이터에 비해서 늘어난다 


* PKCS #7 : 채우기를 해야 하는 모든 부분을 채워야 하는 바이트 수의 값으로 채움

이 방법이나 일반적인 방법이나 모든 메시지에 대해 향상 채우기를 해야 한다.

평문이 블록 크기의 배수가 되어도 무조건 채우기 들어가야 한다

* 문제점 : 그래서 암호문이 평문보다 항상 큼
    * 채운 데이터는 여분 정보 역할을 할 수 있기는 하다


## 암호문 훔침 기법
채우기를 해도 평문의 크기와 암호문의 크기를 일치하도록 하는 방법

바로 전 암호문 블록을 이용하여 채우기를 하는 방식

n개의 블럭이 있으면 n-1번째의 블록이로 채운데

불필요한 데이터가 아니라 필요한 데이터로 채운다.


## ECB 모드
피드백을 사용하지 않는 모드

피드백 : 같은 평문이 똑같이 암호화되지 않는 것

평문 오류 : 한 평문 블록의 오류는 해당 암호문 블록에만 영향을 줌

유사한 평문을 암호화 하면 비슷하게 암호화 됨

그래서 암호문이 비슷하면 평문도 비슷함을 알 수 있다

암호화된 메시지의 블록들의 위치를 바꾸면 복호화된 평문 메시지의 블록 위치들도 동일하게 바뀌게 된다.(NM특성 불만족)

병렬처리 가능

## CBC(Cipher Block Chaining) 모드
Pi를 암호화할 때 이전 블록을 xor 해서 암호화

i를 암호화하려먼 i - 1이 필요한 순차적 암호화 모드이다.

그래서 멀티스레드 환경에서 못돌림

첫 블록은 이전 블록이 없다 그래서 사용하는 것이 초기 벡터(IV)

* C0 : 초기 벡터(IV, Initalization Vector)

보통 랜덤 블록을 사용한다. 비밀성을 유지할 필요는 없다

IV로 한블럭 채우기로 한 블록, 이렇게 최대 2블록이 늘어날 수 있다.

CBC 모드와는 다르게 첫 암호화 블록(IV)이 랜덤 블록이기 때문에 같은 메시지를 다시 암호화하여도 결과가 다르다

만약 하나의 블록이 변한다면, 뒤의 다른 블록들에게도 영향을 미쳐 전부 변하게 된다.

복호화할 때는 마지막 블록이 변경되면 다른 모든 블록에 영향을 미친다.

그래서 마지막 블록을 MAC으로 사용할 수 있다.

* 암호화 조작
    * 하나의 블록의 비트가 변경되면 해당 블록이 아예 깨진다
    * 해당 블록과 그 다음 블록은 영향을 받지만
    * 다른 블록은 영향을 받지 않는다
    * 이런 특성을 자체 회복 기능을 지니고 있다고 한다

* 자체 회복 : 하나의 암호문 블록에 오류가 발생하면 나머지 모든 블록의 복호화에 영향을 주지 않음

복호화다 복호화

여기서는 Ci 에 문제가 생기면 i랑 i+1만 영향을 받는다.

XOR를 사용하기 때문에 두 개의 암호문을 조합하여 새 암호문을 만들 수 있다

암호문 블록을 변경하여 예측할 수 있는 변경을 도입할 수 있음

i의 특정 비트를 조작하면 i+1의 해당 비트도 변경되게 된다(NM특성 불만족)

우연히 Ci랑 Cj가 같을 수 있다...

이 경우 두개 xor 하면 Pi랑 Pj랑 xor 한 값을 얻을 수 있다

이것을 통해서 평문을 유추할 수 있음


## CTR(Counter) 모드
CBC보다 많이 사용하는 암호모드

CBC보다 속도가 빨라졌다. 병행 처리가 가능함

이전 블록이 아닌 카운터를 xor 해서 계산

N0만 알면 Ni는 바로 알 수 있다.

평문이 아닌 카운터를 암호화하여 평문이랑 XOR 하는 것으로 암호화 블록 생성

굳이 암호알고리즘을 사용하지 않아도 괜찮다?? MAC만 하면 된다??

복호화가 필요없고, 암호화 함수만 있으면 된다

복호화시 카운터에 암호화한 다음 다시 암호블록에 xor해주면 끝

IV를 사용하게 되는데 만약 초기값이 겹치게 된다면 심각한 문제가 생긴다

같은 IV면 Si 가 같아진다. 카운터라서...

Si가 같다면 같은 Si의 암호화 블록 두개를 XOR 하면 **평문을 XOR 한 것**을 얻을 수 있다!! 

IV가 같지 않더라도 카운터이니 중첩될 수 있다.

그래서 128비트의 경우 앞에 **96비트는 랜덤으로 정하고 뒤에 32비트만 카운터**로 사용한다.

그러면 앞에 96비트는 다르니까 중첩될일이 없다

생일 파라독스대로 루트 씌워 2^48 의 확률로 충돌이 일어날 수 있다.

채우기가 필요 없다. 조금 남으면 원래 크기만큼의 스트림 방식으로 암호화하면 된다.

하여튼 암호문의 크기는 증가함 IV 때문에

무조건 한 블럭이 증가함

얘도 한 비트를 바꾸면 그대로 그 비트만 영향이 감, NM특성은 만족안됨

NM특성이 만족되지 않는다. 그래서 무결성이 중요하고 인증 암호화를 해야 한다.

특정 블럭에 원하는 변화를 줄 수 있다. 그리고 한 블럭의 오류가 다른 블럭에 영향을 미치지 않는다.

3개다 NM특성은 만족안함

NM특성을 만족하지 못한다는 것은 무결성을 제공하기 어렵다는 측면이 있다

그래서 메시지를 암호화 뿐만이 아니라 인증 암호화 해줘야 한다.


## 인증 암호화 모드
* encrypt then mac : 암호화한 다음 암호화문에 대한 mac

mac then 쓸 때는 CCM 사용함

CBC에서 마지막 블록 MAC으로 사용한 다음 CTR모드로 암호화??


encrypt then mac 에서는 EAX

그 외에도 
* AEAD : 암호화와 별도 평문을 함께 전달하고, 암호문과 별도 평문의 무결성을 제공함
* GCM 모드


보통 CTR 사용하고 병렬로 실행 가능하기 때문에 더 빠르고, 복호화 없이 암호화 만 있으면 되기 때문에 하드웨어로 만들면 더 작게 만들 수 있다.


## CBC모드 Padding Oracle 공격



## DES(Data Encryption Standard)
블록 크기가 64비트, 키의 길이는 56비트




# 암호 알고리즘2
## 블록 암호화를 이용한 충돌회피 함수

## Secure Hash Algorithm
SHA-1 
* 2^69의 확률로 충돌을 찾을 수 있다
* 해시값의 길이가 2^80 이므로 안정성은 2^80
* 이 때문에 SHA-2가 주로 사용된다
    * 해시값의 길이가 224, 256, 386, 512
* 2015년에 KECCAK이라는 알고리즘을 사용한 SHA-3이 채택됨

## SHA-1
160비트, 2^80의 안정성, 사실 이것보다는 작다

Merkle-Damgard 구조

## SHA-3
스펀지 구조, 몰라도 된ㄷ


## MAC을 구성하는 방법
* 전용 알고리즘 사용
* 일반 대칭 암호알고리즘을 사용
    * CBC-MAC, NMAC, CMAC, PMAC
* 일반 해시함수를 사용
    * HMAC
* 전자서명을 사용하는 것과 MAC을 사용하는 것 차이 중요

### CBC-MAC, CMAC
* 이전 블록의 변경이 MAC값에 영항을 주기 때문에 중요



# 해시함수의 활용
* 해시함수 : 임의의 길이에 이진 문자열을 고정된 짧은 길이의 이진 문자열로 매핑해 주는 함수
* 압축, 계산용이, 일방향성, 약한충돌회피, 강한충돌회피 등의 특성이 있다

활용
* 전자서명
    * 전자서명의 비용을 줄인다
    * 메시지 대신에 메시지 해시값에 전자서명
    * 충돌회피 해시함수이어야 함
* 무결성 서비스 
    * 해시함수보다는 MAC을 사용하는 것이 안전
* 비트 약속
    * 값을 전달할 때 먼저 해시값 전달, 나중에 필요한 시점에 공개함
    * 값은닉 : 일방향성 특성 때문에 해시값을 받은 참여자는 어떤 값을 받았는지 알 수 없음
    * 바인딩 : 충돌회피 특성 때문에 최초 해시값을 계산할 때 사용한 입력이 아닌 다른 값을 나중에 공개할 수 없음

## 패스워드 인증
다양하게 사용되지만 

패스워드는 쉽게 예측이 가능하다는 문제가 있다.

### 패스워드 해싱
* 유닉스, 웹 서비스 등에서 패스워드 관리
    * 패스워드를 그대로 저장 : 패스워드가 저장된 파일에 대한 비밀성 유지가 필수
    * 그래서 패스워드의 해시값 보관
    * 사전공격(dictionary) : 흔하게 사용하는 패스워드에 대한 해시값을 구한 후 저장되어 있는 해시값과 비교
    * salt의 사용 : 해시값을 구할 때 임의의 랜던값인 salt를 포함하여 계산
    * 보통 해시값과 salt를 같이 보관
    * 같은 패스워드라도 salt값에 따라 해시값이 달라짐
    * 사전공격이 어려워진다, 단어 m개 salt n개면 해시를 mn번 해봐야 함
        * 각 salt에 따라 m개 일일히 다 해봐야 하니까

### BCrypt
해시함수는 빠른 연산이기 때문에 수행 속도를 느리게 한 것

* 패스워드를 해싱할 때 Salt를 사용하는 것은 물론 기존 다른 암호알고리즘과 달리 알고리즘 수행 속도를 느리게 만들 수 있음
    * 수행 속도를 느리게 한다는 것은?
    * 해시 여러번 함

### 패스워드의 안정성 강화 방법
Abadi
* 클라이언트에서 서버로 패스워드 전송 시 랜덤 비트(a) 추가하여 해싱 후 전송
* 서버는 패스워드 자체를 유지해야 함
* 서버는 패스워드를 받아 모든 가능한 경우를 확인하여 패스워드 확인
* 외부 공격자는 a와 패스워드 모두 몰라 추측 공격하기 어렵다
* 서버 부담은 크다

SSO나 브라우저가 패스워드 기억 등등

## Weakest Link Principle
가장 취약 요소 원리
* 시스템 전체의 안정성은 가장 취약한 부분의 안정성과 같다
* 가장 취약한 부분은 보통 사람이다(social engineering)

## 장기간 키의 보호
* 장기간 키는 비휘발성 메모리에 유지되야 하며, 불법적인 접근이 있더라도 노출되지 않도록 보호되야 함
* 보통 패스워드로부터 대칭키를 생성하고 이 키로 장기간 키를 암호화하여 유지함
    * 공동인증서에서 개인키의 보호 등
* 저장된 파일이 노출되면 키 자체가 노출될 가능성이 높음
* 이 문제를 해결하기 위해 **화이트박스 암호기술**을 사용할 수 있음
    * 변하지 않는 암호키를 별도 파일에 저장하는 것이 아니라 
    * 암호화 알고리즘 소프트웨어 코드 자체에 포함한 후 해당 코드를 난독화하여 코드로부터 키를 추출할 수 없도록 만드는 기술

## 키 관리와 하드웨어 
* 장기간 키의 탈취 방지를 위해 키를 특수 하드웨어에 유지할 수 있음
    * USIM 등
* 하드웨어를 이용한 키 관리
    * 기본적으로 2-factor 인증 : 기기+(PIN 또는 password)
    * 종류에 따라 기기 내에서 암호 연산 수행




## 패스워드 기반 프로토콜
* 패스워드 기반 키를 이용하여 랜덤 값을 암호화한다고 무조건적으로 패스워드 추측 공격에 강건한 것은 아니다
    * 암호화된 랜덤 값을 향후 어떻게 사용하는지에 따라 강건하지 않을 수 있다
    * 암호화된 랜덤 값이 패스워드 추측 공격에 사용 가능한 특성을 가지고 있으면 강건하지 않다

1. `NB, {K}.Kp`
2. `{NB}.K`

패스워드를 추측해서 키를 만듬, 1번을 복호화해서 K를 얻음, 여기까지는 제대로 복호화했는지 알 수 없다. 2번을 K로 복호화해서 NB가 나오면 제대로 추측한 것

### Original EKE, 1992
난스가 아니라 랜덤 값을 사용해 추측이 맞는지 확인할 수 없도록 한 것

### 패스워드 기반 프로토콜(2)
* 정확하게 추측했는지 알 수 없도록 하는 것도 중요하지만
* 추측이 틀렸다는 것을 알 수 없도록 하는 것도 중요
* 패스워드 기반 키는 로컬에서만 사용해야 한다
* 로컬에서 사용하는 것이 아닌 네트워크를 탄다면, 랜덤값만 암호화하고, 암호화한 랜덤값을 올바르게 사용하고, 암호화한 값을 패스워드 추측 공격에 취약하지 않도록 특징들을 가지고 있으면 안됨

## 일회용 패스워드
OTP
* 매번 새로운 패스워드를 사용
    * 매번 패스워드를 변경하면 노출되도 안정성에 문제가 없음
* 클라이언트와 서버는 매번 새롭지만 같은 패스워드를 생성하기 위해 둘 간의 대칭키를 공유하고 있어야 함
    * 대칭키를 사용하기 때문에 부인방지는 약함
    * 클라이언트와 서버가 대칭키를 이용하여 매번 다르지만 동일한 패스워드를 생성해야 함
    * 대칭키와 매번 바뀌는 값을 이용하여 패스워드를 생성해야 함

OTP의 종류
비동기화 vs 동기화

비동기화 방식
* 계산할 때 사용할 랜덤 값을 서버가 제공하는 방식
* 장치와 클라이언트 기기 간 통신이 가능하지 않으면 사용자가 직접 시도값을 장치에 입력해야 함

동기화 방식

 
## HOTP


## KDF(Key Derivation Function)
* 대칭키를 랜덤하게 생성하여 사용하는 경우도 있지만
* 패스워드나 키 동의 프로토콜을 수행한 후, 확보한 비밀값을 이용하여 대칭키를 생성하는 경우가 많음
* 이때 사용하는 함수를 KDF
* 패스워드로부터 대칭키를 생성할 경우 패스워드 추측 공격 때문에 salt와 반복 횟수라는 기법을 사용함

## HKDF
* HMAC 기반 KDF를 말하며, 보통 키 동의 프로토콜 수행을 통해 얻은 랜덤 비밀 정보로부터 대칭키를 생성할 때 사용함

## PBKDF
c는 반복횟수(속도를 느리게 하는 요소)

해싱을 여러 번 반복

`Ti = F(Pi, salt, c, i), c는 반복횟수

## Lamport의 해시체인 기법
랜덤한 seed를 이용하여 연속적으로 해시값을 계산하여 생성함

seed가 s이면 길이가 n인 해시체인을 생성하기 위해서는 다음을 차례로 계산함












