# 보안 목적
1. 비밀성(confidentiality, secrecy. privacy) 
* 인가된 개인, 단체, 장치, 프로세스만 데이터의 내용을 볼 수 있도록 해주는 서비스

2. 무결성
* 비인가된 데이터의 변경을 발견할 수 있도록 해주는 서비스
* 변조가 된것을 알 수 있도록 한다

비밀성은 보장되어야 하는 서비스지만 무결성은 발견만 할 수 있으면 된다.

3. 인증
* 식별 + 검증
* 누구인지 신원을 증명하는 것
* 메시지 인증 : 무결성과 동일, 메시지가 변경되지는 않았는지 아는 것
* 메시지 원천지 인증 : 무결성 + 메시지가 송신된 위치 또는 송신자를 검증
* 개체 인증 : 주장된 신원을 검증
    * 개체 인증에 사용되는 요소3가지
        * 사용자만 알고 있는 지식 : 패스워드
        * 사용자만의 독특한 특징 : 생체정보
        * 사용자만이 가지고 있는 것 : ID 카드

4. 부인방지(non-repudiation)
* 개체가 지난 행위나 약속을 부인하지 못하도록 하는 서비스
* 송신 부인방지 : NRO
* 전달 부인방지 : NRD
* 제출 부인방지 : NRS
* 수신 부인방지 : NRR

* 토큰의 종류가 중요한 것은 아니다
* 직접 통신하는 경우와 중계자를 이용하여 통신하는 경우가 있다
* 부인방지 토큰은 보통 해당 행위를 부인할 수 있는 주체가 제공하는 것

 
 # 프라이버시
개인이나 집단이 자신 또는 자신의 정보를 선택적으로 노출할 수 있는 권리

디지털 서비스를 사용할 때 교환된 통신 메시지를 통한 노출을 고려한다.

프러이버시 종류
* 내용 프라이버시
    * 어떤 컨텐츠 사용
    * 비밀성 서비스를 통해 제공할 수 있다
* 행동 프라이버시
    * 어떤 서비스를 사용하는 것 자체를 숨김
* 위치 프라이버시
    * gps 막는거


행동 프라이버시 보장을 위한 요구사항
* 불관찰성 : 특정 메시지의 송수자 또는 수신자를 알 수 없어야 한다
* 불연결성 : 두 개의 메시지가 주어졌을 때, 두 개의 메시지가 동일 송신자가 전송한 것인지 또는 두 개의 메시지가 동일 수신자에게 보내는 것인지 연결할 수 없어야 한다는 것을 말함
* 불연결성은 특정 메시지의 불관찰성이 깨졌을 때 그 파급효과를 최소화하기 위해 제공되어야 한다

## 조건부 프라이버시
완전 프라이버시를 제공하면 사용자들에 의해 악용될 수 있기 때문에 대신 조건부 프라이버시를 제공함

필요한 경우 익명성 철회 가능

익명을 철회하는 권한 남용을 피하기 위해 여러 기관에 권한을 분산하는 것이 필요함
* 임계 기반 비밀 공유기법
* n명에게 특정 권한을 분산하고, 이 중에 t명 이상이 동의하면 해당 권한을 수행할 수 있도록 한다
* t는 보안 강도를 조절하기 위한 보안 변수이다
* 가용성 측면에서 (n, n)은 바람직하지 않은 형태의 서비스

# 통신 계층과 암호기술
통신 메시지의 비밀성/무결성을 보장하기 위한 암호기술의 적용과 통신 계층간의 관계

end-to-end
* 장점
    * 통신망과 독립적으로 수행 가능
    * 기반구조를 신뢰하지 않아도 됨
* 단점
    * 트래픽 분석이 가능
    * 메시지 단위로 암호화하기 때문에 오류 발생시 암호화하는 방식에 따라 재전송해야 하는 부분이 클 수 있음

hop-by-hop
* 장점
    * 트래픽 분석이 가능하지 않음
    * 패킷 단위로 암호화가 가능하므로 오류 발생시 해당 패킷만 재전송
* 단점
    * 통신망의 각 호스트/스위치에 기능이 포함되어야 함
    * 기반구조를 신뢰해야 함(중산 호스트/스위치는 평문을 볼 수 있음)
    * 반복적으로 암호기술을 적용하기 때문에 효율성이 떨어짐



기본 용어
* 평문
* 암호문
* 암호화
* 복호화

# 암호알고리즘
* 좁은 의미 : 암호화 복호화 과정에 사용하는 수학 함수
    * 비밀성 서비스 제공이 목적
* 넓은 의미 : 암호 기술에서 사용하는 모든 알고리즘
    * 다양한 목적
* 현대 암호화 함수와 복호화 함수는 모두 키를 사용
    * ``E. K(M) = C, D.K(C) = M
* 암호키(cryptographic key) : 암호화/복호하에 사용하는 키
    * 현대 알고리즘의 안성성은 키에 의존하고, 알고리즘 자체는 공개한다

## 제한적 알고리즘
현대 알고리즘의 안성성은 키에 의존해야 한다

키 대신에 알고리즘의 비밀성에 의존할 경우 **제한적 알고리즘**이라 한다.

제한적 알고리즘
* 장점
    * 해독하기가 힘듦
* 단점
    * 알고리즘을 공유할 수 없음
    * 역공학의 가능성이 존재함
    * 노출될 경우에는 알고리즘 자체를 변경해야 함

키 의존 알고리즘
* 장점
    * 알고리즘 공유가 가능
    * 키가 노출되면 키 자체만 변경 가능
    * 알고리즘이 공개되어 있으므로 허점의 발견이 용이함
        * 알고리즘 개선에 사용
* 단점
    * 알고리즘이 공개되어 있으므로 허점의 발견의 용이함
    * 악의적인 목적으로 사용 가능

## 키용어
사용 기간 또는 횟수에 의한 분류
* 단기간키, 세션키, 일회용키
    * 매우 제한적으로 사용하는 키
    * 생성 후 일시적으로 사용 후 폐기하는 키
    * 비휘발성 메모리에 유지할 필요가 없는 키
* 장기간키, 다중사용키
    * 여러 번 사용하는 키로 비휘발성 메모리에 유지해야 하며, 안전한 키 관리가 중요함

## 암호 알고리즘의 분류
결정적 vs 확률적
* 결정적 알고리즘 : 입력이 같으면 항상 같은 결과를 반환
* 확률적 알고리즘 : 같은 입력이라도 결과가 항상 다름

대칭 vs 비대칭
* 대칭 알고리즘 : 암호화할 때 사용하는 암호키와 복호화할 때 사용하는 암호키가 같은 암호알고리즘
* 비대칭 암호알고리즘 : 암호화할 때 사용하는 암호키가 복호화할 때 사용하는 암호키가 다른 암호알고리즘


## 대칭 암호 알고리즘
* 비밀키 알고리즘
* 암호화하는 사람과 복호화하는 사람이 같은 키를 가지고 있어야 함
* 종류
    * 스트림(stream) 암호방식 : 평문의 각 바이트를 하나씩 암호화하는 방식
    * 블록(block) 암호방식 : 평문을 일정한 블록 크기로 나누어, 각블록을 암호화 하는 방식

## 합성 암호 알고리즘

# 암호화 모드
블록 암호방식을 사용하는 대칭 알고리즘은 항상 고정된 크기의 블록을 입력으로 사용함

블록방식은 항상 입력의 크기가 같기 때문에 입력의 크기가 부족하면 평문을 블록크기로 만들기 위한 **채우기**가 필요하고 크면 나누어야 한다

* 암호화 모드 : 블록 암호방식에서 블록 크기보다 큰 평문을 암호화하는 방법을 말함

가장 단순한 암호화 모드는 나누어진 개별 평문 블록들을 독립적으로 암호화하는 ECB, 지금은 안씀

## 대칭 암호알고리즘의 사용 용도
* 공개 채널로 전달하는 메시지에 대한 비밀성 보장
    * 송수산자가 공유하는 비밀키로 메시지를 암호화하여 교환함으로써 제 3자가 도청하여도 내용을 알 수 없게 한다
* 기억장치에 저장하는 데이터에 대한 비밀성 보장 
    * 다른 사용자가 저장된 데이터를 열람할 수 없도록 데이터를 암호화하여 저장할 수 있음. 키의 백업이 중요하다(랜섬웨어)
* 개체 인증
    * 서로가 비밀키를 공유하고 있는 경우 서로가 서로임을 확신할 수 있음


## 법 강화를 위한 키 위탁
키 위탁은 키를 복구하기 위해서도 유용하게 사용될 수 있음

# 비대칭 알고리즘
공개키와 비밀키를 사용

각 사용자는 공개키는 공개하고 개인키는 비밀스럽게 유지함

공개키 알고리즘이라고도 한다.

## 사용용도
대칭 알고리즘과 같은 용도로 사용 가능하지만, 상대적 성능문제 때문에 보통 메시지 자체를 암호화하는데 사용되지 않는다.

이 때문에 다음과 같은 하이브리드 방식을 많이 사용함
* {M}.k, {K}.+Ka
* 공개키는 작은 정보만 암호화, 나머지는 개인키로

# 인증서
공개키를 인증할 때 사용되는 전자문서

신뢰할 수 있는 인증기관이 전자서명하여 생성함

인증기관이 공개키를 공증해 준다

## 인증서의 검증
사용자들은 다른 사용자의 공개키를 사용하기 전 인증서를 검증하여 공개키의 사용자를 확인해야 함

인증서를 검증하기 위한 절차
1. 인증서의 서명 확인
2. 인증서의 유효기간 확인
3. 인증서의 사용 용도 확인
4. 인증서의 폐지 여부

위 4가지 단계를 통해 한 번 확인된 인증서는 보통 캐시(또는 파일 시스템)에 보관하며, 이 인증서를 같은 용도로 다시 사용할 경우 유효기간과 폐지기간만 확인함


## 인증서 폐지


# 신원기반 암호시스템
* 공개키 암호알고리즘의 사용에서 공개키의 인증은 매우 중요함
* 인증서를 사용하기 위해서는 공개키 기반구조가 잘 확립되어 있어야 한다
* 인증서 외에 **신원기반 공개키 암호시스템**
* 결국 안씀

* 상대방의 독특한 신원정보로부터 공개키를 유도
* 인증서가 필요없고 다른 사용자의 공개키를 직접 생성 가능

## PKG
* 사용자는 자신의 개인키를 직접 만들 수 있음
    * 자신 뿐만 아니라 다른 사용자의 개인키도 생성 가능
* 이 때문에 신원기반 시스템에서는 사용자의 개인키를 발급하여 주는 PKG라는 신뢰 기관을 사용한다
* 사용자의 개인키는 누구나 생성할 수 있는 해당 사용자의 공개키와 PKG가 비밀로 유지하는 마스터키를 이용하여 생성한다
* PKG는 모든 사용자의 개인키를 만들 수 있으므로 모든 암호문을 복호화할 수 있고, 모든 사용자의 서명을 위조할 수 있다
    * 부인 방지에 취약하다
    * 임계 기반 비밀 공유 기법 활용
        * 여러 기관에 발급 권한을 분배하여 n명중 t명 이상이 협조해야 사용자의 개인키 생성 가능

## 사용자의 신원정보
공개키를 변경하고 싶다면, 신원정보나 PKG의 개인키를 변경해야 함

둘 다 힘듬

이 문제를 해결하기 위해 추가적인 값을 추가한다

대신 추가된 정보를 알아야 상대방의 공개키를 만들 수 있다는 문제가 생긴다


## 중앙집중 인증서 기반 PKI vs 신원기반


## DPKI
* 탈중앙 PKI
    * 중앙집중 인증기관이 인증서를 발급하는 것이 아님
    * 각 개체가 스스로 인증서를 발급하고 관리하는 형태
        * 기존 pki의 ca에 관한 집중 문제를 해결하는 것이 목적
        * 단일 실패점이 사라짐
* 동작 원리
    * 블록체인에 일정한 형식을 갖춘 ID와 공개키를 연결하는 문서를 저장
    * 블록체인이 기존 PKI에서 공개 디렉토리 역할을 한다
    * ID와 실제 개체와의 연결은 다른 방법을 사용
        * 보통 신뢰관계를 점진적으로 확장하는 방법 사용
            * 오프라인에서 서로 교환, 기관 홈페이지에 기관 ID 게시 등

* 블록체인의 특징
    * 불가역성 : 수정, 삭제 불가 삽입만 가능
    * 분산 저장
    * 합의 기술을 이용하여 일관성 유지

# FIDO
Fast Identity Online 지문 인증, 공개키 방식이다.

동작과정은
1. 공개키를 생성하여 서버에 등록한다.
2. 


# 해시함수
임의의 길이에 이진 문자열을 고정된 길이의 이진 문자열로 매핑하여 주는 결정적 함수 

특징
* 압축
* 계산의 용이성
    * x -> f(x) 는 편해야 함
* 일방향성
    * 입력을 모르는 해시값 y가 주어지면 ``H(x`) = H(x)`` 인 x`은 찾기 어려워야 함
* 약한 충돌회피성
    * x가 있을 때 H(x`) = H(x) 인 x를 찾는 것은 어려워야 함
    * x랑 해시값 같은 x` 값 찾기 어려워야 함
    * 같은 값이 나올 확률은 1/2????
* 강한 충돌회피성
    * H(x`) = H(x) 인 서로 다른 임의의 두 입력 x을 찾는 것은 어려워야 함
    * 해시값이 같은 두 값을 찾기 어려워야 함
  
## 생일 파라독스
N 명중 특정 사람 한명과 생일이 같은 사람을 찾기 위해서는 n 이 183명이 되야 하지만, n명중 생일 같은 두 사람을 찾으려면 23명만 있으면 된다

루트 씌우면 됨

## 해시함수의 용도
* 전자서명
    * 서명 크기와 계산 비용을 줄이기 위해 전체 메시지 대신에 메시지의 해시값에 서명함
    * 충돌 회피성이 그래서 중요함
 
 # MAC
* 해시함수는 보통 비밀키를 사용하지 않음
    * 단순히 메시지의 변경 여부를 판단하기 위해 사용하는 해시값을 조작 탐지 코드라 한다
* 비밀키를 추가로 사용하면 송신자의 인증과 무결성을 동시에 제공할 수 있으며, 결과 값을 메시지 인증 코드(MAC)라 한다
    * MAC을 사용하기 위해서는 생성자와 확인하는 사람이 동일한 **대칭키**를 공유하고 있어야 함
* MAC도 해시함수와 같은 요구사항을 충족해야 하며, 추가로 위조가 가능하지 않아야 한다
* MAC을 만드는 방법
    * MAC 전용 알고리즘을 이용하는 방법
    * 대칭 알고리즘을 이용하는 방법

# 무결성
메시지가 변조되지 않았다는 것을 확인하는 것

메시지랑 해시값을 전부 바꾸면 수신자는 변경사실을 알 수 없음

* 해결법 1. MAC
    * MAC값을 알아야 하기 때문에 변조 못함
    * 키를 사전에 공유해야 한다는 문제점
    * 같은 키가 여러개니 누가 만들었는지는 모른다
* 해결법 2. 전자 서명
    * 값이 바뀌면 전자서명이 유효하지 않아 변조하면 알 수 있다
    * 공개키만 수신자가 있으면 되므로 누구나 확인 가능
    * 누구나 만들수는 없다
    * 효율은 mac이 좋다

# 무결성과 비밀성을 동시에
* 인증 암호화 : 비밀성과 무결성을 동시에 제공하는 방법

1. 암호화할 때 해시값 또는 MAC값을 포함하는 방법
2. 메시지에 독립적으로 대칭암호알고리즘과 MAC을 적용하는 방법
    * JWT
    * 메시지는 알 수 있다
    * 무결성만 확인
3. 메시지를 암호화한 후 암호문에 대한 MAC 값을 계산하는 방법
    * encrypt-then-mac 
    * mac 값이 확인되지 않으면 복호화를 하지 않음
    * 암호화하고 암호문을 MAC 
    * 나머지는 복호화를 무조건 해야하지만 얘는 아님
    * 가장 안전

# 일반 서명과 전자서명의 차이점
* 전자서명은 수학적으로 서명자를 검증할 수 있음
* 전자서명의 안전성은 동일한 알고리즘을 사용할 경우에는 사용자마다 같은 안전성을 제공함
* 일반 서명은 문서 위에 하지만 전자서명은 보통 문서와 별도로 존재함
* 전자서명은 원본과 복사본을 구분하기가 힘듦


## 전자서명의 요구사항
* 인증(authntic) : 누가 서명했는지 확인이 가능해야 함
* 위조불가 : 위조불가
* 부인방지 : 나중에 부인할 수 없어야 함
* 재사용불가 : 서명은 다른 용도로 사용할 수 없어야 함
* 변경불가 : 서명된 문서의 내용을 변경할 수 없어야 함


# 전자서명 방식의 종류
* 직접 서명 방식 : 서명자가 홀로 서명 알고리즘을 수행하여 서명하는 방식
* 문제점. 서명키의 분실/도난
    * 서명자가 직접 서명 시간을 서명에 포함할 경우에는 서명키를 획득한 공격자의 부정을 증명할 방법이 없음
* 중재 서명 방식 : 중재자와 프로토콜을 수행하여 서명하는 방식
    * 중재자는 서명의 증인 역할을 하게 됨
    * 서명자가 시간에 대한 부정을 할 수 없음
    * 중재자는 신뢰기관이어야 함

# 전자서명 알고리즘의 분류
메시지 복구 여부에 따른 분류
* 메시지 복구 가능 전자서명 알고리즘
    * 작은 메시지에 대해서만 가능
* 첨부 형태 전자서명 알고리즘
    * 메시지와 서명 블록이 별도로 존재하며, 메시지와 서명 블록이 함께 제시되어야 검증 가능
    * 보통 해시함수를 이용함

결정 vs 확률 서명 알고리즘
* 결정 서명 알고리즘 : 메시지가 같으면 항상 결과 서명이 같은 알고리즘
* 확률 서명 알고리즘 : 메시지가 같아도 서명할 때마다 그 결과가 달라지는 알고리즘


# 암호알고리즘에 대한 안정성
* 암호알고리즘 : 복호하키를 모르는 상태에서 암호문으로부터 평문이나 키를 얻을 수 없어야 한다
    * 평문이나 키의 일부도 얻을 수 없어야 한다
    * 공개키 암호알고리즘은 공개키로부터 개인키를 얻을 수 없어야 한다

* 해시함수 : 해시값의 역이나 충돌을 찾을 수 없어야 한다
등등

# 현대 암호학의 특징
* 과거에는 오랫동안 허점이 발견되지 않은 것을 안전한 것으로 여긴다
* 오늘날에는 엄격한 안정성 증명을 중요하게 생각함

* 무조건적 안정성 : 무한한 컴퓨터 자원을 가져도 암호알고리즘을 해독할 수 없는 경우
* 계산적 안정성 : 공격자의 능력이 현실적일때 해독하기 위한 노력이 불합리하게 많은 컴퓨터 시간을 요구할 경우
    * 증명가능 안정성 : 어렵다고 알려진 문제와 등가임을 증명함

## 완벽한 안정성 vs 의미론적 안정성
완벽한 안정성은 현장에서는 사용 불가

계산적 안정성만 있어도 현장에서 사용 가능하다

이 때문에 등장한 개념이 의미론적 안정성

## 암호해독 공격의 분류
* 전사 공격 : 가능한 모든 키를 검사하는 방법
    * 암호해독 공격은 아님
* 암호문 단독 공격
    * 공격자가 암호문만 얻을 수 있는 경우
* 기지 평문 공격
    * 공격자가 특정한 개수의 평문과 암호문 쌍만을 얻을 수 있음
* 선택 평문 공격
    * 특정한 개수의 평문과 암호문 쌍을 얻을 수 있지만 공격자는 원하는 평문을 선택할 수 있음
* 선택 암호문 공격
    * 원하는 암호문
* 적응적 선택 평문 공격 
    * 이전에 얻은 쌍들을 바탕으로 추가적으로 원하는 평문을 얻을 수 있음
* 적응적 선택 암호문 공격 
    * 이전에 얻은 쌍들을 바탕으로 추가적으로 원하는 암호문을 선택할 수 있ㅇ듬



## 공격의 복잡성 척도
* 데이터 복잡성 : 공격이 성공하기 위해 필요한 데이터의 양
    * 공격에 성공하기 위해 필요한 평문/암호문 쌍
* 처리 복잡성 : 공격이 성공하기 위해 필요한 시간
    * 병렬처리 가능 여부
* 저장공간 요구사항 : 공격하기 위해 필요한 메모리 공간

## 알고리즘에 대한 공격 결과
* 완전 성공 : 암호키 발견
* 광역 성공 : 암호키를 발견하지 못했지만 복호하할 수 있는 알고리즘 발견
* 인스턴스 성공 : 어떤 암호문으로부터 그것의 평문을 얻어냄
* 정보 추출 : 암호문으로부터 평문의 일부나 암호문의 일부를 알아냄

## 부채널 공격
부채널 : 알고리즘의 입력과 출력 외에 다른 정보를 이용하는 것

암호화에 걸리는 시간이나 걸리는 전력양 계산

## 양자컴퓨팅과 암호기술
* 아직 현실화되지는 않음


# 암호프로토콜
## 프로토콜
어떤 목적을 달성하기 위해 2명 이상이 참여하는 유한한 일련의 단계

프로토콜의 특성
* 사전에 서로 알아야 함
* 참여자 간에 동의하고 있어야 함
* 모호하지 않아야 함
* 완정성 : 완전해야 함

프로토콜 : 어떤 목적을 달성하기 위해 2명 이상이 참여하는 유한한 일련의 단계

트랜스크립트 : 한 수행에서 교환된 메시지들

암호 프로토콜 : 암호 기술을 사용하는 프로토콜

일반 프로토콜과의 차이점 : 공격자의 존재를 가정하고 만든다

일반 프로토콜 : 완전성

암호프로토콜 : 완정성 + 안정성


## 암호프로토콜에 대한 공격
공격의 종류
* 수동 공격 : 프로토콜의 진행을 방해하지 않는 공격
* 능동 공격 : 프로토콜의 진행에 개입하는 공격

공격 방어의 기본은 공격 사실을 인지하는 것

## 프로토콜의 참여자
실제 사용자를 의미할 수 있고, 사용자가 사용하는 장치 또는 소프트웨어일 수 있음

참여자의 분류
* 일반 참여자
    * 프토콜을 통해 얻고자 하는 것이 있는 이해 당사자
* 제 3기관
    * 프로토콜의 실행 결과에 대한 어떤 이해 관계가 없고, 어떤 참여자와도 특별한 협력 관계가 없지만 원할한 프로토콜의 수행을 위해 참여하는 참여자
    * 신뢰 : 프로토콜이 정한 규칙대로 프로토콜을 수행함
    * 부정행위를 하지 않는다는 것은 아님
    * 다른 말로 중재자
* 암호프로토콜에서는 항상 공격자의 존재를 가정함

## TTP의 종류
* 인라인 TTP : 프로토콜의 모든 과정에 참여
    * 모든 메시지는 항상 TTP를 경유함
* 온라인 TTP : 프토코로의 일부 과정에서는 항상 참여
* 오프라인 TTP : 실제 프로토콜 수행과정에서 참여하지 않지만 사전에 또는 사후에 필요에 따라 참여


## 암호프로토콜의 분류
* 자체 강화 프로토콜
    * 중재자가 필요 없는 프로토콜
* 중재 프로토콜
    * 중재자가 프로토콜에 항상 참여
* 판결 프로토콜
    * 분쟁이 발생한 경우에만 판결자가 참여
    * 프로토콜은 분쟁을 해결할 수 있도록 증거를 남겨야 함
    * 중재자는 증거를 검사하여 분쟁을 명확히 해결할 수 있어야 함

신뢰하는 제 3의 중재자를 사용할 경우 발생할 수 있는 문제
* 프로토콜 자체가 수행불가
    * 이 문제를 단일 실패점이라 한다
* 중재자의 신뢰성 문제
* 중재자를 유지하고 관리하는 추가 비용 소요
* 추가적인 통신 지연
* 모든 프로토콜 수행에 관여하여야 하므로 병목현상 발생 가능


## 암호프로토콜 설계 절차
* 설계 순서
    * 달성 목적을 포함한 프로토콜의 정의
        * 환경, 참여자, 사용 장치 등등
    * 요구사항 분석
        * 목적, 요구사항
    * 가정 분석
        * 참여자 가정 : 참여빈도, 신뢰관계
        * 환경에 대한 가정 : 네트워크, 장치, 이동성
        * 공격자에 대한 가정 : 공모 공격 포함
    * 설계
    * 증명 : 요구사항이 충족됨을 증명해야 함
    * 구현
        * 소프트웨어 구현 결과에 대한 검증이 반드시 필요함

* 참여자에 대한 가정
    * 보통 일반 참여자들은 서로를 신뢰하지 않음
    * 신뢰 서버는 보통 서버가 수행해야 하는 모든 기능에 대해 신뢰 있게 행동한다고 가정함
* 공격자에 대한 가정
    * 가정 1. 프로토콜을 통해 교화되는 모든 메시지를 확보할 수 있음
    * 가정 2. 진행을 방해 가능, 메시지 변경 삽입 차단 등등
    * 가정 3. 정상적 참여자가 아닐 수 있다
    * 가정 4. 오래된 세션키는 공격자에게 노출 가능
    * 가정 5. 공모 공격을 할 수 있음


## 키 확립 프로토콜
두 사용자가 대칭 암호 알고리즘을 사용하여 원격에서 메시지를 비밀스럽게 교환하기 위한 전제조건은? 동일 대칭키의 공유

* 키 확립 프로노콜 : 둘 이상의 참여자 간의 비밀키를 공유할 수 있도록 해주는 암호프로토콜

* 키 확립 프로토콜을 통해 얻어지는 비밀키는 단일 세션에 사용하기 위한 세션키이다
    * 한번 쓰면 사라짐



# 블록 방식의 대칭 암호알고리즘의 특성
블록 암호방식 : 정해진 크기의 입력 입력과 같은 크기의 출력
* 평문이 블록크기보다 작으면 채우기가 필요하다, 크면 암호화 모드

단일블록크기의 서로 다른 메시지 M과 M`의 암호화

    E.K(M) = C, E.K(M`) = C`

C와 C`, M도 서로 어떤 상관관계도 없음

서로를 가지고 어떤 예측도 불가능


## 키 확립 프로토콜
두 사용자가 대칭 알고리즘을 통해 원격에서 메시지를 비밀스럽게 교환하기 위해서는 동일 대칭키의 공유가 필요하다

키 확립 프로토콜 : 둘 이상의 참여자 간의 비밀키를 공유할 수 있도록 해주는 암호 프로토콜

프로토콜을 통해 얻어지는 키는 세션키

세션키를 사용하는 이유
* 같은 키로 암호화된 암호문을 제한
* 키가 노출되었을 때 누설되는 정보의 양을 제한
* 키 저장에 관한 안전성 문제를 해결
* 세션 간 또는 응용프로그램 간의 독립성 제공

## 키 확립 프로토콜의 요구사항
1. 참여자는 의도한 다른 참여자들과 사용할 수 있는 새로운 키를 얻어야함
    * 의도한 참여자
        * 키의 용도를 확인할 수 있어야 함
            * 누구와 사용하기 위한 키인지
        * 참여자의 인증이 필요할 수 있음
            * 키 생성자 인증
                * 키를 누가 생성하였는지, 누가 보냈는지 확인할 수 있어야 함
                * 키를 인증서버가 대신 생성해 줄텐데 인증서버가 발급한 키가 밎는지 확인할 수 있어야 한다
    * 키 확인
        * 다른 참여자도 나와 같은 키를 가지고 있다는 것을 확인할 수 있어야 함
        * 참여상대에 대한 인증이 필요할 수 있음
    * 키의 최근성
        * 키가 최근에 생성되었다는 것을 확인할 수 있어야 함

2. 새로운 키는 의도된 참여자 외에 다른 참여자들은 얻을 수 없어야 함
    * 키의 비밀성이라 한다
    * 사실 키의 인증을 도와주는 서버는 알 수 있다

### 키 교환 시도
중재 서버를 사용하는 키 전송 프로토콜

문제점
* 공격자는 도청하여 세션키를 얻을 수 있음
* Alice와 Bob은 K가 둘 간 공유하기 위해 생성된 키인지 알 수 없음
    * 키의 용도
* 최근성도 알 수 없음
* K를 중재 서버가 생성하였다는 것을 확인할 수 없음
    * 생성 주체에 대한 인증 기능이 없음
* 서로 같은 키를 가지고 있는지 확인 할 수 없음


### 키 교환 시도 2
서버와 사용자들이 사전에 키를 공유

해당 키로 각자 암호화하여 A에게 전송

A가 B의 키를 B로 전송

키의 비밀성만 보장된다.

키를 누가 생성했는지 유효기간은 아직 남았는지 알 수 없다

시도 2에 대한 공격
* A에서 B로 키를 보낼 때 중간에서 C가 탈취 가능
* 키와 같이 통신 상대방에 대한 정보를 보내는데 이것을 변경 가능하다

공격2
* A가 서버로 키를 요청할 경우 C가 중간에 탈취
* 서버는 A와 C가 통신하는 데 필요한 키로 착각 
* A는 AC 를 AB로 착각함

공격3
* 이미 유효기간이 지난 키를 전송

## 시도 3
키와 키의 주인을 나타내는 값을 같이 암호화

암호문에 식별자까지 포함시킨다 이것을 **naming 기법**이라 한다.

암호문내에 식별자가 들어있으니 중간에 탈취하여 사용자를 변경하는 것이 불가능하다

근데 아직 유효기간은 안넣음

그리고 BCP의 한계로 안됨

암호화를 블록 단위로 진행하는데 블록 순서를 주무를 수 있다

그래서 무결성을 보장해 줘야 한다 그래서 인증 암호화가 필요하다

## 시도 4
랜덤 수 Na를 넣는다

이제 풀어서 볼 수 없고 조작도 하면 알 수 있다

1. A가 서버로 A, B, Na 보냄
2. 서버가 A용 B용 키 반환
3. A가 B에게 사용할 키 전송
4. B는 키 확인 후 해당 키가 맞는지 A에게 확인 요청
5. A는 확인하여 반환

## 시도 5
둘 중 하나가 자기 N 다른 애한테 전송

받은 애는 자기 N까지 같이 서버에 전송하여 키를 받는다

N은 통신할 때 생성함으로 N을 갖고있다는 것은 최근에 생성한 토큰


## 암호화의 용도
* 비밀성을 보장하기 위해 사용
    * 누가 복호화할 수 있는지가 중요하다
    * Ka 면 a만 복호화
    

* 인증을 제공하기 위해 사용
    * 누가 암호화할 수 있는지가 중요
    * A만 만들 수 있으면 A가 만든 것이라고 한다
    * A와 B만 생성할 수 있는 비밀키의 경우
    * A가 자기가 생성하지 않았다면 이건 B가 생성했다고 확신할 수 있음
    * A와 Server만 만들 수 있다면 A입장에서 서버에서 만들었다는 것을 확신할 수 있음


* 메시지의 구성요소를 바인딩 하기 위해 사용
    * 실제 비밀성이 요구되는 요소는 Kab 뿐이다
    * 하지만 같이 묶여서 암호화된 것으로 연관되어 있다는 것을 알 수 있음
    * 꼭 같이 암호화되야 하는것이 아닌 해싱 등과 같이 같이 묶여있으면 바인딩된 것

* {B||Na||Kab}.Kas를 MAC을 사용해서 변경하면 다음과 같은 효과를 얻을 수 있다
    * {Kab}Kas, MAC.K`as{B||Na||Kab}
    * 비밀성이 요구되는 정보만 암호화하였고
    * 바인딩은 MAC을 통해 제공하고 있고
    * Kab의 무결성을 확인할 수 있다
    * MAC을 사용함으로써 무결성을 얻을 수 있고, Kab를 검증할 수 있다

## 인증 암호화


## 대칭 암호알고리즘의 사용
* 대칭키로 암호화의 의미
    * 인증
        * Kab의 경우 B가 생성하지 않았다면 A가 생성한 것
    * 비밀성
        * Bob과 Alice만 암호문을 복호화하여 M을 얻을 수 있다

* 대칭키 사용의 가장 큰 이슈
    * 대칭키를 어떻게 안전하게 공유할 것인가?
* 대칭/비대칭 암호알고리즘은 기본적으로 무결성을 제공하지 않음
    * 무결성까지 필요하면 인증 암호화

## 비대칭 암호알고리즘의 사용
* 공개키 암호알고리즘에서 개인키로 암호화
    * A가 개인키로 M을 암호화하여 전달
    * 인증
        * A의 공개키로 메시지를 복호화하는데 상공했다면 B는 해당 메시지를 A가 생성했다고 확신할 수 있다

* 공개키 암호알고리즘에서 공개키로 암호화
    * A가 B의 공개키 +Kb로 메시지 M을 암호화하여 전달
    * 비밀성
        * 오직 B만 암호문을 복호화하여 M을 얻을 수 있음
    * 인증
        * B는 누가 이 메시지를 생성하였는지 확인할 수 없음

* 두 경우 모두 대응되는 공개키가 확실히 A또는 B 것임을 확신할 수 있어야 함

## 암호프로토콜의 안정성
* 암호프로토콜은 그것의 보안 요구사항을 모두 충족하였을 때 안전한 프로토콜이라 한다
    * 암호프로토콜은 물론 안전성도 중요하지만, 효율성도 중요함
* 암호프로토콜의 안전성을 증명하기 위해 다양한 방법을 사용하고 있지만 쉽지 않다
    * 보통 지금까지 알려진 공격에 대해서만 안전함
    * 여러 가정 하에서만 증명이 가능한 경우가 많으며, 특정 요구사항 충족에 대해서만 증명이 가능한 경우도 있다
* 암호프로토콜만 안전하다고 하여 전체 시스템이 안전한 것은 아님
    * 서버, 클라이언트 해킹, 서비스 거부 공격 등 프로토콜의 설계를 통해서 방지할 수 없는 위협이 존재함

## 안전성 증명
* 암호프로토콜에 대한 증명은 보통 프로토콜의 보안 요구사항을 고려하여 보안 모델을 세우고, 이 모델에서 증명함
* 보안 모델이란 프로토콜의 안정성을 논하기 위해 세우는 가정들의 집합
    * 가정 중에 가장 중요한 것은 공격자의 능력ㅋㅋ
    * 능력에 따라 공격의 성공 가능성이 다름
    * 공모 공격에 대한 검토가 있어야 함

* 공격자의 능력
    1. 모든 참여자 간의 통신을 제어
    2. 지난 프로토콜 수행을 통해 확립된 세션키를 얻을 수 있음
    3. 공격자가 참여자의 장기간 키를 알고 있음

* 공격자의 종류
    * 제3의 공격자와 내부공격자로 나눌 수 있고, 내부공격자에 대해서는 다음과 같은 가정을 할 수 있음
        * 가정1. 악의적인 내부자의 존재 : 프로토콜의 적법한 참여자가 악의적인 행동을 할 수 있음
        * 가정2. 정직한 내부자 : 적법한 참여자는 항상 정직하게 행동함
    * 보통은 가정 1 

## 프로토콜의 효율성
* 두 측면에서 효율성을 고려
    * 계산 효율성 : 프로토콜의 참여자가 프로토콜을 완료하기 위해 계산해야 하는 양에 의해 측정됨
    * 통신 효율성 : 메시지의 수와 각 메시지의 크기에 의해 측정됨
* 계산 효율성
    * 사용하는 암호기술에 의해 결정됨
    * 공개키를 사용하는 프로토콜은 공개키 연산을 최소화하는 것이 필요함

* 통신 효율성
    * 필요한 라운드의 수를 줄이는 것이 가장 효과적
    * 프로토콜의 한 라운드는 한 시점에서 병렬로 전달할 수 있는 모든 메시지를 포함함
    * 메시지가 서로 독립적이지 않으면 서로 다른 라운드에 포함됨
        * 메시지가 이전 메시지의 구성요소를 포함하면 이 두 메시지는 서로 의존하는 메시지

    

# 암호프로토콜 기초 설계 기술
## 블록방식의 대칭 암호알고리즘의 특성
1. 메시지와 암호화된 데이터 사이에는 어떤 상관관계도 없다
2. 암호화한 데이터를 다른 키로 복호화한 결과 예측 불가
3. 암호화된 데이터가 조작되면 복호화한 결과 예측 불가
4. 메시지가 수신자가 알고 있는 내용이 아니면 복호화해도 이게 제대로 된건지 알 수 없다
    * 수신자가 복호화해서 메시지를 얻었을 때,
    * 메시지에서 알아볼 수 있는 무언가가 있어야 함
5. 메시지의 일부가 확인할 수 있는 값이고, 복호화 후 그것이 확인되면 C가 K를 이용하여 생성한 암호문인지 확인 가능
    * 즉 복호하하여 얻은 메시지에 대해 무결성 확인 가능
    * 이처럼 암호문을 생성할 때 사용한 암호키를 확인할 수 있게 해주는 평문의 요소를 여분 정보라 한다
    * 인증 암호화 생기고 나서는 사용하지 않는다?


다중 블록의 경우
* M1과 M2가 있다면 M1,M2 모두에 여분 정보가 있어야 K로 암호화된 블록임을 확신할 수 있다
* 둘 다 여분정보가 있어도 서로 연결할 수 있는 부분이 없다면 M1과 M2가 M을 쪼개서 암호화하여 만든 암호 블록임을 확신할 수 없다
    * 공격자는 전송되는 메시지를 다양하게 조작 가능
    * 여분 정보의 유무에 따라 할 수 있는 조작이 달라짐


인증 암호화 방법을 사용한 경우
* MAC(encrypt then mac) : 메시지를 암호화한 후 mac값을 계산  
* MAC값이 확인된 경우에만 복호화 시도
    * MAC 값이 확인되면 C의 무결성을 확신할 수 있음
* MAC값이 확인되고 상대방을 신뢰하면 C가 특정키를 이용하여 생성한 암호문인지 여부를 확신할 수 있다
    * C가 단일 블록이 아니라도 성립한다
    * 상대가 애당초 이상한 것 보내면 그거는 알 수 없다

* 인증 암호화를 하지 않으면 블록 크기, 평문의 각 요소의 크기, 평문의 구성 등이 바인딩에 영향을 준다
    * 실제 바인딩되었다고 확신하기 어려울 수 있다
* 인증 암호화를 하면 전송 과정의 조작은 발견할 수 있다
    * 송신자가 애초에 메시지를 엉뚱하게 구성하면 문제
        * 이때문에 신뢰할 수 있어야 함
    * 상대방을 신뢰할 수 있다면 여분 정보 없이 수신한 암호문이 어떤 키로 암호화되었는지 확신할 수 있다
    * 상대방을 신뢰할 수 있다면 바인딩에 대해서도 확신할 수 있다
* 인증 암호화가 모든 문제를 해결하는 것은 아님

## 여분 정보
* 평문에 여분 정보가 없다면 올바른 키를 이용하여 복호하하였는지 판단할 수 없음
    * 여분 정보란 복호화의 정확성을 확인할 수 있도록 해주는 요소

* 여분 정보의 분류
    * 명백한 여분 정보 : 누구나 확인할 수 있는 정보
        * 식별자
        * 수동적인 암호해독 공격을 용이하게 해줌
        * 특히 패스워드와 같이 사전 공격이 가능하거나, 비교적 작은 공간에서 선택된 암호키를 이용하여 암호화한 암호문 내에는 명백한 여분 정보를 포함하지 않는 것이 바람직함
            * 추측 가능함
    * 함축적 여분 정보 : 오직 수신자와 송신자만이 알고 있는 정보

