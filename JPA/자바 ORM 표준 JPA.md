http://www.yes24.com/Product/Goods/19040233

1. [SQL 중심적인 개발의 문제점](#SQL-중심적인-개발의-문제점)
2. [JPA](#JPA) 
3. [영속성 컨텍스트](#영속성-컨텍스트)
4. [엔티티 매핑](#엔티티-매핑)
5. [연관관계 매핑 기초](#연관관계-매핑-기초)
6. 상속 관계 매핑
7. 프록시와 연관관계 관리
8. 값 타입
9. 객체지향 쿼리 언어

# SQL 중심적인 개발의 문제점

## SQL에 의존적인 개발을 피하기 어렵다
중간에 domain 에 변경이 있으면 관계된 모든 sql을 일일히 수정해야 한다.

번거롭고 특정 sql을 실수로 수정하지 않는 등 실수의 여지가 많다

## 패러다임의 불일치
* 객체와 관계형 데이터베이스의 차이

1. 상속
2. 연관관계
3. 데이터 타입
4. 데이터 식별 방법

등에서 여러가지로 힘들어진다.

객체지향적으로 개발할수록 매핑이 힘들어지는 문제가 생긴다.
그래서 대안으로 나온 것 이 JPA

# JPA(Java-Persistent-Api)
JPA는 ORM 기술이다

ORM(Objective-relational mapping)
* 객체는 객체대로, 관계형 db는 관계형 db대로 설계
* ORM 프레임워크가 중간에서 매핑

JPA는 Java 애플리케이션과 JDBC 사이에서 동작한다. DB에서 JDBC 가 받으면 그것을 JPA가 매핑하고, 애플리케이션에서 JPA로 보내면 JPA가 JDBC에 매핑한다.

## JPA 장점
생산성
* CRUD 쿼리가 이미 존재한다

유지보수
* 기존 필드 변경시 SQL은 자동으로 JPA가 처리

패러다임 불일치 해결
* 상속 등 자동으로 처리해준다

신뢰할 수 있는 엔티티, 계층
* 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장한다
    * user1 == user2 보장


## JPA의 성능 최적화 기능
1. 1차 캐시와 동일성 보장
* 엔티티 매니저 안에서 캐시 기능 지원
* 같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상 

2. 트랜잭션을 지원하는 쓰기 지연
* 트랜잭션을 커밋할 때까지 비슷한 SQL을 모은다
* JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송한다

3. 지연 로딩
    
지연 로딩
* 객체가 실제 사용될 때 로딩

즉시로딩 
* JOIN SQL 로 한번에 연관된 객체까지 미리 조회

## JPQL
JPA 가 제공하는 SQL 을 추상화한 객체 지향 쿼리 언어

SELECT, GROUP BY, HAVING, JOIN 등을 지원한다

엔티티 객체를 대상으로 쿼리

## 엔티티 매니저 팩토리와 엔티티 매니저
EntityManagerFactory 라는 클래스가 요청이 올 때마다 EntityManager을 생성, EntityManager 는 DB 커넥션을 사용하여 DB를 사용한다.



# 영속성 컨텍스트
엔티티를 영구 저장하는 환경이라는 뜻

EntitiyManager.persist(entity) 라고 하면 엔티티를 db가 아닌 영속성 컨택스트라는 곳에 저장한다.

## 엔티티의 생명주기
비영속
* 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
* 객체를 생성하기만 한 상태

영속
* 영속성 컨텍스트에 관리되는 상태 
* 엔티티메니저에 persist 해서 객체를 넣은 상태
* 바로 db에 날라가는 것이 아님

준영속
* 영속성 컨텍스트에 저장되었다가 분리된 상태 
* detach 

삭제
* 삭제된 상태


## 영속성 컨텍스트의 이점
* 1차 캐시
    * 바로 DB 에 가는 것이 아닌 캐시를 먼저 조회한다
    * 캐시에 없다면 DB 를 조회한 후 캐시에 저장한다
    * 트랜잭션 단위로 작동하고 트랜잭션이 끝나면 영속성 컨텍스트도 종료하기 때문에 사실 별로 도움이 안된다

* 동일성 보장
    * == 비교하면 같다

* 트랜잭션을 지원하는 쓰기 지연
    * insert 문을 모았다가 커밋 시점에 한번에 보낸다
    * batch 옵션이다

* 변경 감지(Dirty checking)
    * 엔티티메니저에 객체를 넣고 나면 객체를 변경하기만 해도 DB까지 자동으로 변경됨

* 지연 로딩


## 플러시
영속성 컨텍스트의 변경내용을 데이터베이스에 반영

영속성 컨텍스트를 비우지 않는다

영속성 컨텍스트의 변경내용을 데이터베이스에 동기화

트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 된다

플러시 발생
* 변경 감지
* 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
* 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

영속성 컨텍스트를 플러시하는 방법
* em.flush() - 직접 호출
* 트랜잭션 커밋 - 플러시 자동 호출
* JPQL 쿼리 실행 - 플러시 자동 호출


## 준영속
객체를 더 이상 영속성 컨텍스트에서 관리하지 않는 상태.

detach, clear, close 로 준영속 상태로 만들 수 있다.



# 엔티티 매핑

## 객체와 테이블 매핑
@Entity
* JPA 가 관리하는 엔티티
* JPA 를 사용해서 테이블과 매핑할 클래스는 @Entity 필수이다.
* 주의
    * 기본 생성자 필수
    * final 클래스, enum, interface, inner 클래스 사용 X
    * 저장할 필드에 final 사용 X 

@Entity 속성
* name
    * JPA 에서 사용할 엔티티 이름 지정
* Table(name="")
    * 매핑할 테이블 지정



### 데이터베이스 스키마 자동 생성
옵션에 따라 테이블 자동으로 변경 가능하다

entity 를 수정하면 그에 맞춰 테이블을 자동으로 수정해준다.


## 필드와 컬럼 매핑

java 타입과 컬럼 타입
* 기본 자료형은 자동으로 매핑된다
* Enum 타입 등은 
    * @Enumerated(EnumType.STRING) : enum 이름으로 매핑
    * @Enumerated(EnumType.STRING) : enum 순서로 매핑
    * 순서는 바뀔 수 있기 때문에 이름으로 매핑하는 것을 권장한다
* 날짜 타입은 @Temporal(TemporalType.TIMESTAMP), timestamp, date, 등 세가지가 있다
    * java 8 이후로는 Tiemstamp, DateTime 등을 지원하기 때문에 쓸 일이 없다
* @Lob 은 큰 컨텐츠에 사용

@Column(name="", nullable=false/true, unique=true/false)


## 기본키 매핑
직접할당은 @Id, 자동할당은 추가로 @GeneratedValue

@GeneratedVlaue(strategy = GenerationType.{})
* 자동할당 전략을 선택 가능하다
* GenerationType.IDENTITY
    * mySql 의 auto_inclement
* GenerationType.SEQUENCE
    * oracle
* 여러가지 있다, IDENTITY 등 자동 생성 권장

@SequenceGenerator(
        name="ORDER_SEQ_GENERATOR",
        sequenceName = "MEMBER_SEQ",
        initialValue=1, allocationSize = 50
)
* sequence 에서 allocation size 를 이용하여 미리 여러 로를 할당하는 방식으로 insert 문이 여러 번 네트워크를 타지 않도록 할 수 있다
    * 성능최적화
    * 동시성문제도 없다
* 

IDENTITY 의 경우 DB에 insert 되야지만 ID 값을 알 수 있다. 그래서 커밋하는 시점이 아닌 영속성 컨텍스트에 들어가는 즉시 db에 insert 문을 바로 보내도록 한다.


## 데이터 중심 설계의 문제점
객체를 설계할 때 memberId, orderId 등 관계를 나타내는 id 를 가지고 있는 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식

테이블의 외래키를 객체에 그대로 가져온다

객체 그래프 탐색이 불가능해진다

참조가 없으므로 UML도 잘못된다.


# 연관관계 매핑 기초
## 단방향 연관관계
@ManyToOne
* 1 대 n 관계라고 jpa 에 알려주는 어노테이션

@JoinColumn(name="FK")
* 조인해야 하는 컬럼을 가리킴

ex)
Team 
@ManyToOne
@JoinColumn(name="USER_ID")
private Long userId;


## 양방향 연관관계
DB에서는 두 테이블 중 하나에만 FK 가 있으면 양쪽 다 접근 가능하다.

하지만 객체에서는 양쪽 다 서로를 참조해야 양방향으로 접근이 가능하다

    ex)
    Member Long id, Team team
    Team    Long id

    Team 에서 Member로 접근 불가

    -->

    Member Long id, Team team
    Team    Long id, List<Member> members

    양방향 접근 가능

@OneToMany(mappedBy="team")  
* List 에 어노테이션을 붙임으로서 연관관계를 알릴 수 있다


## 연관관계의 주인과 mappedBy
객체의 양방향 관계는 사실 양방향 관계가 아닌 서로 다른 단방향 관계 2개

객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.

객체에서는 단방향 연관관계가 2개이지만, RDB에서는 양방향 연관관계 하나가 존재한다. 따라서 객체의 어떤 단방향 연관관계가 RDB의 연관관계와 매핑될 것인지 결정해야 한다.

이것을 연관관계의 주인이라 한다.

### mappedBy
@OneToMany 를 mappedBy 없이 사용하게 되면 두 테이블의 관계 테이블을 생성하게 된다. 왜냐하면 1 대 다 관계에서 1 측 테이블은 외래키를 가지지 않는다. 따라서 1측에서 다 측으로 가기 위해서는 관계 테이블이 필요하기 때문이다.

1:n 단방향 관계에서 1이 관계의 주인이라면 @JoinColumn 을 사용해주면 된다.

참고로 @ManyToOne 은 테이블의 fk 를 가지고 다른 테이블을 찾아가면 되므로 관계 테이블을 만들 지 않는다. 

mappedBy 를 사용해 관계의 주인을 명시함으로써 관계 테이블이 생성되지 않고 관계의 수정 또한 관계의 주인을 통해서만 가능하게 할 수 있다.  

### 연관관계의 주인(Owner)
* 객체의 두 관계중 하나를 연관관계의 주인으로 지정한다
* 연관관계의 주인만이 외래 키를 관리한다(등록, 수정)
* 주인이 아닌쪽은 읽기만 가능하다
* 주인은 mappedBy 속성을 사용하지 않는다
* 주인이 아니면 mappedBy 속성으로 주인을 지정한다

* 외래 키가 있는 곳을 주인으로 정해라!!
    * 성능이슈나 여러 가지 문제를 해결가능

## 양방향 매핑시 가장 많이하는 실수
1. 순수한 객체 관계를 고려하면 항상 양쪽 다 값을 입력해야 한다.
    * 사실 주인쪽에만 관계를 넣어도 테이블에는 들어간다.
        * 참고로 주인이 아니면 관계를 추가하더라도 테이블에 들어가지 않는다.
    * 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다.
    * 연관관계 편의 메소드를 만들자
    * 함수 하나로 둘 다 세팅할 수 있도록 set 메서드를 따로 만들자
2. 양방향 매핑시에 무한 루프를 조심하자
    * toString(), lombok, JSON 생성 라이브러리 등
    * 자동 생성을 사용하면 서로의 toString 을 호출하며 무한 루프에 빠진다
    * lombok 에서 toString 은 사용하지 말고, JSON 생성의 경우는 Controller 에서 Entity를 절대 반환하지 않으면 됨

## 양방향 매핑 정리
* 단방향 매핑만으로 이미 연관관계 매핑은 완료
* 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
* JPQL 에서 역방향으로 탐색할 일이 많음
* 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음)

## 연관관계의 주인을 정하는 기준
* 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
* 연관관계의 주인은 외래 키의 위치를 기준으로 정해야 함

# 다양한 연관관계 매핑
## 연관관계 매핑시 고려사항
1. 다중성
2. 단방향, 양방향
3. 연관관계의 주인

### 다중성
* n : 1 : @ManyToOne
* 1 : n : @OneToMany
* 1 : 1 : @OneToOne
* n : M : @ManyToMany
    * 실무에서 쓰면 안됨

### 단방향, 양방향
테이블
* 외래 키 하나로 양쪽 조인 가능
* 사실 방향이라는 개념이 없음

객체
* 참조용 필드가 있는 쪽으로만 참조 가능
* 한쪽만 참조하면 단방향
* 양쪽이 서로 참조하면 양방향

### 연관관계의 주인
* 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
* 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데
* 객체 양방향 관계는 참조가 2군데 있음. 둘 중 테이블의 외래키를 관리할 곳을 지정해야 함
* 연관관계의 주인 : 외래 키를 관리하는 참조
* 주인의 반대편 : 값을 바꾼다고 외래 키에 영향을 주지 않음, 단순 조회만 가능

## 일대다
* 일대다 단방향은 일 측이 관계의 주인이다
* 테이블에서는 그대로 다 쪽에 외래 키가 있다
* 객체설계하다 보면 나올 수 있는 모델
* @JoinColumn("테이블ID") 을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용한다
    * 관계 테이블 추가 생성

단점
* 엔티티가 관리하는 외래 키가 다른 테이블에 있음
* 연관관계 관리를 위해 추가로 UPDATE SQL 실행

**일대다 단방행 매핑보다는 다대일 양방향 매핑을 사용하자!!**

## 일대일
* 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
* 외래 키에 데이터베이스 유니크 제약조건 추가
* @OneToOne 사용, 반대쪽에는 mappedby 

### 외래 키 결정
* 주 테이블에 외래 키
    * 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
    * 객체지향 개발자 선호
    * JPA 매핑 관리
    * 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
    * 단점 : 값이 없으면 외래 키에 null 허용
* 대상 테이블에 외래 키
    * 대상 테이블에 외래 키가 존재
    * 전통적인 데이터베이스 개발자 선호
    * 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
    * 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨


## 다대다
* @ManyToMany
* 중간에 테이블 하나 생성
* 편리해 보이지만 실무에서 사용하지 않는다
* 연결 테이블이 단순히 연결만 하고 끝나지 않는다
* 주문시간, 수량 같은 데이터가 들어올 수 있다
* 그래서 그냥 연결 테이블을 Entity 로 승격시켜서 사용한다

## 어노테이션 주요 속성
@JoinColumn
* 외래 키를 매핑할 때 사용
* 속성
    * name : 매핑할 외래 키 이름
    * referencedColumnName : 외래 키가 참조하는 대상 테이블의 칼럼명
* Column 이랑 비슷?

@ManyToOne
* 다대일 관계 매핑
* optional : false 로 설정하면 엔티티가 항상 있어야 함
* fetch : 글로벌 패치 전략을 설정
* cascade : 영속성 전이 기능을 사용

@OneToMany
* 일대다 관계 매핑
* mappedBy : 연관관계의 주인 필드를 선택
* fetch : 글로벌 페치 전략을 설정
* cascade : 영속성 전이 기능을 사용

# 상속 관계 매핑
* 관계형 데이터베이스는 상속 관계가 없다
* 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다
* 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
    * DB에서 각각 테이블로 변환
    * 통합 테이블로 변환 -> 단일 테이블 전략
    * 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략
    * 이 3가지 중 어떤 방식으로 구현하더라도 JPA 에서 매핑이 가능하다

## 주요 어노테이션 
* @Inheritance(strategy=InheritanceType.XXX)
    * JOINED : 조인 전략
    * SINGLE_TABLE : 단일 테이블 전략
    * TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
* @DiscriminatorColumn(name="DTYPE")
    * 타입을 나타내는 칼럼을 지정
    * 막 user_type 0, 1, 2  0은 애플, 1은 구글 같은 것
    * Join 전략에서 이 칼럼을 사용하면 해당 칼럼이 생성된다
* @DiscriminatorValue("XXX")

## 장단점
조인 전략
* 장점
    * 정규화도 되어있다
    * 외래 키 참조 무결성 제약조건도 걸 수 있다
    * 저장공간 효율화
* 단점 
    * 조회시 조인을 많이 사용, 성능 저하
    * 조회 쿼리가 복잡함
    * 데이터 저장 시 Insert SQL 2번 호출

단일 테이블 전략
* 장점
    * 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다
    * 조회 쿼리가 단순하다
* 단점
    * 자식 엔티티가 매핑한 칼럼은 모두 null 허용
    * 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서는 조회 성능이 오히려 느려질 수 있다

구현 클래스마다 테이블 전략
* 쓰지마라


## @MappedSuperclass
* 공통 매핑 정보가 필요할 때 사용(id, name 등)
* DB에는 따로 들어간다, 객체에만 따로 BaseClass를 둔다
    * 상속받으면 된다
    * 편하다
* entity 도 아니고 상속관계 매핑도 아니다
* 추상 클래스 권장


# 프록시와 연관관계 관리
## 프록시
비즈니스적으로 연관관계에 있는 데이터가 필요 없는 경우 어떻게 할까?

em.find() vs em.getReference()
* em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
* em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
    * getReference 는 호출되는 시점이 아닌 실제 사용되는 시점에서 DB에서 데이터를 가져온다
    * Entity target = null 을 가지고 있는 빈 객체를 반환해 준다
    * 이 빈 객체를 프록시 라고 한다

## 프록시 특징
* 실제 클래스를 상속 받아서 만들어짐
* 실제 클래스와 겉 모양이 같다
* 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다(이론상)    
* 프록시 객체는 실제 객체의 참조를 보관한다
* 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다

### 프록시 객체의 초기화
1. entityManager.getReference(*.class, "**"); 을 통해 프록시 생성
2. entity 값 호출
3. 영속성 컨텍스트에 초기화 요청
4. 영속성 컨텍스트가 DB 조회
5. 실제 Entity 생성
6. entity 의 값 조회

* 프록시 객체는 처음 사용할 때 한 번만 초기화
* 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
* 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(== 비교실패, 대신 instance of 사용)
    * 프록시를 사용할지 모르니 jpa 에서 타입비교할때는 instance of 를 사용하는 것이 좋다
* 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference() 를 호출해도 실제 엔티티 반환
    * 반대로 이미 getReference() 를 사용했다면 find() 를 호출해도 reference 를 반환한다! 
    * 객체끼리 == 비교 가능
* 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생 
    * 영속성 컨텍스트가 DB에서 값을 가져오는 역할을 담당하기 때문에, 영속성 컨텍스트에 프록시가 들어가있지 않다면 초기화해서 db에서 값을 가져올 수 없다
    * 실무에서 Transaction 끝나고 나서 프록시 조회하는 등에서 문제가 많이 생김
    * org.hibernate.LazyInitializationException 예외 발생


## 프록시 확인
프록시 인스턴스의 초기화 여부 확인
* PersistenceUnitUtil.isLoaded(Object entity)

프록시 클래스 확인 방법
* entity.getClass().getName() 출력

프록시 강제 초기화
* org.hibernate.Hibernate.initialize(entity);


## 즉시 로딩과 지연 로딩
@ManyToOne(fetch = FetchType.LAZY) 
* 얘를 프록시 객체로 조회한다

지연 로딩하지 않으면 즉시 로딩

## 프록시와 즉시로딩 주의
* 모든 연관관계에 지연 로딩을 사용햐러
    * 특히 실무에서
* 즉시 로딩을 적용하면 예상하지 못한 SQL 이 발생한다
* 즉시 로딩은 JPQL 에서 N + 1 문제를 일으킨다
* @ManyToOne, @OntToOne 은 기본이 즉시 로딩이다
    * LAZY 로 설정해라
* JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라
* 즉시 로딩은 상상하지 못한 쿼리가 나간다

## CASCADE
@OneToMany(mappedBy="parent", cascade=CascaderType.ALL)

자신과 연관관계에 있는 애들 전부 한꺼번에 영속성 컨텍스트에 넣어준다.

영속성 전이는 연관관계를 매핑하는 것과 아무 관련이 없다

엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함을 제공한다.

한 엔티티에서 다른 엔티티를 모두 관리할 경우 사용하면 좋다.  
parent - child
* 라이프사이클 똑같거나
* 단일 소유자거나


### CASCADE 종류
* ALL : 모두 적용
* PERSIST : 영속
    * 저장할때만 같이
* REMOVE : 삭제
* MERGE : 병합
* REFRESH : REFRESH
* DETACH : DETACH

## 고아 객체
고아 객체 제거
* 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제

@OneToMany(orphanRemoval=true)

Parnet parent = em.find(Parent.class, id);
parent.getChildren().remove(0);
* DELETE FROM CHILD WHERE ID=? 와 같은 역할을 한다

### 고아 객체 - 주의
* 참조가 제거된 엔티티는 다른 곳에서 참조하지 않는 고아 객체로 보고 삭제하는 기능
* 참조하는 곳이 하나일 때 사용해야 함
* 특정 엔티티가 개인 소유할 때 사용
* @OneToOne, @OneToMany 만 가능
* 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화하면, 부모를 제거할 때 자식도 함께 제거된다. 이것은 CascaseType.REMOVE 처럼 동작한다.

## 영속성 전이 + 고아 객체, 생명주기
@OneToMany(mappedBy="", cascade=CascadeType.ALL, orphanRemoval=true)

스스로 생명주기를 관리하는 엔티티는 em.persis()로 영속화, em.remove() 로 제거가 가능하다.

두 옵션을 모두 활성화 하면 부모 엔티티를 통해서 자식의 생명 주기를 관리할 수 있다

도메인 주도 설게(DDD)의 Aggregate Root 개념을 구현할 때 유용하다.

# 값 타입

## 기본 값 타입
### JPA 의 데이터 타입 분류
엔티티 타입
* @Entity로 정의하는 객체
* 데이터가 변해도 식별자로 지속해서 추적 가능

값 타입
* int, integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체
* 식별자가 없고 값만 있으므로 변경시 추적 불가

### 값 타입
* 기본값 타입
    * 자바 기본 타입(int, double)
    * 래퍼 클래스(Integer, Long)
    * String
* 임베디드 타입
* 컬렉션 값 타입

* 기본 값 타입은 생명주기를 엔티티에 의존해야 한다
* 값 타입은 공유하면 안된다
* 래퍼 클래스 타입은 공유 가능한 객체지만 변경불가능하기 때문에 괜찮다

## 임베디드 타입
* 새로운 값 타입을 직접 정의할 수 있음
* JPA는 임베디드 타입이라 한다
* 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 한다
* int, String 과 같은 값 타입
* 클래스 하나 만드는 것, Pair 같은 거
* 임베디드 타입이 내부적으로 Entity 를 가질 수 있다

### 임베디드 타입 사용법
* @Embeddable : 값 타입을 정의하는 곳에 표시(객체 위)
* @Embedded : 값 타입을 사용하는 곳에 표시(사용하는 값 위)
* 기본 생성자 필수
* 테이블은 그대로다
* 객체 매핑만 바꾸는 것

### 장점
* 재사용
* 높은 응집도
* Period.isWork() 처럼 해당 값 타입만 사용하는 의미 있는 메소드를 만들 수 있음
* 임베디드 타입을 포함한 모든 값 타입은, 값 타입을 소유한 엔티티에 생명주기를 의존함


### @AttributeOverride: 속성 재정의
* 한 엔티티에서 같은 값 타입을 사용하는 경우 
* 해당 어노테이션을 사용하여 직접 칼럼을 지정함으로써 사용 가능

## 값 타입과 불변 객체
### 값 타입 공유 참조
* 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함
* 부작용(side effect) 발생
* 그래서 clone 해서 사용해야 함
* 근데 clone 아니면 사용하지 못하도록 막을 방법은 없다

### 불변 객체
* 객체 타입을 수정할 수 없게 만들면 부작용을 원천 차단가능하다
* 값 타입은 불변 객체로 설계해야 한다
* 생성자로만 값을 설정하고 수정자(Setter)를 만들지 않으면 된다
* 불변이라는 작은 제약으로 부작용이라는 큰 제약을 막을 수 있다

## 값 타입의 비교
값 타입 : 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 한다

그래서 equals 재정의해야 함

hashcode 도 재정의해줘야 함

## 값 타입 컬렉션
* 값 타입을 하나 이상 저장할 때 사용
* @ElementCollection, @CollectionTable(name="") 을 사용한다
* 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다
* 컬렉션을 저장하기 위한 별도의 테이블이 필요하다
* 값 타입 컬렉션도 지연 로딩 전략 사용
* 참고로 컬렉션은 내부적으로 equals 로 remove 를 사용하기 때문에 equals를 제대로 정의해야 한다

### 값 타입 컬렉션 제약사항
* 값 타입은 엔티티와 다르게 식별자 개념이 없다
* 값은 변경하면 추적이 어렵다
* 값 타입 컬렉션에 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 값을 모두 다시 저장한다
* 값 타입 컬렉션을 매핑하는 테이블은 모든 칼럼을 묶어서 기본키를 구성해야 한다
    * null 입력x, 중복 저장x
* 결론은 값 타입 컬렉션을 사용하지 않는 것이 좋다
* 정말 단순한 경우만 사용하자
    * update 할 필요도 없을 때

### 값 타입 컬렉션 대안
* 실무에서는 상황에 따라 값 타입 컬렉션 대신에 일 대 다 관계를 고려하는 것이 좋다
* 일대다 관계를 위한 


# 객체지향 쿼리 언어
* JPQ 를 사용하면 엔티티 객체를 중심으로 개발
* 검색을 할 때도 테이블이 아닌 엔티티 객체를 대상으로 검색
* 모든 DB 데이터를 객체로 변환해서 검색하는 것은 불가능하다
* 애플리케이션이 필요한 데이터만 DB에서 불러오려면 결국 검색 조건이 포함된 SQL이 필요하다

## JPQL 
* JPA 는 SQL 을 추상화한 JPQL 이라는 객체 지향 쿼리 언어 제공한다
* SQL 문법과 유사하게 select, group by 등 지원
* JPQL 은 엔티티 객체를 대상으로 쿼리
* SQL 은 데이터베이스 테이블을 대상으로 쿼리
* SQL 을 추상화해서 특정 데이터베이스 SQL에 의존하지 않는다
* 동적 쿼리 짜기 어렵다

## Criteria 
* 자바로 JPQL을 작성할 수 있다
* 사실 안씀
* QueryDSL 사용 권장

## JPQL 문법
* 엔티티와 속성은 대소문자를 구분ㅇ
* JPQL 키워드는 대소문자를 구분x
* 테이블이 아닌 엔티티 이름을 사용한다
* 별칭은 필수(ex Member as m)
* 집합(sum, avg), 정렬 전부 지원

### TypeQuery, Query
* TypeQuery: 반환 타입이 명확할 때 사용
* Query: 반환 타입이 명확하지 않을 때 사용
    
    TypedQuery<> query = em.createQuery("SELECT m FROM MEMBER m", Member.class);

    Query query = em.createQuery("select m.username, m.age from member m");

### 결과 조회 API
* query.getResultList() : 결과가 하나 이상일 때, 리스트 반환
    * 없으면 빈 리스트
* query.getSingleResult() : 결과가 정확히 하나, 단일 객체 반환
    * 하나 아니면 예외

### 파라미터 바인딩
* select u from user u where u.id=:id
* query.setParameter("id", userId); 

### 프로젝션
* SELECT 절에 조회할 대상을 지정하는 것
* 프로젝션 대상: 엔티티, 임베디드 타입, 스칼라 타입
* 여러 값을 반환할 경우 DTO 를 만들어 해주는 것이 좋다
* select new 패키지이름.MemberDTO(m.username, m.age) from m
    * 물론 순서와 타입이 일치하는 생성자 있어야 함
    * 패키지 이름까지 다 적어야 함

## 페이징 API
* JPA는 페이징을 다음 두 API로 추상화
* setFirstResult(int startPosition) : 조회 시작 위치
* setMaxResults(int maxResult) : 조회할 데이터 수

## 조인
* 연관관계가 없어도 left join 하고 싶으면 똑같이 on 사용하면 됨

## 서브쿼리


## JPA 서브 쿼리 한계
* JPA는 WHERE, HAVING 절에서만 서브 쿼리 사용 가능
* SELECT 절도 가능(Hibernate 에서 지원)
* FROM 절의 서브 쿼리는 현재 JPQL 에서 불가능
    * 조인으로 풀 수 있으면 해결

## JPQL 타입 표현
* 문자 : 'asd'
* 숫자 : 1, 2, 3L 
* 열거형 : 패키지명.MemberType
* 엔티티 타입 : TYPE(m) = Member(상속 관계에서 사용)
    * 이런식으로 상속관계일 때 타입 으로 조회 가능

## 조건식 - CASE 식
* select case when then when then else
* COALESCE : 하나씩 조회해서 null이 아니면 반환
    * SELECT coalesce(m.username, 'asd') from Member m
    * null 이면 'asd' 가 반환
* NULLIF : 두 값이 같으면 null 반환, 다르면 첫번째 값 반환
    * SELECT NULLIF(m.username, 'asd') from member m
    * username 이 'asd' 면 null 반환

## 경로표현식   

### 경로표현식 용어 정리
* 상태 필드
    * 단순히 값을 저장하기 위한 필드
* 연관 필드
    * 연관관계를 위한 필드 
    * 단일 값 연관 필드
        * ManyToOne, OneToOne
    * 컬렉션 값 연관 필드
        * OneToMany, ManyToMany

## 경로표현식 특징
* 상태 필드 : 경로 탐색의 끝, 더 이상 탐색 안됨
* 단일 값 연관 경로 : 묵시적 내부 조인 발생, 탐색 된다
    * 묵시적이 되도록 하면 튜닝하기 힘들다, 쓰지 말자
* 컬렉션 값 연관 경로 : 묵시적 내부 조인 발생, 탐색 안됨
    * FROM 절에서 명시적 조인을 통해 별칭을 얻으면 별칭을 통해 탐색 가능 
    * select m from team t join t.members m
* 그냥 묵시적 조인을 사용하지 말고 명시적 조인을 사용하자
    * 튜닝하기 힘들다

## 페치 조인(fetch join)
* SQL 조인 종류X
* JPQL 에서 성능 최적화를 위해 제공하는 기능
* 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
* join fetch 명령어 사용
* 페치 조인 ::= [LEFT[ OUTER ] | INNER ] JOIN FETCH 조인 경로

### 엔티티 페치 조인
* 회원을 조회하며 연관된 팀도 함께 조회(SQL 한 번에)
* SQL을 보면 회원 뿐만 아니라 팀도 함께 SELECT
* JPQL
    * select m from Member m join fetch m.team
* SQL
    * SELECT M.*, T.* FROM MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID
* 이렇게 처음부터 join 으로 데이터를 가져올 수 있다

### 컬렉션 페치 조인
* 일대다 관계, 컬렉션 페치 조인
* JPQL
    * select t from Team t join fetch t.members where t.name='팀A'
* SQL
    * SELECT T.*, M.* FROM TEAM T INNER JOIN MEMBER M ON T.ID=M.TEAM_ID WHERE T.NAME = '팀A'
* 일대다 조회의 경우 결과가 중복될 수 있다 -> DISTINCT 사용

### 페치 조인과 DISTINCT
* SQL 의 DISTINCT 는 중복된 결과를 제거하는 명령
* JPQL의 DISTINCT 2가지 기능 제공
    * SQL에 DISTINCT 를 추가
        * DISTINCT 만으로 데이터가 줄지는 않을 수 있다
    * 애플리케이션에서 엔티티 중복 제거
        * 같은 식별자를 가진 Team 엔티티를 제거한다

### 페치 조인과 일반 조인의 차이
* 일반 조인 실행시 연관된 엔티티를 함께 조회하지 않음
* 지연으로 나중에 다시 일일히 가지고 와야 한다
* 페치 조인은 필요한 것을 한 SQL에 가져오는 과정

### 페치 조인의 특징과 한계
* 페치 조인 대상에는 별칭을 줄 수 없다
    * 하이버네이트는 가능, 가급적 사용X
* 둘 이상의 컬렉션은 페치 조인 할 수 없다
    * 페치 조인한 테이블에서 페치 조인 또 타고 들어갈 수 없음
* 컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다
    * 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
    * 하이버네이트는 경로 로그를 남기고 메모리에서 페이징(매우 위험)
    * 일대다를 다대일 방향으로 바꿔서 페이징하던가 하면 됨
* batch fetch size 를 사용하면 쿼리를 조회하는 테이블 수만큼만 날림
    * 어노테이션 사용해도 되고, 글로벌 셋팅도 가능

* 연관된 엔티티들을 SQL 한 번으로 조회 - 성능 최적화
* 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
    * FetchType.LAZY 같은 것
* 실무에서 글로벌 로딩 전략은 모두 지연 로딩
* 최적화가 필요한 곳은 페치 조인 적용

## 페치 조인 - 정리
* 모든 것을 페치 조인으로 해결할 수 는 없음
* 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적
* 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인보다는 일반 조인을 사용하고 필요한 데이터들만 조회해서 DTO 로 반환하는 것이 효과적

## Named 쿼리
* 미리 정의해서 이름을 부여해두고 사용하는 JPQL
* 정적 쿼리만 가능
* 어노테이션, XML 에 정의
* 애플리케이션 로딩 시점에 초기화 후 재사용
    * SQL로 미리 캐싱하고 있다
* 애플리케이션 로딩 시점에 쿼리를 검증
    
## 벌크 연산
* 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?
* JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행
* 쿼리 한번으로 한꺼번에 하게 해주는 것이 벌크 연산
* .executeUpdate(), .executeDelete()

### 벌크 연산 주의
* 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다
    * 벌크 연산을 먼저 실행하고 영속성 컨텍스트에서 작업을 하던가
    * 벌크 연산 수행 후 영속성 컨텍스트를 초기화하던가
    * 참고로 벌크 연산은 flush() 후에 실행된다, 근데 이게 영속성 컨텍스트에 반영되지는 않는다

## 영속성 컨텍스트와 JPQL
JPQL 로 엔티티를 조회할 경우 영속성 컨텍스트에서 관리되지만 엔티티가 아니면 영속성 컨텍스트에서 관리되지 않는다.

# 추가

## @Where
테이블에 ``@Where`` 어노테이션을 추가하면 일괄적인 Where 조건이 적용된다.

```
@Entity
@Where(clause = "column_name=condition")
public Entity{
}
```

엔티티에 해당 어노테이션을 붙이면 

해당 엔티티를 조회하는 모든 쿼리에 설정한 where 문이 붙게 된다.

Lazy Loading을 하는 경우에도 해당 Where 문이 적용되게 된다.

