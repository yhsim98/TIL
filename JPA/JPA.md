http://www.yes24.com/Product/Goods/19040233

1. SQL 중심적인 개발의 문제점
2. JPA 
3. 영속성 컨텍스트
4. 엔티티 매핑
5. 연관관계 매핑 기초
6. 상속 관계 매핑
7. 프록시와 연관관계 관리


# SQL 중심적인 개발의 문제점

## SQL에 의존적인 개발을 피하기 어렵다
중간에 domain 에 변경이 있으면 관계된 모든 sql을 일일히 수정해야 한다.

번거롭고 특정 sql을 실수로 수정하지 않는 등 실수의 여지가 많다

## 패러다임의 불일치
* 객체와 관계형 데이터베이스의 차이

1. 상속
2. 연관관계
3. 데이터 타입
4. 데이터 식별 방법

등에서 여러가지로 힘들어진다.

객체지향적으로 개발할수록 매핑이 힘들어지는 문제가 생긴다.
그래서 대안으로 나온 것 이 JPA

# JPA(Java-Persistent-Api)
JPA는 ORM 기술이다

ORM(Objective-relational mapping)
* 객체는 객체대로, 관계형 db는 관계형 db대로 설계
* ORM 프레임워크가 중간에서 매핑

JPA는 Java 애플리케이션과 JDBC 사이에서 동작한다. DB에서 JDBC 가 받으면 그것을 JPA가 매핑하고, 애플리케이션에서 JPA로 보내면 JPA가 JDBC에 매핑한다.

## JPA 장점
생산성
* CRUD 쿼리가 이미 존재한다

유지보수
* 기존 필드 변경시 SQL은 자동으로 JPA가 처리

패러다임 불일치 해결
* 상속 등 자동으로 처리해준다

신뢰할 수 있는 엔티티, 계층
* 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장한다
    * user1 == user2 보장


## JPA의 성능 최적화 기능
1. 1차 캐시와 동일성 보장
* 엔티티 매니저 안에서 캐시 기능 지원
* 같은 트랜잭션 안에서는 같은 엔티티를 반환 - 약간의 조회 성능 향상 

2. 트랜잭션을 지원하는 쓰기 지연
* 트랜잭션을 커밋할 때까지 비슷한 SQL을 모은다
* JDBC BATCH SQL 기능을 사용해서 한번에 SQL 전송한다

3. 지연 로딩
    
지연 로딩
* 객체가 실제 사용될 때 로딩

즉시로딩 
* JOIN SQL 로 한번에 연관된 객체까지 미리 조회

## JPQL
JPA 가 제공하는 SQL 을 추상화한 객체 지향 쿼리 언어

SELECT, GROUP BY, HAVING, JOIN 등을 지원한다

엔티티 객체를 대상으로 쿼리

## 엔티티 매니저 팩토리와 엔티티 매니저
EntityManagerFactory 라는 클래스가 요청이 올 때마다 EntityManager을 생성, EntityManager 는 DB 커넥션을 사용하여 DB를 사용한다.

# 영속성 컨텍스트
엔티티를 영구 저장하는 환경이라는 뜻

EntitiyManager.persist(entity) 라고 하면 엔티티를 db가 아닌 영속성 컨택스트라는 곳에 저장한다.

## 엔티티의 생명주기
비영속
* 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
* 객체를 생성하기만 한 상태

영속
* 영속성 컨텍스트에 관리되는 상태 
* 엔티티메니저에 persist 해서 객체를 넣은 상태
* 바로 db에 날라가는 것이 아님

준영속
* 영속성 컨텍스트에 저장되었다가 분리된 상태 
* detach 

삭제
* 삭제된 상태


## 영속성 컨텍스트의 이점
* 1차 캐시
    * 바로 DB 에 가는 것이 아닌 캐시를 먼저 조회한다
    * 캐시에 없다면 DB 를 조회한 후 캐시에 저장한다
    * 트랜잭션 단위로 작동하고 트랜잭션이 끝나면 영속성 컨텍스트도 종료하기 때문에 사실 별로 도움이 안된다

* 동일성 보장
    * == 비교하면 같다

* 트랜잭션을 지원하는 쓰기 지연
    * insert 문을 모았다가 커밋 시점에 한번에 보낸다
    * batch 옵션이다

* 변경 감지(Dirty checking)
    * 엔티티메니저에 객체를 넣고 나면 객체를 변경하기만 해도 DB까지 자동으로 변경됨

* 지연 로딩


## 플러시
영속성 컨텍스트의 변경내용을 데이터베이스에 반영

영속성 컨텍스트를 비우지 않는다

영속성 컨텍스트의 변경내용을 데이터베이스에 동기화

트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 된다

플러시 발생
* 변경 감지
* 수정된 엔티티 쓰기 지연 SQL 저장소에 등록
* 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)

영속성 컨텍스트를 플러시하는 방법
* em.flush() - 직접 호출
* 트랜잭션 커밋 - 플러시 자동 호출
* JPQL 쿼리 실행 - 플러시 자동 호출


## 준영속
객체를 더 이상 영속성 컨텍스트에서 관리하지 않는 상태.

detach, clear, close 로 준영속 상태로 만들 수 있다.


# 엔티티 매핑

## 객체와 테이블 매핑
@Entity
* JPA 가 관리하는 엔티티
* JPA 를 사용해서 테이블과 매핑할 클래스는 @Entity 필수이다.
* 주의
    * 기본 생성자 필수
    * final 클래스, enum, interface, inner 클래스 사용 X
    * 저장할 필드에 final 사용 X 

@Entity 속성
* name
    * JPA 에서 사용할 엔티티 이름 지정
* Table(name="")
    * 매핑할 테이블 지정



### 데이터베이스 스키마 자동 생성
옵션에 따라 테이블 자동으로 변경 가능하다

entity 를 수정하면 그에 맞춰 테이블을 자동으로 수정해준다.


## 필드와 컬럼 매핑

java 타입과 컬럼 타입
* 기본 자료형은 자동으로 매핑된다
* Enum 타입 등은 
    * @Enumerated(EnumType.STRING) : enum 이름으로 매핑
    * @Enumerated(EnumType.STRING) : enum 순서로 매핑
    * 순서는 바뀔 수 있기 때문에 이름으로 매핑하는 것을 권장한다
* 날짜 타입은 @Temporal(TemporalType.TIMESTAMP), timestamp, date, 등 세가지가 있다
    * java 8 이후로는 Tiemstamp, DateTime 등을 지원하기 때문에 쓸 일이 없다
* @Lob 은 큰 컨텐츠에 사용

@Column(name="", nullable=false/true, unique=true/false)


## 기본키 매핑
직접할당은 @Id, 자동할당은 추가로 @GeneratedValue

@GeneratedVlaue(strategy = GenerationType.{})
* 자동할당 전략을 선택 가능하다
* GenerationType.IDENTITY
    * mySql 의 auto_inclement
* GenerationType.SEQUENCE
    * 
* 여러가지 있다, IDENTITY 권장

@SequenceGenerator
* allocation size 를 이용하여 미리 여러 로를 할당하는 방식으로 insert 문이 여러 번 네트워크를 타지 않도록 할 수 있다
    * 성능최적화
    * 동시성문제도 없다
* 

IDENTITY 의 경우 DB에 insert 되야지만 ID 값을 알 수 있다. 그래서 커밋하는 시점이 아닌 영속성 컨텍스트에 들어가는 즉시 db에 insert 문을 바로 보내도록 한다.

한번에 50개씩 할당하여 사용하는 방식으로 최적화 가능하다 

## 데이터 중심 설계의 문제점
객체를 설계할 때 memberId, orderId 등 관계를 나타내는 id 를 가지고 있는 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식

테이블의 외래키를 객체에 그대로 가져온다

객체 그래프 탐색이 불가능해진다

참조가 없으므로 UML도 잘못된다.


# 연관관계 매핑 기초
## 단방향 연관관계
@ManyToOne
* 1 대 n 관계라고 jpa 에 알려주는 어노테이션

@JoinColumn(name="FK")
* 조인해야 하는 컬럼을 가리킴

ex)
Team 
@ManyToOne
@JoinColumn(name="USER_ID")
private Long userId;


## 양방향 연관관계
DB에서는 두 테이블 중 하나에만 FK 가 있으면 양쪽 다 접근 가능하다.

하지만 객체에서는 양쪽 다 서로를 참조해야 양방향으로 접근이 가능하다

    ex)
    Member Long id, Team team
    Team    Long id

    Team 에서 Member로 접근 불가

    -->

    Member Long id, Team team
    Team    Long id, List<Member> members

    양방향 접근 가능

@OneToMany(mappedBy="team")  
* List 에 어노테이션을 붙임으로서 연관관계를 알릴 수 있다


## 연관관계의 주인과 mappedBy
객체의 양방향 관계는 사실 양방향 관계가 아닌 서로 다른 단방향 관계 2개

객체를 양방향으로 참조하려면 단방향 연관관계를 2개 만들어야 한다.

객체에서는 단방향 연관관계가 2개이지만, RDB에서는 양방향 연관관계 하나가 존재한다. 따라서 객체의 어떤 단방향 연관관계가 RDB의 연관관계와 매핑될 것인지 결정해야 한다.

이것을 연관관계의 주인이라 한다.

### mappedBy
@OneToMany 를 mappedBy 없이 사용하게 되면 두 테이블의 관계 테이블을 생성하게 된다. 왜냐하면 1 대 다 관계에서 1 측 테이블은 외래키를 가지지 않는다. 따라서 1측에서 다 측으로 가기 위해서는 관계 테이블이 필요하기 때문이다.

1:n 단방향 관계에서 1이 관계의 주인이라면 @JoinColumn 을 사용해주면 된다.

참고로 @ManyToOne 은 테이블의 fk 를 가지고 다른 테이블을 찾아가면 되므로 관계 테이블을 만들 지 않는다. 

mappedBy 를 사용해 관계의 주인을 명시함으로써 관계 테이블이 생성되지 않고 관계의 수정 또한 관계의 주인을 통해서만 가능하게 할 수 있다.  

### 연관관계의 주인(Owner)
* 객체의 두 관계중 하나를 연관관계의 주인으로 지정한다
* 연관관계의 주인만이 외래 키를 관리한다(등록, 수정)
* 주인이 아닌쪽은 읽기만 가능하다
* 주인은 mappedBy 속성을 사용하지 않는다
* 주인이 아니면 mappedBy 속성으로 주인을 지정한다

* 외래 키가 있는 곳을 주인으로 정해라!!
    * 성능이슈나 여러 가지 문제를 해결가능

## 양방향 매핑시 가장 많이하는 실수
1. 순수한 객체 관계를 고려하면 항상 양쪽 다 값을 입력해야 한다.
    * 사실 주인쪽에만 관계를 넣어도 테이블에는 들어간다.
        * 참고로 주인이 아니면 관계를 추가하더라도 테이블에 들어가지 않는다.
    * 양방향 매핑시 연관관계의 주인에 값을 입력해야 한다.
    * 연관관계 편의 메소드를 만들자
    * 함수 하나로 둘 다 세팅할 수 있도록 set 메서드를 따로 만들자
2. 양방향 매핑시에 무한 루프를 조심하자
    * toString(), lombok, JSON 생성 라이브러리 등
    * 자동 생성을 사용하면 서로의 toString 을 호출하며 무한 루프에 빠진다
    * lombok 에서 toString 은 사용하지 말고, JSON 생성의 경우는 Controller 에서 Entity를 절대 반환하지 않으면 됨

## 양방향 매핑 정리
* 단방향 매핑만으로 이미 연관관계 매핑은 완료
* 양방향 매핑은 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐
* JPQL 에서 역방향으로 탐색할 일이 많음
* 단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨(테이블에 영향을 주지 않음)

## 연관관계의 주인을 정하는 기준
* 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안됨
* 연관관계의 주인은 외래 키의 위치를 기준으로 정해야 함

# 다양한 연관관계 매핑
## 연관관계 매핑시 고려사항
1. 다중성
2. 단방향, 양방향
3. 연관관계의 주인

### 다중성
* n : 1 : @ManyToOne
* 1 : n : @OneToMany
* 1 : 1 : @OneToOne
* n : M : @ManyToMany
    * 실무에서 쓰면 안됨

### 단방향, 양방향
테이블
* 외래 키 하나로 양쪽 조인 가능
* 사실 방향이라는 개념이 없음

객체
* 참조용 필드가 있는 쪽으로만 참조 가능
* 한쪽만 참조하면 단방향
* 양쪽이 서로 참조하면 양방향

### 연관관계의 주인
* 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
* 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데
* 객체 양방향 관계는 참조가 2군데 있음. 둘 중 테이블의 외래키를 관리할 곳을 지정해야 함
* 연관관계의 주인 : 외래 키를 관리하는 참조
* 주인의 반대편 : 값을 바꾼다고 외래 키에 영향을 주지 않음, 단순 조회만 가능

## 일대다
* 일대다 단방향은 일 측이 관계의 주인이다
* 테이블에서는 그대로 다 쪽에 외래 키가 있다
* 객체설계하다 보면 나올 수 있는 모델
* @JoinColumn("테이블ID") 을 꼭 사용해야 한다. 그렇지 않으면 조인 테이블 방식을 사용한다
    * 관계 테이블 추가 생성

단점
* 엔티티가 관리하는 외래 키가 다른 테이블에 있음
* 연관관계 관리를 위해 추가로 UPDATE SQL 실행

**일대다 단방행 매핑보다는 다대일 양방향 매핑을 사용하자!!**

## 일대일
* 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
* 외래 키에 데이터베이스 유니크 제약조건 추가
* @OneToOne 사용, 반대쪽에는 mappedby 

### 외래 키 결정
* 주 테이블에 외래 키
    * 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
    * 객체지향 개발자 선호
    * JPA 매핑 관리
    * 장점 : 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
    * 단점 : 값이 없으면 외래 키에 null 허용
* 대상 테이블에 외래 키
    * 대상 테이블에 외래 키가 존재
    * 전통적인 데이터베이스 개발자 선호
    * 장점 : 주 테이블과 대상 테이블을 일대일에서 일대다 관계로 변경할 때 테이블 구조 유지
    * 단점 : 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨


## 다대다
* @ManyToMany
* 중간에 테이블 하나 생성
* 편리해 보이지만 실무에서 사용하지 않는다
* 연결 테이블이 단순히 연결만 하고 끝나지 않는다
* 주문시간, 수량 같은 데이터가 들어올 수 있다
* 그래서 그냥 연결 테이블을 Entity 로 승격시켜서 사용한다

## 어노테이션 주요 속성
@JoinColumn
* 외래 키를 매핑할 때 사용
* 속성
    * name : 매핑할 외래 키 이름
    * referencedColumnName : 외래 키가 참조하는 대상 테이블의 칼럼명
* Column 이랑 비슷?

@ManyToOne
* 다대일 관계 매핑
* optional : false 로 설정하면 엔티티가 항상 있어야 함
* fetch : 글로벌 패치 전략을 설정
* cascade : 영속성 전이 기능을 사용

@OneToMany
* 일대다 관계 매핑
* mappedBy : 연관관계의 주인 필드를 선택
* fetch : 글로벌 페치 전략을 설정
* cascade : 영속성 전이 기능을 사용

# 상속 관계 매핑
* 관계형 데이터베이스는 상속 관계가 없다
* 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사하다
* 상속관계 매핑 : 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑
    * DB에서 각각 테이블로 변환
    * 통합 테이블로 변환 -> 단일 테이블 전략
    * 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략
    * 이 3가지 중 어떤 방식으로 구현하더라도 JPA 에서 매핑이 가능하다

## 주요 어노테이션 
* @Inheritance(strategy=InheritanceType.XXX)
    * JOINED : 조인 전략
    * SINGLE_TABLE : 단일 테이블 전략
    * TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
* @DiscriminatorColumn(name="DTYPE")
    * 타입을 나타내는 칼럼을 지정
    * 막 user_type 0, 1, 2  0은 애플, 1은 구글 같은 것
    * Join 전략에서 이 칼럼을 사용하면 해당 칼럼이 생성된다
* @DiscriminatorValue("XXX")

## 장단점
조인 전략
* 장점
    * 정규화도 되어있다
    * 외래 키 참조 무결성 제약조건도 걸 수 있다
    * 저장공간 효율화
* 단점 
    * 조회시 조인을 많이 사용, 성능 저하
    * 조회 쿼리가 복잡함
    * 데이터 저장 시 Insert SQL 2번 호출

단일 테이블 전략
* 장점
    * 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다
    * 조회 쿼리가 단순하다
* 단점
    * 자식 엔티티가 매핑한 칼럼은 모두 null 허용
    * 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 상황에 따라서는 조회 성능이 오히려 느려질 수 있다

구현 클래스마다 테이블 전략
* 쓰지마라


## @MappedSuperclass
* 공통 매핑 정보가 필요할 때 사용(id, name 등)
* DB에는 따로 들어간다, 객체에만 따로 BaseClass를 둔다
    * 상속받으면 된다
    * 편하다
* entity 도 아니고 상속관계 매핑도 아니다
* 추상 클래스 권장


# 프록시와 연관관계 관리
## 프록시
비즈니스적으로 연관관계에 있는 데이터가 필요 없는 경우 어떻게 할까?

em.find() vs em.getReference()
* em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
* em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
    * getReference 는 호출되는 시점이 아닌 실제 사용되는 시점에서 DB에서 데이터를 가져온다
    * Entity target = null 을 가지고 있는 빈 객체를 반환해 준다
    * 이 빈 객체를 프록시 라고 한다

## 프록시 특징
* 실제 클래스를 상속 받아서 만들어짐
* 실제 클래스와 겉 모양이 같다
* 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다(이론상)    
* 프록시 객체는 실제 객체의 참조를 보관한다
* 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다

### 프록시 객체의 초기화
1. entityManager.getReference(*.class, "**"); 을 통해 프록시 생성
2. entity 값 호출
3. 영속성 컨텍스트에 초기화 요청
4. 영속성 컨텍스트가 DB 조회
5. 실제 Entity 생성
6. entity 의 값 조회

* 프록시 객체는 처음 사용할 때 한 번만 초기화
* 프록시 객체를 초기화 할 때, 프록시 객체가 실제 엔티티로 바뀌는 것은 아님, 초기화되면 프록시 객체를 통해서 실제 엔티티에 접근 가능
* 프록시 객체는 원본 엔티티를 상속받음, 따라서 타입 체크시 주의해야함(== 비교실패, 대신 instance of 사용)
    * 프록시를 사용할지 모르니 jpa 에서 타입비교할때는 instance of 를 사용하는 것이 좋다
* 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference() 를 호출해도 실제 엔티티 반환
    * 반대로 이미 getReference() 를 사용했다면 find() 를 호출해도 reference 를 반환한다! 
    * 객체끼리 == 비교 가능
* 영속성 컨텍스트의 도움을 받을 수 없는 준영속 상태일 때, 프록시를 초기화하면 문제 발생 
    * 영속성 컨텍스트가 DB에서 값을 가져오는 역할을 담당하기 때문에, 영속성 컨텍스트에 프록시가 들어가있지 않다면 초기화해서 db에서 값을 가져올 수 없다
    * 실무에서 Transaction 끝나고 나서 프록시 조회하는 등에서 문제가 많이 생김
    * org.hibernate.LazyInitializationException 예외 발생


## 프록시 확인
프록시 인스턴스의 초기화 여부 확인
* PersistenceUnitUtil.isLoaded(Object entity)

프록시 클래스 확인 방법
* entity.getClass().getName() 출력

프록시 강제 초기화
* org.hibernate.Hibernate.initialize(entity);


## 즉시 로딩과 지연 로딩
@ManyToOne(fetch = FetchType.LAZY) 
* 얘를 프록시 객체로 조회한다

지연 로딩하지 않으면 즉시 로딩

## 프록시와 즉시로딩 주의
* 모든 연관관계에 지연 로딩을 사용햐러
    * 특히 실무에서
* 즉시 로딩을 적용하면 예상하지 못한 SQL 이 발생한다
* 즉시 로딩은 JPQL 에서 N + 1 문제를 일으킨다
* @ManyToOne, @OntToOne 은 기본이 즉시 로딩이다
    * LAZY 로 설정해라
* JPQL fetch 조인이나, 엔티티 그래프 기능을 사용해라
* 즉시 로딩은 상상하지 못한 쿼리가 나간다
