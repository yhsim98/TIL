# Serverless

클라우드 제공업체가 클라우드 인프라와 애플리케이션 스케일링을 모두 관리

표준 서비스 인프라(laaS) 클라우드 컴퓨팅 모델에서 사용자는 용량 단위를 사전에 구매하게 된다.

상시 가동 중인 서버 구성 요소에 대한 비용을 지불하고, 수요가 많을 때 스케일 업이나 다운하는 것  역시 사용자의 책임. 애플리케이션을 구동하기 위해 필요한 클라우드 인프라는 애플리케이션이 사용되지 않을 때도 활성화된 상태이다.

반면, 서버리스 아키텍처에서는 애플리케이션이 필요한 경우에만 시작.

이벤트가 구동을 위한 애플리케이션 코드를 트리커하면 퍼블릭 클라우드 공급업체가 신속하게 해당 코드에 대한 리소스를 할당. 코드 실행이 종료되면 비용도 청구되지 않는다.

비용과 효율성 외에도, 서버리스는 애플리케이션 스케일링 및 서버 프로비저닝(과 같은 부분에서도 개발자의 부담을 덜어준다.

비동기식 stateless 애플리케이션에서 이상적

- 프로비저닝
    - 프로비저닝(provisioning)은 **사용자의 요구에 맞게 시스템 자원을 할당, 배치, 배포해 두었다가 필요 시 시스템을 즉시 사용할 수 있는 상태로 미리 준비해 두는 것을 말한다**
- Infrastructure as a Service(IaaS)
    - 클라우드 서비스의 종류
    - 개발사에 제공되는 물리적 자원을 가상화
    - 컴퓨팅 리소스를 가상화하여 제공하는 것
- Platform as a Service(PaaS)
    - 개발사에 제공되는 플랫폼을 가상화
- Software as a Service(SaaS)
    - 고객에게 제공되는 소프트웨어를 가상화
    - 인터넷을 통하여 응용프로그램 제공?

### 장점

- 서버리스 컴퓨팅은 개발자 생산성을 높이고 운영 비용을 줄일 수 있다.
- 인프라를 명시적으로 설명할 필요를 줄여줌으로써 DevOps 도입을 지원
- BaaS의 모든 구성 요소를 통합해 애플리케이션 개발을 간소화
- 항상 자체 서버를 실행하고 관리하는 대신 필요한 만큼 클라우드 기반 컴퓨팅 시간에 대해 비용을 지불

### 단점

- 자체 서버를 실행하지 않거나 자체 서버측 로직을 제어하지 않는 데 따른 단점
- 클라우드 제공업체는 자사 구성 요소가 상호작용하는 방법을 엄격히 제한할 수 있어, 사용자 시스템의 유연성과 커스터마이징 수준에 영향을 준다
- 특정 벤더에 종속성을 가진다

# Serverless Framework

- 개발, 배포, 트러블슈팅, 보안관리를 적은 비용으로 할 수 있도록 도와주는 프레임워크
- CLI와 hosted dashboard 로 구성되어 있으며, 이것을 통해 완전한 서버리스 애플리케이션 라이프사이클 관리를 제공해 준다
- 정리하자면, 환경을 배포하고 운영하기 위한 도구
- AWS 람다 사용하여 함수를 작성하고 환경 설정 등을 대신해 준다

## Get Started

- Node와 NPM이 설치되어 있어야 합니다
    - 해당 명령어를 통해 설치를 확인할 수 있습니다
    
    ```
    # 각 버젼 확인
    npm -v
    node -v
    ```
    
    - 없을 경우
        - [https://nodejs.org/ko/download/](https://nodejs.org/ko/download/)
        - 

```
# serverless 프레임워크 설치
sudo npm install -g serverless
```

```
# Create a new serverless project
serverless create --template aws-nodejs --path my-service

# Move into the newly created directory
cd your-service-name
```

- 위 명령어에서 template 이란 함수의 런타임을 말한다, 위에서는 aws-node 옵션을 통해 런타임을 node.js로 설정했다
- 생성된 serverless 프로젝트는 serverless.yml 파일을 포함하고 있다
- 이 파일은 AWS 에 어떤 것이 배포될 것인지 정의하는 설정파일
    - 함수나 이벤트 자원 등등

```
# Service name for use dashboard.serverless.com
service: serverlessNodeJS

# specific Serverless Framework version
frameworkVersion: '3'

# The cloud provider that we are going to use and the runtime environment.
provider:
  name: aws
  # Default stage (default: dev)
  stage: dev
  # Default region (default: us-east-1)
  region: us-east-1
  # The AWS profile to use to deploy (default: "default" profile)
  profile: production
  # Use a custom name for the CloudFormation stack
  stackName: custom-stack-name
  # Optional CloudFormation tags to apply to APIs and functions
  tags:
    foo: bar
    baz: qux
  # Optional CloudFormation tags to apply to the stack
  stackTags:
    key: value
  # Method used for CloudFormation deployments: 'changesets' or 'direct' (default: changesets)
  # See https://www.serverless.com/framework/docs/providers/aws/guide/deploying#deployment-method
  deploymentMethod: direct
  # List of existing Amazon SNS topics in the same region where notifications about stack events are sent.
  notificationArns:
    - 'arn:aws:sns:us-east-1:XXXXXX:mytopic'
  stackParameters:
    - ParameterKey: 'Keyname'
      ParameterValue: 'Value'
  # Disable automatic rollback by CloudFormation on failure. To be used for non-production environments.
  disableRollback: true
  rollbackConfiguration:
    MonitoringTimeInMinutes: 20
    RollbackTriggers:
      - Arn: arn:aws:cloudwatch:us-east-1:000000000000:alarm:health
        Type: AWS::CloudWatch::Alarm
      - Arn: arn:aws:cloudwatch:us-east-1:000000000000:alarm:latency
        Type: AWS::CloudWatch::Alarm
  tracing:
    # Can only be true if API Gateway is inside a stack.
    apiGateway: true
    # Optional, can be true (true equals 'Active'), 'Active' or 'PassThrough'
    lambda: true

functions:
  hello:
    handler: handler.hello
```

### Amazon API Gateway

[Amazon API Gateway](https://www.notion.so/Amazon-API-Gateway-16e002bdfe844affbfb8ad2b6b991c98)

### AWS Lambda

## node.js로 serverless 개발 시작하기

## java로 serverless 개발 시작하기

자바의 경우 따로 함수형 프로그래밍을 지원하지 않기 때문에 handler가 필요하다

그리고 요청이 일정기간 이상 없다면 초기화되버리기 때문에 첫 실행시 빌드해야 해 시간이 걸림