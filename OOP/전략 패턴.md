# 전략 패턴
알고리즘을 캡슐화해주고 실행시간에 선택

상속은 정적관계이다. 따라서 자식은 상속받을 메소드를 선택할 수 없다.

부모에 정의된 모든 메소드가 모든 자식에 적합하지 않을 수 있다.

## 해결법 1. 빈 메소드로 재정의한다
문제
1. 빈 메소드를 여러 번 만드는 것도 코드 중복사용
2. 사용자가 사전에 해당 메소드를 지원하는 지 알기 어렵다
3. 부모의 변화가 자식에게 의도치않은 영향을 줄 수 있다

## 해결법 2. 종류별로 클래스를 만들기
문제
1. 너무 많은 클래스가 생길 수 있다

## 해결법 3. 각 기능을 하는 interface 를 나눠 만들기
interface 을 이용하면 특정 기능을 제공하는 것과 제공하지 않는 것을 구분할 수 있다.

클래스에서 기능을 제외한 후 해당 기능을 하는 클래스들을 따로 만들기

문제
1. 코드 중복 문제가 존재한다
    * 인터페이스이니 같은 코드라도 구현하는 클래스에서 전부 구현해야 한다
    * 자바8의 default 메서드를 사용하더라도 여전히 동적 변화를 제공하기 힘들다
2. 다양한 조합 문제를 제공하기 어렵다

# 다양한 조합 문제
* 공통적으로 가진 기능이 있지만 이 기능이 다양하게 구현될 수 있다
* 다양하게 구현된 것들을 종종 실행시간에 바꾸어야 사용할 수 있다
* 이와 같은 기능이 여러 개 존재할 수 있다

# 관련 설계 원리
## 변하는 부분과 변하지 않는 부분을 분리해라
조합 문제의 해결책으로 상속은 좋은 해결책이 아니다.

interface 또한 구현을 포함하지 않기 때문에 좋은 해결책이 아니다

## 인터페이스를 통해 관계를 맺도록 해라
Has-a 관계와 의존관계 주입으로 구현

# 올바른 구현
1. 행동에 관한 인터페이스를 만든 후
2. 그것을 구현하는 각각의 클래스를 만든다
3. 필요로하는 각 클래스에 주입해준다

```
interface Fly{
    fly();
}

class FlyWithWings implements Fly{
    fly(){}
}

class FlyNoWay implements Fly{
    fly(){}
}

class RubberDuck{
    Fly fly = new FlyNoWay();
}

class GoldDuck{
    Fly fly = new FlyWithWings();
}
```
장점
* 코드 재사용이 가능해진다
    * 날개로 나는 모든 오리에 대한 구현은 한번
* 기존 클래스를 변경하지 않고 새 행위를 추가하기 쉽다
* 조건문을 사용하지 않고 구현이 가능하다



