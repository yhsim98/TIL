## ORM
객체와 데이터베이스 데이터를 자동으로 매핑해주는 기술입니다.

관계형 DB와 객체지향 사이의 패러다임 차이를 매꿔준다

장점
* sql 중심의 개발에서 벗어나, 객체지향적으로 개발 가능
* 재사용 및 유지보수 편리성 증가
* DBMS에 대한 종속성 감소

단점
* 완벽한 ORM 으로만 서비스를 구현하기 어렵습니다
* 설계하기 어렵고, 속도의 저하 


## 데이터 중심 설계의 문제점
객체를 설계할 때 memberId, orderId 등 관계를 나타내는 id 를 가지고 있는 현재 방식은 객체 설계를 테이블 설계에 맞춘 방식

테이블의 외래키를 객체에 그대로 가져온다

객체 그래프 탐색이 불가능해진다

참조가 없으므로 UML도 잘못된다.

## JPA(Java-Persistent-Api)
JPA는 ORM 기술이다

ORM(Objective-relational mapping)
* 객체는 객체대로, 관계형 db는 관계형 db대로 설계
* ORM 프레임워크가 중간에서 매핑

JPA는 Java 애플리케이션과 JDBC 사이에서 동작한다. DB에서 JDBC 가 받으면 그것을 JPA가 매핑하고, 애플리케이션에서 JPA로 보내면 JPA가 JDBC에 매핑한다.

## JPA 장점
생산성
* CRUD 쿼리가 이미 존재한다

유지보수
* 기존 필드 변경시 SQL은 자동으로 JPA가 처리

패러다임 불일치 해결
* 상속 등 자동으로 처리해준다

* 특정 DB에 종속되지 않는다

신뢰할 수 있는 엔티티, 계층
* 동일한 트랜잭션에서 조회한 엔티티는 같음을 보장한다
    * user1 == user2 보장

## 단점
* 복잡한 동적 쿼리를 작성하기 힘들고
* N+1등 예상치 못한 쿼리로 인한 성능감소가 있을 수 있습니다

## 영속성 컨텍스트
엔티티를 영구 저장하는 환경이라는 뜻으로 애플리케이션과 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을 합니다

EntitiyManager.persist(entity) 라고 하면 엔티티를 db가 아닌 영속성 컨택스트라는 곳에 저장한다.

## 영속성 컨텍스트의 이점
* 1차 캐시
    * 바로 DB 에 가는 것이 아닌 캐시를 먼저 조회한다
    * 캐시에 없다면 DB 를 조회한 후 캐시에 저장한다
    * 트랜잭션 단위로 작동하고 트랜잭션이 끝나면 영속성 컨텍스트도 종료하기 때문에 사실 별로 도움이 안된다

* 동일성 보장
    * == 비교하면 같다

* 트랜잭션을 지원하는 쓰기 지연
    * insert 문을 모았다가 커밋 시점에 한번에 보낸다
    * batch 옵션이다

* 변경 감지(Dirty checking)
    * 엔티티 메니저에 객체를 넣고 나면 객체를 변경하기만 해도 DB까지 자동으로 변경됨

* 지연 로딩

## 엔티티의 생명주기
비영속
* 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태

영속
* 영속성 컨텍스트에 관리되는 상태 
* 엔티티메니저에 persist 해서 객체를 넣은 상태
* 바로 db에 날라가는 것이 아님

준영속
* 영속성 컨텍스트에 저장되었다가 분리된 상태 
* detach 

삭제
* 삭제된 상태

## 플러시
영속성 컨텍스트의 변경내용을 데이터베이스에 반영

영속성 컨텍스트를 비우지 않는다

영속성 컨텍스트의 변경내용을 데이터베이스에 동기화

트랜잭션이라는 작업 단위가 중요 -> 커밋 직전에만 동기화 하면 된다

## 프록시
비즈니스적으로 연관관계에 있는 데이터가 필요 없는 경우 어떻게 할까?

em.find() vs em.getReference()
* em.find() : 데이터베이스를 통해서 실제 엔티티 객체 조회
* em.getReference() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
    * getReference 는 호출되는 시점이 아닌 실제 사용되는 시점에서 DB에서 데이터를 가져온다
    * Entity target = null 을 가지고 있는 빈 객체를 반환해 준다
    * 이 빈 객체를 프록시 라고 한다

## 프록시 특징
* 실제 클래스를 상속 받아서 만들어짐
* 실제 클래스와 겉 모양이 같다
* 사용하는 입장에서는 진짜 객체인지 프록시 객체인지 구분하지 않고 사용하면 된다(이론상)    
* 프록시 객체는 실제 객체의 참조를 보관한다
* 프록시 객체를 호출하면 프록시 객체는 실제 객체의 메소드를 호출한다

## 페치 조인(fetch join)
* 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능
* SQL 조인 종류X
* JPQL 에서 성능 최적화를 위해 제공하는 기능
* join fetch 명령어 사용
* 페치 조인 ::= [LEFT[ OUTER ] | INNER ] JOIN FETCH 조인 경로

## 벌크 연산
* 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면?
* JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행
* 쿼리 한번으로 한꺼번에 하게 해주는 것이 벌크 연산
* .executeUpdate(), .executeDelete()

### 벌크 연산 주의
* 벌크 연산은 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다
    * 벌크 연산을 먼저 실행하고 영속성 컨텍스트에서 작업을 하던가
    * 벌크 연산 수행 후 영속성 컨텍스트를 초기화하던가
    * 참고로 벌크 연산은 flush() 후에 실행된다, 근데 이게 영속성 컨텍스트에 반영되지는 않는다

## N + 1
연관 관계가 설정된 엔티티를 조회할 경우 데이터가 조회된 갯수만큼 연관관계의 조회 쿼리가 추가로 발생하는 것을 의미합니다

JPA 성능에 굉장히 악영향을 미치게 됩니다.

JPQL을 사용할 경우 즉시건 지연로딩이건 발생

해결방법으로는 지연로딩 + jpql의 fetch join사용하거나

이거나 BatchSize 등을 이용하여 해결 가능

## BatchSize
연관된 엔티티 조회시 지정한 사이즈만큼 IN절을 통하여 한번에 조회하게 해주는 옵션 보낸다
