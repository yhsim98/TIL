## LinkedList
스프링이나 자바 어디에 적용됬는지

불연속적으로 저장된 같은 종류의 데이터 집합

자신의 다음 데이터의 주소를 가지고 있다

자바의 경우는 DoubleLinkedList로 이전 데이터에 대한 주소다 가지고 있다

크기가 정해져 있지 않고 삽입, 삭제가 용이하다

불연속적이기 때문에 지역 참조에서 불리하다, cash miss 가능성 높음

대신 메모리 관리는 쉽다

따라서 크기가 정해져있지 않고 자주 삽입, 삭제가 일어나면 List가 유리하다

## ArrayList
같은 종류의 여러 데이터을 모아놓은 데이터 집합

연속된 공간에 같은 타입의 데이터를 저장하기 위한 자료구조

연속된 공간에 할당되기 때문에 임의 접근 가능

지역 참조성 덕분에 List보다 빠름

삽입과 삭제는 O(n)

따라서 크기가 정해져있고, 한번 할당되면 삽입, 작제가 일어나지 않고 자주
검색되면 유리

* ArrayList
    * 크기를 늘릴 수 있는 Array
    * 디폴트로는 10개의 공간을 가짐
    * 다 차면 2배의 크기를 가진 객체를 새로 생성

## 스택
FILO, 하는 자료구조

DFS 등에서 사용된다, 재귀적 함수를 호출할 때도 사용된다

## 큐
FIFO, 하는 자료구조

BFS, 컴퓨터 버퍼 등에서 주로 사용됩니다(레디 큐)

## 덱
Deque라는 인터페이스가 있다.

Queue인터페이스를 상속받는 인터페이스

구현체로는 ArrayDeque, 앞과 뒤 모두 삽입 삭제가 가능

LinkedList vs ArrayDeque
* 배열을 이용했기 때문에 지역성을 통해 cache-hit 에 유리
* 다음 노드에 대한 참조를 유지할 필요 없으므로 메모리 효율적

Stack을 Deque를 이용하여 구현하라는 말이 있다

Stack은 Vector을 상속받았기 때문인데 그것때문에 중간에 값의 삽입이 가능한 문제가 있고, vector는 thread-safe하기 위해 동기화가 되어있는데 그것때문에 싱글스레드에서 느림

## Tree
비선형 자료구조 부모와 자식들로 구성된 graph로 계층이 있고 사이클은 없어야 한다

각 노드가 최대 2개의 자식을 가질 수 있는 트리를 이진 트리라 한다

* 완전이진트리
    * 단말 노드를 제외하고는 모두 자식을 둘 가진다
    * 단말은 왼쪽에서부터 채워짐
* 균형이진트리
    * 높이의 차이가 1이하인 경우

## 이진검색트리(Binary Search Tree)
노드에 키값이 있고, 왼쪽 자식은 키값보다 작은 값, 오른쪽 값보다 큰 값을 유지합니다

## 균형이진검색트리
트리 자료구조의 시간복잡도는 보통 트리의 높이와 비례하기 때문에 높이가 편향되지 않도록 유지하는 것이 필요

* 레드블랙트리
    * 자가균형이진트리
    * 루트 노드는 검은색
    * 빨간색 노드 자식은 검은색
    * 리프 노드는 검은색
    * 이런 규칙들을 이용하여 균형을 유지하는 트리 자로규조로서
    * 높이가 log(n)으로 일정하기 때문에 탐색을 log(n)으로 할 수 있습니다

## 힙
힙은 최솟값 또는 최댓값을 빠르게 찾아내기 위한 완전이진트리 형태로 만들어진 자료구조

완전 이진트리로서, 단말 노드를 제외한 모든 노드가 자식 노드를 2개씩 가지게 됩니다.

부모가 자식보다 항상 크거나 항상 작다는 특징이 있습니다.

배열을 이용해서 구현하게 됩니다.

## 우선순위 큐
먼저 들어간 것이 아닌 우선순위에 따라 나오는 큐

이진힙을 이용하여 구현

* 이진힙
    * 부모값이 자식 값보다 같거나 항상 크다
    * 배열을 통하여 완전이진트리 형태로 구현 가능
    * 삽입 log(n), 추출 log(n)
    * 배열이기 때문에 캐싱에 유리

구현방법
* 삽입
    * 단말노드에 추가
    * 부모보다 우선순위 높으면 교환, 반복
* 삭제 
    * 루트 노드 삭제
    * 단말노드 루트로, 재구성
## Hash
다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑하는 과정

일방향성을 가진다, 값이 조금이라도 바뀌면 해시 값도 달라진다.

자바의 해싱
* 해시함수를 통해 키를 해시값으로 매핑하고 
* 이 해시값을 인덱스로 값에 접근

## Set
저장 순서를 유지하지 않고 중복도 없는 자료구조

* HashSet
    * hashCode()로 접근 후 equals()로 확인
    * 같은 객체면 저장하지 않는다
* TreeSet
    * 이진탐색트리
        * 레드블랙트리
    * 자동으로 정렬됩니다
    * 정렬조건을 지정할 수 있습니다
* LinkedHashSet
    * 저장순서를 유지

* 차이
    * HashSet이 삽입 삭제가 TreeSet보다 빠릅니다
    * TreeSet은 정렬되어 저장합니다


## Map
Key, value 구조를 가지는 자료구조, HashMap과 TreeMap이 있습니다.

* TreeMap
    * 이진탐색트리로 구현
    * 정렬해서 저장한다
    * 삽입 삭제 O(logN)
    * 조회 O(logN)
* HashMap
    * hashCode() 연산 결과를 인덱스로 접근
    * 초기 크기는 10, load factor는 0.75
        * 0.75부터 성능 급격이 하락
    * 해시값 충돌되면 LinkedList로 연결
    * 만약 충돌된 값이 많아지면 균형이진탐색트리로 변경
    * 그래서 접근할때는 최대 O(logN)

## 버블소트
인접한 원소 비교 여러번

## 힙소트
힙을 이용한 소트

## 머지소트
분할해가며 정렬, O(n)

## 퀵소트
피봇을 기준으로 옮겨가며 정렬

자바에서는 더블 피벗 퀵 소트, O(log n)

## 다이나믹
하위문제로 나뉘어 해결하고 결합해가며 해결하는 방식

한번만 계산하고 재활용하는 매모이제이션 활용

## 자바 정렬
* Collections.sort
    * 합병정렬과 삽입정렬을 합친 정렬
    * 자바 7부터 채택
    * 지역성이 없는 List때문에 Tim정렬 사용
* Arrays.sort
    * 듀얼피봇 퀵정렬
    * 평균적으로 좋다나 뭐라나
    * 피봇 주변에서 데이터 이동이 빈번하기 때문에, 지역성을 활용할 수 있기 때문에 퀵 정렬 사용

