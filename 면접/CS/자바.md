## 자바 컴파일 과정
자바는 OS에 독립적이다. JVM 덕분

0. 개발자가 .java 생성
1. 자바 컴파일러가 개발자가 작성한 소스코드를 컴파일 하여, .class인 바이트 코드를 생성합니다
3. .class파일이 클래스 로더를 통해 JVM의 메모리에 올라가게 됩니다
5. 실행엔진이 JVM 메모리에 올라온 .class 파일을 기계어로 변환하게 됩니다.
    * 인터프리터
        * 바이트 코드 명령어를 하나씩 읽어 해석하고 실행합니다
        * 이식성은 높지만 전체적인 실행속도가 느립니다
    * JIT 컴파일러(Just-In-Time Compiler) 
        * 인터프리터의 단점을 보완하기 위해 도입된 방식
        * 한번 기계어로 변환되면 다시 기계어로 변역하지 않고 이전에 번역한 것을 활용합니다 
        * 실행속도가 빨라집니다

## JVM 구조
1. class loader
* 자바는 필요할 때마다 로드됨(lazy loading)
* 런타임시 클래스를 동적으로 JVM에 Runtime Data Area로 로드하는 역할

2. 메모리 영역(Runtime Data Area)
JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고, 용도에 따라 여러 영역으로 나누어 관리합니다. 총 5개의 영역으로 나뉩니다.
* Method area
    * 모든 쓰레드가 공유
    * 클래스, 인터페이스, 메소드, 필드 static 변수 등의 바이트 코드를 보관
* Heap area
    * 모든 쓰레드가 공유하며, new 키워드로 생성된 객체와 배열이 생성되는 영역
    * GC 대상
* Stack area
    * 메서드 안의 지역변수와 매개변수, 리턴값, 연산을 위한 임시 값 등을 저장
    * 스레드 하나당 하나씩 할당
* PC Register
    * 쓰레드 시작될 때 생성되어 쓰레드마다 하나씩 할당
    * 쓰레드 실행되는 부분의 주소와 명령을 저장합니다
* Native method stack
    * 자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역

3. Runtime Engine
* Interpreter : 바이트코드를 읽어 기계어로 변환하여 실행
* Just In Time Compiler : Code Cache 메모리에 캐싱
* Garbage Collection : 참조되지 않은 개체 정리

## compiler vs interpreter
compiler는 개발자가 작성한 소스코드 .java 파일을 JVM이 이해할 수 있는 바이트코드인 .class 변환해줍니다.

interpreter는 이런 바이트코드를 OS가 이해할 수 있는 기계어로 변환해 줍니다.

## String vs StringBuffer, Builder
동기, 비동기

String은 불변객체로 만약 수정할 일이 있다면 객체를 새로 생성해야 합니다.

버퍼나 빌더는 가변객체로 변경이 가능합니다.

버퍼는 동기화를 지원하여 thread safe하다는 특징이 있고, 빌더는 thread safe하지 않지만 단일 쓰레드에서는 그만큼 성능이 빠릅니다

## String이 불변인 이유
1. 스트링은 리터럴("")로 생성할 경우 힙의 상수 풀에 저장된다.

만약 새로운 문자열이 생성될 경우 상수 풀에서 해당 문자열의 존재를 확인 후 없다면 상수 풀에 등록하게 해당하는 레퍼런스를 반환한다.

있다면 따로 저장하지 않고 같은 레퍼런스를 사용하게 됩니다.

이것을 통하여 힙 공간을 절약할 수 있습니다.

만약 불변이 아닐 경우 이렇게 레퍼런스를 공유하는 것이 불가능해집니다.

불변이 아닐 경우 s1 = "abc", s2 = "abc" 가리킬 경우 새로 생성되는게 아니라 같은 레퍼런스를 가지게 된다. == 연산도 가능

하지만 불변이 아니면 s1을 "cde" 변경할 경우 s2도 "cde"를 가리키게 됩니다. 이러면 프로그래머가 예상하지 못한 변경이 있을 수 있기때문에 강건하다 할 수 없습니다. 그래서 불변이어야 합니다.

2. 멀티스레드 환경에서 Thread-safe 합니다.
3. hashing을 수행할 때 처음 한번만 수행하고 그 후로는 캐싱하여 계산했던 값을 반환하므로써 성능상 이점

## 동기 비동기
동기 방식은 작업을 순차적으로 처리, 비동기 방식은 작업을 요청 후 결과값이 반환될 때까지 다른 작업을 하다 결과값이 반환되면 다시 처리하는 것이다. 물론 순서를 보장하지 않는다.

동기화란 멀티 스레드 환경에서 상호배제를 통해 자원에 동시 접근하지 않도록 막아주는 것

## 동기화
멀티 스레드 환경에서 상호배제를 통해 자원에 동시 접근하지 않도록 막아주는 것

상호배제 방법으로 Mutex와 Semaphore가 있다

## Mutex
상호배제 방법으로 멀티 스레드 환경에서 자원에 대한 접근 제한을 강제하는 동기화 메커니즘

* Boolean 타입의 Lock 변수
    * 1개의 공유자원에 대한 접근을 제한
* 공유자원을 사용중인 스레드가 있다면, 접근하는 스레드는 Blocking 후 ready Queue로 이동됩니다
* Lcok을 건 스레드만 Lock을 해제할 수 있습니다
* 작업이 완료되면 Lock을 false로 만들고 레디 큐에있던 스레드를 호출합니다

## Semaphore
멀티프로그래밍 환경에서 다수의 프로세스나 스레드가 n개의 공유 자원에 접근할 때  접근을 제한하는 동기화 기법

* 음이 아닌 정수 S를 사용, 증감연산자로만 수정 가능
* n개의 공유자원에 대한 접근을 제한할 수 있다
* 강성 세마포어
    * 큐에 연결된 스레드를 깨우는 방식이 FIFO
* 약성 세마포어
    * 비결정적
* OS가 atomic하게 보장하여 준다
* Lock을 걸지 않은 스레드도 Signal을 보내 Lock 해제 가능

## 자바 스레드
Thread 클래스를 상속받은 다음 run을 오버라이드 해주거나

Runnable 인터페이스를 구현하는 class를 만들어 run메소드를 오버라이드 후 스레드 생성시 생성자 파라미터로 넣어주면 됩니다.


## 자바의 멀티 스레드 환경
자바는 멀티 스레드 환경을 가집니다.


## 동시성과 병렬성
동시성이란 한 코어가 작업을 잘개 쪼개 매우 빠른 속도로 context switch을 일으키며 번갈아가며 처리하는 것 동시에 여러 작업을 하는 것처럼 보이게 됩니다. 싱글코어에서 멀티 쓰레드 처리 가능
한번에 많은 것을 처리

병렬성은 여러 프로세서가 여러 프로세스를 처리하는 것

## thread safe
스레드가 자원에 접근하는 것을 제어해줘야 하는데 이를 상호배제 Mutex라 한다.

그리도 동기화 작업을 해준 클래스는 Thread safe 하다고 표현한다

synchronized를 통해 동기화해줄 수 있다

## thread pool
스레드를 매번 생성하게 되면 성능저하

## java 불변 객체
생성 후 그 상태를 바꿀 수 없는 객체  
final 하거나 setter 가 없거나 해서 수정할 수 없는 것  
참고로 불변객체가 참조하는 객체도 전부 불변이어야 함

대표적으로는 String, Integer 등이 있다

우선 Thread-Safe 합니다. 변경되지 않기 때문에 동기화를 고려하지 않아도 됩니다.

그리고 side effect가 없어 객체의 상태를 예측하기 쉽고 오류가능성을 줄여주게 됩니다. 

또 가비지 컬렉션의 성능을 높일 수 있습니다. 불변객체를 참조하는 객체가 살아있다면 불변객체 또한 처음 참조된 상태 그대로 살아있다는 것을 의미하기 때문에 GC가 스캔해야 되는 객체가 줄어 성능이 올라가게 됩니다.

단점은 다른 값을 가질 때 매번 새로운 객체를 생성해야 합니다.

## new String()과 ""의 차이
리터럴과 new 연산의 차이

리터럴은 힙 상수 풀에 생성됨, new는 일반 객체처럼 생성

리터럴은 상수 풀에 한번만 생성되고 그 후로는 같은 레퍼런스 공유
 

## 접근 제어자 종류와 특징
* private : 같은 클래스 내부에서만 접근 가능
* default : 같은 클래스와 패키지
* protected : 상속과 같은 클래스와 패키지
* public : 전체 접근 가능

## static
전역적으로 멤버나 메소드를 사용할 수 있게 해줍니다

static 멤버는 Heap 영역이 아닌 메소드 영역에 고정적으로 할당되어 프로그램이 종료될 때 해제

static 멤버들은 모든 인스턴스가 공유하는 가능하다는 장점을 지니지만, GC의 대상이 아님으로 너무 많이 사용하면 시스템 퍼포먼스에 악영향을 줍니다.

static 메소드는 
모든 인스턴스가 공통적으로 사용하는 멤버변수에 붙이거나, 인스턴스 변수를 사용하지 않아 항상 일관적인 메소드에 붙여주면 호출시간이 짧아집니다.

## final 
한번 생성되면 바뀌지 않도록 하는 키워드

생성자나 직접 초기화 후 변경할 수 없다

원시타입에 붙이면 상수값

객체 변수에 붙이면 그 변수에 다른 참조값 지정 불가, 물론 객체의 속성은 변경 가능

메서드 인자에 붙이면, 메서드 안에서 변수값 변경 불가

static 멤버 변수에 사용하면 전역 상수가 됨

final 메소드는 상속받은 클래스에서 오버라이드 불가
* 변경되면 안되는 자바 코어 라이브러리에서 주로 사용

final 클래스는 상속이 안됨
* 상수 값 모아둔 클래스 등에 사용
* util 등에도 사용

## 클래스, 객체, 인스턴스 차이
* 클래스 : 객체를 만들어내기 위한 틀로서, 연관된 변수와 메서드의 집합
* 객체
    * 소프트웨어 세계에 구현할 대상
    * 클래스 타입의 인스턴스
    * 약간 논리적인거? 테이블의 low라 해야하나
* 인스턴스
    * 클래스를 바탕으로 소프트웨어 세계에 구현된 객체 
    * 설계도를 바탕으로 메모리에 구현된 상태
    * 클래스를 바탕으로 메모리를 할당하여 인스턴스를 만드는 것을 인스턴스화

## interface와 abstract class
각각 특성이랑
사용처, 어디 사용했나

* interface 
    * 일종의 추상 클래스로서 클래스들이 구현해야 하는 동작을 지정하게 됩니다
    * 구체화
    * 구성요소
        * 상수 필드(static final)
            * 자바 8부터 가능
        * 추상 메서드
        * 디폴트 메서드
            * 자바 8에서 추가
            * 확장성 증가
        * 정적 메서드
            * 자바 8에서 추가
            * 객체 없이 인터페이스만으로 호출 가능
            * 오버라이드 불가
    * 같은 이름의 메소드를 가진 여러 다른 객체를 공통 처리할 수 있어 자바의 다형성을 이용할 수 있다
        * 유지보수성 증가
* 추상클래스
    * 추상메서드가 있는 클래스
    * 상속받는 클래스는 추상 메소드를 모두 구현해 주어야 함
    * 한 클래스는 하나의 클래스만 상속받을 수 있고, 상태를 가질 수 있다

* 차이
    * 사용 목적이 다릅니다
    * 추상 클래스의 경우 상속받아 기능을 이용하고 확장하는데 중점을 둡니다
    * 인터페이스의 경우 같은 동작을 보장하고 다형성을 제공하기 위해 사용하게 됩니다

## CheckedException vs UncheckedException
사례도 같이 들어서 부가적으로 설명

* Error
    * 시스템 레벨에서 발생하는 심각한 수준의 오류, 개발자가 핸들링할 수 없습니다
* Unchecked Exception
    * Runtime Exception의 하위 예외
    * 실행 중에 발생할 수 있는 에러, 에러 처리를 강제하지 않는다
    * ex) NullPointer, ArrayIndexOutOfBounds
    * 보통 개발자의 실수 혹은 개발자가 조건을 만들어 의도적으로 발생시킴
    * @Transactional 같은 선언적 트랜잭션에서는 런타임 예외가 발생하면 롤백한다 
    * 예외가 발생하지 않거나 체크 예외가 발생하면 커밋한다
    * 체크 예외는 예외적인 상황보다는 리턴 값을 대신해서 비즈니스적인 의미를 담은 결과를 돌려주는 용도로 많이 사용되기 때문
    * rolbackFor속성을 이용하여 명시적으로 적용할 수도 있다
* Checked Exception
    * Exception 클래스의 하위 클래스
    * 반드시 처리해야 하는 예외
    * 클래스가 없거나, 존재하지 않는 파일 등 처리하지 않으면 컴파일 시간에 잡힌다
    
저는 예외 전환하여 적절히 포장 후 던진다

## 예외 처리 방법
* 예외 복구
    * 문제 상황 파악후 재시도
* 예외처리 회피
    * 처리하지 않고 상위 메소드로 던진다
* 예외 전환
    * 상위 메소드로 던지지만 적절한 예외로 전환하여 넘긴다

## Call by Reference vs Call by Value
자바는?
자바는 call by value로 주소값을 복사하여 전달하게 됩니다.

만약 변수 a와 a를 전달받은 b가 있을 때, b는 주소값이 복사되어 전달된 변수이므로 b가 다른 객체를 가리키게 된다 하더라도 a에는 아무런 영향을 주지 않습니다.

만약 call by reference인 경우 b가 다른 객체를 가리키게 된다고 했을 때 a도 마찬가지로 다른 객체를 가리키게 됩니다.

## 오버로딩 오버라이딩
특징과 객체지향에 다형성과 관련됨

* 오버로딩 : 같은 메서드 이름을 가지지만 매개변수가 다름, 리턴타입은 상관없음
    * 다양한 유형의 호출에 응답할 수 있습니다
    * 접근제어랑 리턴값은 상관없음
    * 같은 기능을 하는 메서드들을 하나의 이름으로 사용 가능
* 오버라이딩 : 상위 클래스의 메서드를 재정의, 부모에도 접근하고 싶으면 super
    * 상속받은 메서드를 자식 클래스에 맞도록 재정의 가능합니다

다형성을 제공

## 자바 GC
Minor, Major, Full GC

Young 영역 old영역

Card Table

* 대부분의 객체는 금방 접근 불가 상태가 된다
* 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다

* Young 영역
    * 새롭게 생성된 객체가 할당되는 영역
    * Young 영역에 대한 가비지 컬렉션을 Minor GC라고 부른다
    * 하나의 에덴과 두개의 서바이버
    * 처음 생성된 객체는 에덴, 한번 마이너 GC에서 살아남으면 서바이버
* Old 영역
    * Young 영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
    * 복사되는 과정에서 대부분 Young 영역보다 크게 할당되며, 크기가 큰 만큼 가비지는 적게 발생한다
    * Old 영역에 대한 가비지 컬렉션을 Major GC또는 Full GC이라 부른다

보통 Old 영역은 Young 영역보다 크게 할당됩니다. Young 영역의 수명이 짧은 객체들은 큰 공간을 필요로 하지 않고 큰 객체들은 Young영역이 아니라 바로 Old 영역에 할당되기 때문입니다.

* 예외적인 상황으로 Old 영역의 객체가 Young영역의 객체를 참조하는 경우가 있다
* 그래서 Old 영역에는 Card Table이 존재한다
* Card Table에는 Old영역의 객체가 Young영역의 객체를 참조할 때 그에 관한 정보가 저장된다
* Minor GC시 Card Table만 검사해도 GC대상인지 식별할 수 있다

* Minor GC
    * 에덴이 꽉 차면 마이너 GC가 일어납니다
    * 에덴에서의 Reachable 객체는 서바이버 영역으로 이동하는데 2개중 하나는 비어있어야 함
    * 살아남을때마다 age증가, 일정 값 넘으면 old로 이동
    * 하나의 서바이버 영역이 다 차면 마크 엔 스윕
    * reachable한 객체는 다른 서바이버로 이동, 이때마다 age 증가 
* Major GC또는 Full GC
    * Old 영역에 대한 GC

## 자바 GC 동작방식
2가지의 단계를 따른다

* Stop The World
    * GC를 위해 JVM이 애플리케이션의 실행을 멈춘다
    * GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단
    * 비용이 크다
* Mark and Sweep
    * Mark : 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
        * 스택의 모든 변수 탐색하여 reachable 확인
        * reachable 객체가 참조하는 객체확인
    * Sweep : Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업

Stop The World에서 작업을 중단시키면, GC는 스택의 모든 변수 또는 Reachable 객체를 스캔하며 각각이 어떤 객체를 참조하고 있는지 탐색을 통해 사용되는 메모리를 식별, 이것을 Mark

Mark 되지 않은 객체를 메모리에서 제거하는데 이것을 sweep

## 제네릭
형변환 오류 예방, 런타임 오류 예방, 컴파일에서 잡아줌

유지보수 향상

강건성이란 어떤 환경에서도 올바르게 동작하는 정도

## 클래스 변수(static 멤버 변수)와 인스턴스 변수(Non-static 멤버)의 차이에 대해 설명하세요

## primitive type & reference type
primitive type은 기본 자료형 타입입니다. int, char 등 stack 영역에 저장되게 됩니다.

reference type은 참조형 기본형을 제외한 모든 타입으로, 값이 아닌 객체의 주소값을 저장하는 변수를 말함. 힙 영역에 저장되게 됩니다

## 업 캐스팅과 다운캐스팅
* 업캐스팅 : 자식 객체가 부모 클래스 타입으로 형변환
* 다운캐스팅 : 부모 클래스 객체가 자식 클래스 타입으로 형변환
    * 기본적으로는 불가
    * 만약 업캐스팅을 했다면 다운캐스팅 가능
    * 명시적으로 타입을 지정
    

## Error와 Exception의 차이

## 얕은 복사 깊은 복사
* 얕은 복사 : 객체의 주소값을 복사
* 깊은 복사 : 객체의 값을 복사, 같은 값을 가진 다른 객체
    * 깊은 복사를 위해서는 
    * cloneable인터페이스 넣고
    * clone() 재정의하면 됨
    * 권장하지는 않는단다, 복사 생성자 사용하자

## 어노테이션에 대해 설명
자바 어노테이션은 소스코드에 추가하여 사용할 수 있는 메타 데이터의 일종으로, 컴파일 과정과 실행 과정에서 어떻게 처리해야 하는지 알려주기 위한 추가 정보입니다.

* 표준 어노테이션 : 자바가 기본적으로 제공
* 메타 어노테이션 : 어노테이션을 위한 어노테이션
* 사용자 정의 어노테이션 : 사용자가 직접 정의하는 어노테이션

## 래퍼클래스에 대해 설명
Integer, Character 등 

기본 데이터타입을 객체로 취급하기 위해 사용

기본 타입을 객체로 바꾸는 것을 박싱, 반대는 언박싱

## 자바 Thread에서 start와 run의 차이

## 병행과 병렬의 차이
* 병행 : 여러가지 일을 동시에 수행하는 것처럼 매우 짧은 시간에 번갈아가며 수행하는 것
* 병렬 : 멀티코어 환경에서 여러가지 일을 동시에 수행하는 것

## Map, Set, List

## iterator는 무엇인가요?
반복자, 자바 컬렉션에서 각 요소에 접근할 수 있게 해주는 메소드

hasNext(), next() 등 지원, 지금은 foreach 사용하는 것을 권장, iterator를 굳이 생성할 필요없이 순회 가능

## 이진탐색트리에 대해 설명하세요

## Stack과 Queue에 대해 설명하세요

## 해싱이란?
다양한 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑하는 과정

일방향성을 가진다, 값이 조금이라도 바뀌면 해시 값도 달라진다.

자바의 해싱
* 해시함수를 통해 키를 해시값으로 매핑하고 
* 이 해시값을 인덱스로 값에 접근

## 자바 hashMap
키를 해싱한 값을 인덱스로 값에 접근하는 자료구조

내부적으로 array(버킷이라고 함)를 사용하기 때문에 해싱의 값은 정수여야 한다, 물론 배열의 크기를 넘어가면 안된다

각 키는 하나의 value만 가질 수 있다

삽입, 삭제, 검색 모두 O(1)

Map에서 객체를 키로 사용할 경우 equals와 hashCode를 오버라이드 해야 합니다

hashCode로 찾아갔는데 충돌이 나면 equals로 같은 값인지 확인해야 함
초기값은 16 로드팩터는 0.75

용량이 로드팩터만큼(75%) 찼다면 용량을 2배로 늘려주고 버킷의 값들을 새로운 버킷에 옮긴다

해시의 결과의 크기가 key의 종류보다 작으니 충돌이 일어날 수 있다
그래서 로드팩터 비율만큼 버킷이 차면 확장

또한 충돌이 일어났을 경우를 대비 LinkedList + RedBlackTree를 통해 해결한다 

충돌이 일어날 경우 처음에는 LinkedList로 유지하다 임계값이 넘으면 Red black Tree로 바꾼다

## Stop The World
GC의 방법, GC를 위해 GC를 수행하는 스레드를 제외한 모든 스레드를 멈춘다

## Reachability
도달가능성, 도달가능성이 없는 객체가 GC의 대상이 된다

## Young영역과 Old영역
Young 영역은 생성된지 얼마 안된 객체가 저장되고, Old영역은 Young영역에서 살아남은 객체가 오게 된다.

Young 영역을 대상으로하는 GC를 Minor GC, Old영역은 Major GC

## Minor GC와 Major GC

## 자바8
함수형 프로그래밍 패러다임을 지원하게 되었습니다

함수가 1급 시민이 되었습니다.

스트림 API, 함수가 1급 시민(파라미너로 전달 가능, 동작 파리미터화), 인터페이스의 디폴트 메서드

## 스트림
Stream API란 자바에서의 일련의 데이터 요소인 배열이나 컬렉션 등의 데이터를 처리하기 위한 API 입니다. 

컬렉션과 다르게 내부 반복을 사용하여 반복을 알아서 처리하게 됩니다. 이것을 통해 병렬성을 손쉽게 획득할 수 있습니다

외부반복 : 사용자가 직접 요소를 반복

데이터를 필터링하고 추출하여 그룹화할 수 있다

## 람다
익명 함수로, 이름과 식별자가 없습니다.

적절한 클래스나 메서드가 없을 경우 코드를 간결하게 작성할 수 있습니다.

## 함수형 인터페이스
단 하나의 추상 메소드를 가지고 있는 인터페이스

람다식과 결합하여 여러 연산을 간단하게 구현 가능

Predicate, Comparator 등이 있습니다

## Optional
NPE를 방지하기 위해 null 이 발생할 수 있는 객체를 Optional로 감싸서 처리할 수 있습니다.

orElseThrow등 null을 간편하게 핸들링할 수 있습니다.

null을 반환하면 오류가 발생할 가능성이 높은 경우 결과없음을 명확하게 들어내기 위해 반환타입으로 사용되도록 만들어졌습니다.

Optional 생성하는 자체도 비용임으로 주의해서 사용해야 합니다


## 함수형 프로그래밍



## default 인터페이스
인터페이스의 확장성이 증가였다