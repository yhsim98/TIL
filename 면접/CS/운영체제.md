## 운영체제
시스템의 자원과 동작을 효율적으로 관리하는 소프트웨어

크게 system call interface, kernel, resource management로 구성되어 있습니다.

* 역할
    * 사용자 편의성
    * 하드웨어 관리
    * 자원 관리

## system call interface
사용자 프로그램이 커널에 접근할 수 있도록 제공하는 인터페이스

악의적인 사용자로부터 시스템을 보호하기 위해 system call interface를 통해서만 커널의 기능에 접근할 수 있도록 합니다.

## 커널
커널이란 메모리에 상주하는 운영체제의 부분으로 processor나 memory 관리 등 실질적인 os 기능들을 수행하게 됩니다.

## 이중 모드 방식
다중 프로그래밍 환경에서 자원에 대한 접근을 사용자 모드와 커널 모드로 분리하여 운영체제를 보호하는 기법

user mode는 사용자의 애플리케이션 코드를 실행하며 시스템에 대한 제한된 접근만이 허용됩니다.
user mode에서 system call을 수행하면 kernel mode로 변경됩니다. kernel mode에서는 모든 자원에 대해 접근이 가능합니다.

이를 통하여 악의적인 사용자로부터 운영체제의 시스템과 자원을 보호할 수 있습니다.

cpu내부의 mode bit는 유저모드가 1, 커널모드가 0

## 프로세스와 스레드의 차이는 무엇인가요?
프로세스는 프로그램이 메모리에 올라가 실행되는 것이라면, 스레드는 자원을 가지고 작업을 처리하는 단위를 의미합니다.
 
프로세스가 스레드를 포함하게 되고, 하나의 프로세스는 하나 이상의 스레드를 가질 수 있습니다.

같은 프로세스의 스레드는 특정 메모리 영역을 공유할 수 있어 context switching 비용이 적습니다.

## 프로세스 메모리 구조
힙, 스택, 코드, 데이터 이렇게 4가지로 구분됩니다.

코드 영역은 실행할 프로그램의 코드가 저장되고, cpu는 이 영역에서 명령어를 가져와 실행합니다.

데이터 영역은 

## 프로세스 상태
create, ready, running, blocked, terminated

ready에서 running 되기 위해 기다리는 곳이 ready queue

## 컨텍스트 스위칭이란 무엇인가요?
다중 프로그래밍 환경에서 동시성을 제공하기 위해 여러 프로제스를 번갈아가며 처리하게 됩니다. 
이때, 현재 진행중인 작업의 Context를 저장하고 다음 처리할 작업의 context를 불러오는 것을 context switching 이라 합니다.

context를 PCB에 저장

## Context란?
cpu가 해당 프로세스를 실행하기 위한 프로세스와 관련된 정보들의 집합

## 왜 컨텍스트 스위칭이 필요할까요?
동시성을 제공하기 위해서 입니다.
만약 하나의 작업이 마쳐야만 다음 작업을 수행할 수 있다면, 작업이 i/o를 수행한다면, 해당 i/o 처리하는 동안 cpu가 놀게되어 cpu 사용률이 떨어지게 됩니다.

이런 상황을 방지하기 위해 os는 여러 작업을 번갈아가며 처리하게되고, context switching이 필요해졌습니다.

## PCB
OS가 프로세스 관리에 필요한 모든 정보를 저장하는 저장공간입니다.

프로세스 생성 시, 커널에 생성되고 모든 프로세스가 각각 하나씩 가집니다

## 프로세스 상태
* 생성  
    * 프로세스 생성
* 준비
    * cpu를 제외한 모든 자원 할당
* 실행
    * 준비 단계에 있던 프로세스가 cpu를 할당받은 상태
    * 준비에서 실행을 dispatch라 한다
* blocked, asleep
    * 사용중이던 프로세서를 반납한 상태
    * block 됬다고 한다
* 종료
    * 프로세스가 실행을

* 상태 전이 동작
    * dispatch
        * 우선순위가 높은 프로세스를 선정하여 cpu 할당
    * timer runout
        * 클럭이 인터럽트를 발생시켜 제어권을 빼앗음
        * preemption, 독점 방지
    * block
        * 프로세서가 입출력, 자원 등을 기다리기 위해 대기로 전환
    * wake up
        * 입출력이 완료되거나 자원이 할당되어 다시 실행

## CPU 스케쥴링에 대해 설명해주세요?
os는 cpu 활용율을 증가시키기 위해 여러 프로세스를 번갈아가며 실행하게 됩니다

cpu를 할당받기 위해 대기 중이던 프로세스 중 어떤 프로세스에 CPU를 할당할지 선택하는 것입니다.

## CPU 스케줄링에 대해 자세히
선점과 비선점으로 나뉩니다. 비선점의 경우 프로세스가 스스로 반납하기 전까지 사용, 선점의 경우는 타의에 의해 빼앗길 수 있습니다.

선점 방식의 알고리즘으로는 대표적으로
* RR
    * 먼저 도착한 프로세스 먼저 처리
    * time quantum을 둔다
    * 할당된 시간이 지나면 자원 반납
* SRTN(Shortest Remaining Time Next)
    * 잔여 실행 시간이 가장 적은 프로세스가 ready 상태가 되면 선점됩니다 

비선점 방식에는
* FCFS
    * 먼저온 프로세스부터 스스로 반납할때까지 사용하게 됩니다
* SPN
    * 실행 시간이 가장 짧은 프로세스를 먼저 실행합니다
* HRRN
    * 대기시간을 고려하여 기회를 제공
    * 대기시간 + 실행시간 / 실행시간이 가장 높은 프로세스 먼저
    * response ratio가 높은
등이 있습니다

## 인터럽트
CPU가 프로그램을 실행하고 있을 때, 실행중인 프로그램 밖에서 예외 상황이 발생하여 처리가 필요한 경우, CPU에게 알려 처리할 수 있도록 하는 것

* I/O request, time slice expired 등등

## 스레드
CPU 입장에서 작업의 최소 단위로, 프로세스의 자원을 사용하여 작업을 처리합니다.

프로세스의 특정 메모리 영역을 공유합니다

* 자원 공유
* 경제성
    * 프로세스를 하나 만드는 것보다 효율적
* 멀티 프로세서 활용
    * 병렬처리를 통해 성능 향상
    * 여러 코어 사용 가능

## 한 프로세스가 CPU를 독점하는 것을 방지하기 위한 방법
CPU 스케줄링

## 멀티 프로그래밍

## 멀티 프로세스, 멀티 스레드

## 동시성과 병렬성
동시성이란 여러 프로세스를 마치 동시에 처리하는 것처럼 번갈아가며 처리하는 것을 의미합니다.

병렬성은 여러 코어가 정말로 작업을 동시에 처리하는 것을 의미합니다

## 멀티 스레드의 경우 주의사항
공유영역에 동시에 접근할 경우 접근 순서에 따라 결과가 달라지는 race condition이 발생할 수 있습니다.

이를 방지하기 위해 동시에 ciritical section에 접근하는 것을 막는 mutual exclusion이 필요합니다.

## 프로세스 동기화란?
여러 프로세스가 공유 데이터에 동시에 접근할 경우 접근 순서에 따라 결과가 달라질 수 있습니다. 이것을 race condition이라 하는데, 프로세스 동기화란 프로세스 혹은 스레드가 동시에 critical section에 접근하는 것을 막는 mutual exclusion을 통해 race condition을 예방하는 것을 의미합니다.

운영체제에서 제공하는 대표적은 Mutual exclusion 방식으로는 semaphore가 있습니다.

## Mutex
동기화를 위한 상호배제 기술로, boolean 타입의 lock 변수를 통해 
하나의 스레드만이 동일한 시점에 뮤텍스를 얻어 cs에 들어갈 수 있고, 오직 그 스레드만이 cs에서 나갈 때 뮤텍스를 해체할 수 있습니다.

## 스핀록
비지 웨이팅 뮤텍스??

## 그럼 semaphore는 무엇인가요?
멀티프로그래밍 환경에서 다수의 프로세스나 스레드가 여러 개의 공유 자원에 대한 접근을 제한하는 방법
임계영역에 여러 프로세스 혹은 스레드가 접근하는 것을 막아줍니다

## semaphore vs mutex
mutex의 경우 소유가 가능하며 수유주가 책임을 집니다. 쇼유주만이 반납할 수 있습니다. 세마포는 소유할 수 없고 cs 밖의 프로세스도 세마포를 해제할 수 있습니다.

mutex는 동기화 대상이 하나일때, 세마포어는 동기화 대상이 하나 이상일 때 사용합니다


## Critical Section
코드 상에서 race condition이 발생할 수 있는 특정 부분

동시에 접근하는 critical section문제를 해결하기 위해서는 3가지 조건을 충족해야 합니다.

1. Mutual Exclusion
    * critical section에 프로세스가 있으면 다른 프로세스의 진입을 막습니다
2. progress
    * critical section에 프로세스가 없다면 다른 프로세스가 접근할 수 있어야 하고
    * cs 안에 있는 프로세스를 제외하고는 다른 프로세스가 cs에 접근하는 것을 방해하면 안됩니다
3. bounded waiting
    * 프로세스가 무한히 대기해서는 안됩니다
    * 유한시간 내에 접근이 허용되어야 합니다


## Deadlock이란?
deadlock 발생조건 4가지를 충족하여 대기중인 프로세스의 상태가 결코 변할 수 없는 상황

## Deadlock을 핸들링하기 위한 방법들
예방, 회피, 회복

* 예방
    * non preemptiom
    * mutual exclustion
    * hold and wait
    * circular wait 

회피
교착상태가 발생할 것 같은면 피하는 방법

프로세스가 자원을 요구할 때 시스템은 자원을 할당한 후에도 안전상태로 있는지 사전에 검사하여 교착 상태를 회피하는 기법으로, 안전상태에 있다면 자원을 할당하고, 그렇지 않다면 다른 프로세스들이 자원을 해지할 때까지 대기합니다

safe 상태 : dead lock 발생 가능성이 없음
unsafe : deadlock 발생 가능성이 있음


탐지(Detection)
자원할당 그래프를 dfs로 순회하며 cycle이 발생한다면 daedlcok 가능성

회복
교착 상태를 일으킨 프로세스를 종료하거나, 자원을 선점시켜 회복하게 합니다.

중요도나 수행시간 필요한 리소스등을 따져서 종료시킴

## 메모리 할당 방법
* 연속 메모리 할당
    * 프로세스를 연속된 메모리 공간에 통쨰로 할당하는 방식입니다
    * 외부 단편화가 일어날 수 잇습니다.
    * 연속 메모리 할당 방식
        * first fit
        * worst fit
        * best fit
    * 그래서 whole을 한곳으로 모으는 compaction

    * 가변 메모리 할당
        * 페이징
        * 세그멘테이션

## 페이징
프로세스를 일정한 물리적 단위인 페이지로 나누어 메모리에 적재하는 방식
메모리가 나뉜것은 프레임이라 합니다

내부 단편화가 발생할 수 있습니다.

## 세그멘테이션
프로세스를 논리적 단위인 세그먼트로 분할하여 메모리에 적재하는 방식

외부 단편화 발생 가능

## 외부 단편화
메모리에 적재가 가능한 공간이 남았지만 연속되지 않아 적재할 수 없는 상태

## 내부 단편화 
프로세스 마지막 페이지는 한 프레임을 다 채울 수 없기 때문에 메모리 낭비

외부 단편화에 비해 미비

## 동기와 비동기

## 뮤텍스와 세마포

## 페이지 교체 알고리즘

## 가상 메모리란?
물리적인 메모리에 한계를 극복하기 위해 도입됬습니다.

프로세스의 이미지를 디스크의 스왑메모리에 저장 후 필요한 부분만 동적으로 메모리에 적재하는 방식입니다.

## Page fault
프로세스의 페이지에 접근할 때 해당 페이지가 메모리에 없다면 page fault 인터럽트가 발생된다.

swap device에서 해당 page를 가져오게 된다.

만약 메모리가 찼다면 swapping 하게 된다

## 페이지 교체
메모리가 찼을 경우, victim 페이지를 내리고 새로 페이지를 적재하는 것

## 페이지 교체 알고리즘
page fualt를 최대한 줄이는 방향으로 victim frame를 결정하는 알고리즘

* FIFO
    * 가장 먼저 들어온 페이지를 victim으로 하는 것입니다
* Optimal page Replacement
    * 가장 오랫동안 사용되지 않을 페이지를 victim으로
    * 어떤 페이지를 사용하지않을지 추측이 불가능하기 때문에 
    * 성능 비교를 위한 알고리즘
* LRU
    * 가장 사용한지 오래된 페이지를 victim으로 선정
    * 시간 지역성 고려
        * 최근에 참조된 페이지가 다시 참조될 가능성이 높은 성질
* NRU
    * 최근에 사용하지 않은 페이지 교체
    * 참조 비트와 변형 비트를 두고
    * 클럭 알고리즘이 돌며 참조하지 않은 페이지의 비트 값을 0으로 바꾼다
    * 다시 방문할때까지 0이면 해당 페이지 교체

## thrashing
너무 많은 프로세스가 한번에 실행되면, 각 프로세스당 할당된 메모리가 적어 swap 이 빈번하게 일어나 성능이 하락한다
이것을 thrashing