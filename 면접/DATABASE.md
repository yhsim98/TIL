## 데이터베이스를 설계할 때 ERD 도구로 어떤 것을 사용했나요?
저는 viso 를 사용했습니다. 아는게 이거밖에 없기도 하고 딱히 사용하는데 불만은 없습니다.
설마 안물어보겠지?

## DB 락의 종류
읽기 전용인 경우 사용하는 Shared Lock과 데이터를 수정할 때 사용하는  Exclusive Lock이 있습니다.

shared Lock의 경우는 같은 shared Lock 끼리는 접근을 혀용하지만 Exclusive Lock의 접근은 막습니다.

Exclusive Lock의 경우 모든 접근을 막습니다. 데드록이나 블로킹이 발생가능합니다.

## 인덱스에 대해 설명해주세요
테이블의 검색 속도를 높이기 위해 사용한 자료구조입니다. B-tree 자료구조를 이용하여 찾아갈 수 있도록 하는 것입니다. 

mysql의 내부 구현체인 InnoDB의 경우는 B+Tree로 인덱스를 구현하였습니다.

unique 하거나 PK면 자동으로 설정됩니다. 카디널리티가 높거나 자주 조회하는 열에 설정하면 좋습니다. 

조회 성능이 향상되지만 인덱스를 저장하는데 공간이 필요하게 됩니다. 또한 데이터 삽입시 인덱스처리를 하는 비용이 들고 update, delete 시 따로 인덱스의 변경없이 soft delete 처리를 하는데 이게 지속적으로 쌓이게 되면 인덱스테이블의 크기가 비대해져 오히려 성능이 떨어질 수 있습니다

## 캐시 전략에 대해 설명해주세요
lazy loading, time to live, write through 방식이 있습니다. 자세한 것은 구글링

## DB를 설계하는 과정에서 어려웠던 경험이 있다면 얘기해주세요
무결성과 성능 사이에서 고민을 많이 했던 것 같습니다. 회원과 비회원이 있었는데 회원과 비회원을 같은 테이블에 가지고 있기에는 너무 빈 값이 많아져 

회원과 비회원을 설계할 때 고민을 많이 했습니다. 회원과 비회원을 같은 테이블에 가지고 있기에는 너무 빈 칼럼이 많아졌고 나누기에는 서비스에서 id값이 겹칠 경우

슈퍼 서브 타입으로 해결

그 외에도 무결성과 성능, 테이블 크기, 등 고민이 많았음

아직 어느선까지 무결성을 지켜야 하는지 잘 모르겠다.

## 인덱스의 종류와 각각의 특징에 대해 설명해주세요
B-Tree, BITMAP 인덱스가 있다 

## constraints에 대해 설명해주세요
unique, pk, fk not null 등 자료에 대한 제약을 의미합니다.

## 무결성이란?
데이터의 정확성, 일관성, 유효성이 유지되는 것

## 정규화
릴레이션을 분리하여 중복을 배제하고 삽입, 삭제, 갱신 이상을 방지하는 것

테이블이 분리되어 조인이 필요해진다. 따라서 성능이 느려진다.

역정규화란 성능을 위하여 정규화 단계를 낮추는 것

## 트랜잭션
DB의 논리적인 작업의 단위입니다.

원자성, 독립성, 일관성, 지속성 등의 특징이 있습니다.

## commit, rollback
트랜잭션이 성공적으로 완료되어 해당 결과를 반영하는 것

트랜잭션이 실패하여 변경된 결과를 원래돼로 되돌리는 것

## Lock
트랜잭션 처리의 순차성을 보장해주기 위해 하나의 트랜잭션이 완벽하게 끝날 때까지 다른 요청을 막아주는 역할을 합니다.

shared lock, exclusive lock이 있다.

데이터를 변경하는 경우 상대방에 접근할 수 없다.

서로가 진행하기 위해 서로가 필요하다면 daedlock이 발생

트랜잭션을 자주 커밋하거나 