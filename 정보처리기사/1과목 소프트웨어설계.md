# 요구사항 확인
## 소프트웨어 생명주기
개발 방법론의 바탕. 소프트웨어 개발과정을 단계별로 나눈 것

소프트웨어 공학
* 위기 극복을 위해 연구된 학문
* 소프트웨어의 품질과 생산성 향상을 목적
* 기본 원칙 3가지
    * 현대적 기술을 게속적으로 적용
    * 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증
    * 명확한 기록 유지

소프트웨어 생명 주기 모형
1. 폭포수형 모형
2. 프로토타입 모형
3. 나선형 모형
4. 애자일

## 폭포수형 모형
순차적으로 한 단계식 진행해 나간다. 전단계가 수행되어 완료되기 전에는 다음 단계로 진행할 수 없다

가장 오래되고 가장 폭넓게 사용됬다. 두 개 이상의 과정이 병행하여 수행되지 않는다.

타당성 -> 요구분석(문서화) -> 설계 -> 구현 -> 테스트 -> 유지보수

## 프로토타입 모형
개발초기 시스템의 모형을 간단히 만들어 사용자에게 보여 주고, 사용자가 정보시스템을 직접 사용해보게 함으로써 프로토타입을 재구축하는 과정을 사용자가 만족할 때까지 반복해 나가며 시스템을 개선시켜 나가는 방식

요구문제 -> 프로토타입 설계 -> 프로토타입 개발 -> 고객평가

요구사항이 부정확하거나 할 때 사용한다. 변경이 용이하지만 비용이나 시간이 많이든다.


## 나선형 모형
고객과의 소통을 통하여 계획수립과 위험분석, 구축, 고객 평가의 과정을 거쳐 소프트웨어를 개발하는 방식. 복잡한 개발에서 위험 요소를 분석하고 해결할 수 있도록 지원하는 모델

점진적으로 개발과정이 반복된다.

비용과 시간이 많이 들어 대규모 시스템에 알맞다.

키워드는 위험분석

계획 -> 위험 분석 -> 개발 -> 평가 를 반복

요구사항 추가 가능, 유지보수 과정이 필요없다

## 애자일
고객과의 소통에 초점을 맞춘 방법론이다.

요구사항을 받아 우선순위를 부여

개인 상호작용에 가치를 둔다.

짧은 개발 주기를 반복한다.

문서화 보다는 실행sw 에 가치를 둔다.

고객과 협업에 가치를 두고 변화에 대응하는 것에 가치를 둔다.

애자일 12가지 실행지침 
* 고객만족
* 요구사항 적극수용
* 매주 브리핑
* 고객과 개발자가 함께 일함
* 얼굴을 맞대고 의견교환
* 작동하는 sw로 진행상황 
* 설계 중요
* 단순화
* 정기적으로 팀원간 브리핑

## 스크럼 기법
애자일 기반, 팀이 중심이 되어 개발의 효율성을 높임

팀원 스스로 팀을 구성, 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 함

스크럼 팀은 제품 책임자, 스크럼 마스터, 개발팀으로 구성

제품 책임자
* 이해관계자 중 이해도가 높고, 요구사항 책임, 의사 결정할 사람, 주로 개발 의뢰자나 사용자
* 이해관계자들의 의견을 종합하여 제품에 관한 요구사항을 작성
* 백로그 작성하고 우선순위 지정, 팀원들은 우선순위 수정 불가
* 테스트를 수행하며 주기적으로 요구사항 우선순위 갱신

스크럼 마스터
* 스크럼 팀이 작동하도록 조언을 하는 가이드
* 일일 회의 주관하여 진행 사항을 점검하고, 개발 과정에서 발생된 장애 요소를 공론화하여 처리

개발팀
* 제품 책임자와 마스터를 제외한 모든 팀원, 개발자 외에도 디자이너나 테스터 등 모든 사람
* 7 ~ 8 명이 적당

### 스크럼 개발 프로세스
제품 백로그
* 제품 개발에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록
* 지속적으로 업데이트된다
* 백로그의 사용자 스토리를 기반으로 릴리즈 계획을 수립한다

스프린트 계획 회의
* 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립한다
* 요구사항을 task 라는 작업 단위로 분할한 후 개발자별로 수행할 작업 목록인 스프린트 백로그를 작성한다

스프린트
* 실제 작업을 진행하는 과정, 2 ~ 4 주 기간 내에서 진행
* 스프린트 백로그에 작성된 태스크를 대상으로 작업 시간을 추정한 후 개발 담당자에게 할당
* 개발자가 원하는 태스크를 직접 선별할 수 있도록 하면 좋다
* 할당된 태스크는 Todo, inprogress, done 의 상태를 갖는다

일일 스크럼 회의
* 모든 팀원이 매일 약속된 시간 약 15분 정도 짧은 시간동안 진행 상황 점검
* 보통 서서 하며, 남은 작업 시간 소멸 차트에 표시
* 스크럼 마스터는 발견된 장애 요소를 해결할 수 있도록 도와줌

스프린트 검토 회의
* 제품이 요구사항에 부합되는지 사용자 포함된 참석자 앞에서 테스팅 수행
* 스프린트의 한 주당 한 시간 내에 진행
* 제품 책임자는 개선할 사항 피드백 후 다음 스프린트에 반영할 수 있도록 제품 백로그 업데이트

스프린트 회고
* 스프린트 주기를 돌아보며 규칙 준수, 개선점 확인
* 스프린트 끝난 시점에 하거나 일정 주기로 수행


# XP(eXtreme Programming)
XP 는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객참가와 개발 과정의 반복을 극대화하여 개발 생산성 향상시키는 방법

짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 개발하는 것이 목적

릴리즈의 기간을 짧게 반복, 고객의 요구사항 반영에 대한 가시성을 높인다

소규모 인원의 프로젝트에 효과적

5가지 핵심 가치
* 의사소통
* 단순성
* 용기
* 존중
* 피드백


## XP 개발 프로세스
사용자 스토리
* 고객의 요구사항을 시나리오로 표현
* 기능 단위로 구성하고, 필요한 경우 간단한 테스트 사항도 기재

릴리즈 계획 수립
* 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 한다
* 부분 혹은 전체 개발 완료 시점에 대한 일정을 수립한다

스파이크
* 요구사항의 신뢰도를 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램
* 처리할 문제 외의 다른 조건은 모두 무시하고 작성한다

이터레이션
* 하나의 릴리즈를 더 세분화 한 단위를 이터레이션이라고 한다
* 일반적으로 1~3주 정도의 기간으로 진행된다
* 이 기간 중에 새로운 스토리가 작성될 수 있으며, 작성된 스토리는 진행 중인 이터레이션 혹은 다음 이터레이션에 포함될 수 있다

승인 검사
* 하나의 이터레이션 안에서 계획된 릴리즈 단위의 부분 완료 제품이 구현되면 수행하는 테스트
* 사용자 스토리 작성 시 함께 기재한 테스트 사항에 대해 고객이 직접 수행
* 테스트 과정에서 발견한 오류사항은 다음 이터레이션에 포함
* 테스트 이후 새로운 요구사항이 작성되거나 요구사항의 상대적 우선순위가 변경될 수 있다
* 테스트가 완료되면 다음 이터레이션을 진행한다

소규모 릴리즈
* 릴리즈를 소규모로 하게 되면, 고객의 반응을 기능별로 확인할 수 있어, 고객의 요구사항에 좀 더 유연하게 대응할 수 있다
* 계획된 릴리즈 기간 동안 진행된 이터레이션이 모두 완료되면 고객에 의한 최종 테스트를 수행한 후 릴리즈, 즉 최종 결과물을 고객에게 전달한다
* 릴리즈가 최종 완제품이 아닌 경우 다음 릴리즈 일정에 맞게 개발을 계속 진행한다

## XP의 주요 실천방법
* Pair Programming : 다른 사람과 프로그래밍 하는 것
* Collective Ownership : 개발 코드에 대한 권한과 책임을 공동 소유
* Test-Driven Development : 테스트 주도 개발
* Whole Team : 전체 팀이 각자 역할
* Continuous Integratio : 모듈 게속적 통합
* Design Improvement : 리펙토링
* Small Releases : 짧은 릴리즈


# 현행 시스템 파악
새로 개발하는 시스템의 개발 범위를 명확히 설정하기 위해 현행 시스템의 구성과 제공 기능, 시스템 간의 전달 정보, 사용되는 기술 요소, 소프트웨어, 하드웨어, 네트워크의 구성 등을 파악한다

## 현행 시스템 파악절차
* 1단계 : 시스템 구성, 기능, 인터페이스 파악
* 2단계 : 아키텍처 구성, 소프트웨어 구성 파악
* 3단계 : 하드웨어 구성, 네트워크 구성 파악

## 시스템 구성 파악
조직의 주요 업무를 담당하는 **기간 업무**와, 이를 지원하는 **지원 업무**로 구분하여 기술

단위업무의 명칭, 주요 기능들 명시

## 시스템 기능 파악
기능을 주요기능, 하부기능, 세부기능으로 구분하여 계층형으로 표시

## 시스템 인터페이스 파악
시스템간 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시한다

통신규약 같은것도

## 아키텍처 구성 파악
업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도

## 소프트웨어 구성 파악 
소프트웨어 제품명 용도 라이선스 적용 방식, 라이선수 수 등 명시

상용 소프트웨어의 경우 라이선스 적용 방식의 기준과 보유한 라이선스의 파악이 중요

aws, mysql, sage, oracle, window 등등

## 하드웨어 구성 파악
서버의 사양과 수량, 이중화의 적용 여부

## 네트워크 구성 파악
네트워크 구성도, 보안 취약성 분석

장애가 발생한 경우 발생 원인을 찾아 복구하는 용도로 활용

# 개발 기술 환경 파악
## 개발 기술 환경의 정의
운영체제, DBMS, 미들웨어 등을 선정할 때 고려해야 할 사항을 기술, 오픈 소스 사용 시 주의해야 할 내용을 제시

## 운영체제
컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환령을 제공하는 소프트웨어

## 운영체제 식별 시 고려사항
가용성, 성능, 기술 지원, 주변 기기, 구축 비용

## 데이터베이스 관리 시스템
가용성, 성능, 기술지원, 상호호환성, 구축비용

## WAS
사용자의 요구에 따라 변하는 동적 컨텐츠를 처리하기 위해 사용되는 미들웨어

가용성, 성능, 기술지원, 구축비용

# 요구사항 정의
요구사항은 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 제약조건 등

소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거 제공

의사소통 원할, 잘 정의해야 함

## 요구사항 유형
기술하는 내용에 따라 기능 요구사항과 비기능 요구사항으로 나뉨

기술관점과 대상의 범위에 따라 시스템 요구사항과 사용자 요구사항으로 나뉨

* 기능 요구사항
    * 시스템이 무엇을 하는지, 어떤 것을 입출력 하는지, 수행해야 하는 기능
* 비기능 요구사항
    * 시스템 장비구성
    * 성능, 인터페이스
    * 데이터 요구사항
    * 테스트, 보안, 품질
    * 제약사항
    * 등등

* 사용자 요구사항
    * 사용자 관점에서 본 시스템이 제공해야 할 요구사항
    * 사용자를 위한 것으로 친숙한 표현으로 이해하기 쉽게 작성된다
* 시스템 요구사항
    * 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항
    * 전문적이고 기술적인 용어로 표현됨
    * 소프트웨어 요구사항이라고도 한다

## 요구사항 개발 프로세스
개발 대상에 대한 요구사항을 체계적으로 도출하고 분석한 후 분석 결과를 명세서에 정리한 다음 마지막으로 이를 확인 및 검증하는 일련의 구조화된 활동

도출 -> 분석 -> 명세 -> 확인

## 요구사항 도출
사용자나 시스템 등 관련자들이 의견 교환하여 요구사항 어딨는지, 어떻게 수집할건지 식별하고 이해하는 과정

요구사항 도출은 지속적으로 반복

청취나 인터뷰, 브레인스토밍 등등

## 요구사항 분석
분석과 중재 기술

명확하지 않거나 모호한 것 발견 걸러냄


## 요구사항 명세
관찰 및 모델 작성

모델작성 문서화

## 요구사항 검증(확인)
확인, 검증

# 요구사항 분석
소프트웨어 개발의 실질적인 첫 단계로 사용자의 요구사항을 이해하고 문서화하는 활동

일정이나 비용의 타당성, 제약 설정

요구 추출, 해결법 결정

문서화

## 구조적 분석 기법
자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법

* 도형 중심의 분석도구
* 도형 중심의 도구라 사용자와 분석가 간의 대화가 용이
* 하향식 방법을 사용하여 시스템 세분화, 분석의 중복 배제
* 논리적 일관성, 자료 흐름도, 자료 사전, 소단위 명세서, 상태 전이도 등등 사용한다
    * 구자자소개상

## 자료 흐름도
자료의 흐름이나 기능 등을 도형으로 나타낸 것

* 프로세스(process) : 처리 변경
* 자료 흐름(data flow) : 흐름
* 자료 저장소(data store) : 저장
* 단말(Terminator) : 출력 입력
* 프자자단

## 자료 사전
자료 흐름도의 자료를 자세히 정의하고 기록

메타 데이터
* = : 정의
* ```+```: 연결
* () : 생략
* [|] : 선택
* {} : 반복
* ** : 설명

# 요구사항 분석 case
요구사항 분석을 위한 CASE(자동화 도구)

자동으로 분석하고 명세서 기술하도록 개발된 도구

SADT
SREM
RSL
PSL/PSA
TAGS

# Hipo
시스템 분석 설계나 문서화 시 사용되는 기법, 시스템 입력, 처리, 출력의 기능을 나타냄

* 가시적 도표 : 시스템의 전체적인 기능과 흐름을 보여주는 계층 구조도
* 총체적 도표 : 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공
* 세부적 도표 : 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

# UML(unified modeling language)
의사소통이 원할이 이뤄지도록 표준화한 표현법, 대표적인 객체지향 모델링 언어

사물(things), 관계(relationship), 다이어그램(diagram) 등이 있다

## 사물(things)
모델을 구성하는 가장 중요한 기본 요소, 객체

* 구조 : 클래스, 컴포넌트
* 행동 : 관계
* 그룹 : 패키지
* 주해 : 주석

## 관계
연관성

* 연관관계 association
    * 서로 연관된 것
    * 실선
    * 관계에 참여하는 객체 개수 표시
* 집합관계 aggregation
    * 포함
    * 포함하는 쪽이 마름모 가짐
    * 서로 독립적 이지만 종속적
* 포함관계 composistion
    * 영향을 미친다
    * 특이한 집합관계
    * 생명주기를 함께한다
    * 포함하는 쪽으로 꽉찬 마름모
* 일반화 normalization
    * 자식같은 것
    * 하위 개념
    * 상위로 빈 화살표
* 의존관계 dependency
    * 연관은 있으나 필요에 의해 서로에 영향을 주는 짧은 시간 동안만 연관을 유지
    * 할인율, 등급 관계 등
    * 하나가 다른 하나를 매개변수로 사용하는 관계
    * 주는 쪽에서 받는 쪽으로 점선 화살표
* 실체화관계 realization
    * 기능, 인터페이스
    * 점선
    * 구현체에서 기능으로 점선 화살표

## 다이어그램 **
사물과 관계를 도형으로 표현

구조적 다이어그램
* 클래스 다이어그램 class
    * 클래스와 클래스 속성 클래스 사이의 관계
* 객체 다이어그램 object
    * 인스턴스를 특정 시점의 객체와 객체 사이의 관계
    * 럼바우 객체지향 분석 기법에서 객체 모델링에 활용
* 컴포넌트 다이어그램 component
    * 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
* 배치 다이어그램 deployment
    * 결과물, 프로세스 등 물리적 요소들의 위치 표현
    * 노드와 통신 경로로 표현
    * 구현 단계에서 사용한다
* 복합체 구조 다이어그램 composite structure diagram
    * 클래스나 컴포넌트가 복합 구조를 갖는 경우 내부 구조 표현
* 패키지 다이어그램 package
    * 패키지간의 관계

행위 다이어그램
* 유스케이스 다이어그램 use case
    * 요구 분석 모델링 작업에 사용
    * 사용자와 사용 사례로 구성
* 시퀀스 다이어그램 sequence
    * 상호 작용하는 시스템이나 객체들이 주고받는 메시지 표현
* 커뮤니케이션 다이어그램 communication
    * 객체들이 주고받는 메시지 + 객체 관계
* 상태 다이어그램 state
    * 객체 변화에 따른 다른 객체 변화
    * 럼바우
* 활동 다이어그램 activity
    * 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름
* 상호작용 개요 다이어그램 intreation overview
    * 상호작용 다이어그램 간의 제어 흐름을 표현
* 타이밍 다이어그램 timing
    * 객체 상태 변화와 시간 제약을 명시적으로 표현

스테레오 타입
``<<>>``
UML 기본 기능 외의 추가적인 기능 표현


# 주요 다이어그램
## use case 다이어그램
이 시스템을 통해 할 수 있는 것을 사용자 관점에서 표현

* system scope : 시스템 내부에서 수행되는 기능들을 외부와 구분하는 것
* actor : 시스템과 상호작용하는 모든 요소, 
    * 주액터 : 시스템 사용 이득얻는 대상, 사람
    * 부액터 : 주액터 달성을 위해 서비스를 제공하는 외부 시스템, 기관이나 조직
* use case : 사용자가 보는 관점에서 표현한 것
* relationship : 액터와 유스케이스, 유스케이스와 유스케이스 간의 관게, 포함 확장 일반화

## class 다이어그램
클래스의 속성과 오퍼레이션, 이 들 사이의 관계

문서화하는데 사용

객체 속성이나 함수 정보 잘 표현

클래스 제약조건 관계로 구성

클래스
* 속성과 동작
* 이름, 속성, 오퍼레이션(메소드)

제약조건
* 조건

관계
* 클래스 사이의 연관성

## 시퀀스 다이어그램
객체가 시간의 흐름에 따라 상호작용하는 과정을 액터 객체 메시지 등의 요소를 사용하여 그림으로 표현한 것

객체들 상호작용하며 주고받는 메시지

구성요소
* 액터 : 서비스를 요청하는 외부요소
* 객체 : 메시지를 주고받는 주체
* 생명선 : 객체가 메모리에 존재하는 기간, 라이프사이클
* 실행 상자 : 객체가 메시지를 주고받으며 구동되고 있음을 표현함
* 메시지 : 객체가 상호 작용을 위해 주고받는 메시지


# 화면 설계 
# 사용자 인터페이스(UI)
사용자와 시스템 간의 상호작용이 원할하게 이뤄지도록 도와주는 장치나 소프트웨어

## 특징
편하고 좋고 매개체 

## 구분
* CLI(Command line) : 명령과 출력이 텍스트
* GUI(graphical user) : 아이콘이나 메뉴 를 마우스로
* NUI(natural user) : 사용자의 말이나 행동

## UI 기본원칙 **
* 직관성 : 누구나 사용 가능
* 유효성 : 정확하고 완벽하게 달성
* 학습성 : 쉽게 배우고 익힐 수 있다
* 유연성 : 요구사항을 최대한 수용하고, 실수를 최소화해야 한다

## UI 설계 지침
* 사용자 중심
* 일관성
* 단순성
* 결과 예측 가능
* 가시성
* 표준화
* 접근성
* 명확성
* 오류 발생 해결

## UI 개발 시스템의 기능
UI 개발 시스템이 가져야 할 기능
* 사용자의 입력을 검증할 수 있어야 한다
* 에러 처리와 그와 관련된 에러 메시지를 표현할 수 있어야 한다
* 도움과 프롬프트를 제공해야 한다

# UI 설계 도구
설계에 사용하는 도구 결과를 미리 보여준다

## 와이어프레임
기획 초기, 페이지에 대한 개략적인 레이아웃이나 UI 요소의 뼈대

개발자와 디자이너가 협의하거나 현재 진행 상태 등을 공유하기 위해 사용

## MockUp
좀 더 실제 화면과 유사하게 만든 정적인 행태의 모형

## 스토리보드
와이어프레임에 추가적인 설명

디자이너와 개발자가 최종적으로 참고하는 작업 지침서

## 프로토타입
UI 를 통해 간단한 작동 구현, 동적인 모형

## 유스케이스
사용자 측면의 요구사항

사용자의 목표를 달성하기 위해 수행할 내용을 기술

# 품질 요구사항
품질은 소프트웨어 요구사항이 얼만나 충족되는가 

ISO/IEC 9126
* 소프트웨어의 품질 특성과 평가를 위한 표준 지침
* 특성
    * 기능성 : 적절, 적합, 정밀, 보안, 준수 등
    * 신뢰성 : 성숙성, 고장 허용성, 회복성
    * 사용성 : 이해성, 학습성, 운용성..
    * 효율성 : 시간 효율성, 자원 효율성
    * 유지 보수성 : 분석성, 변경성, 안정성, 시험성

## 기능성
요구사항을 만족하는 기능을 제공하는지

* 적절성/적합성 : 적절한 기능을 제공하는지
* 정밀성/정확성 : 요구하는 결과를 정확하게 산출하는지
* 상호 운용성 : 다른 시스템과 서로 어울려 작업하는 능력
* 보안성 : 정보에 대한 접근을 권한에 따라 허용하거나 차단할 수 있는 능력
* 준수성 : 표준, 관례 준수

## 신뢰성
일관되게 기능 제공

* 성숙성 : 결함으로 인한 고장을 피해갈 수 있는 능력
* 고장 허용성 : 결함에도 규성된 성능 수준 유지
* 회복성 : 고장나도 복구할 수 있는 거

## 사용성
쉽게 배우고 사용, 다시 사용하고 싶은 정도

* 이해성 : 소프트웨어의 적합성, 사용 방법등을 사용자가 이해할 수 있는 능력
* 학습성 : 사용법 학습능력
* 운용성 : 사용자가 소프트웨어 운용, 제어
* 친밀성 : 사용자가 소프트웨어 다시 사용하고 싶게 만드는 능력

## 효율성
한정된 자원, 속도

* 시간 효율성
* 자원 효율성

## 유지 보수성
변화나 새로운 요구사항에 확장할 수 있는 정도

* 분석성 : 결함이나 고장의 원인, 수정될 부분들을 식별하는 능력
* 변경성 : 변화 쉽게 구현
* 안정성 : 변화로 인한 예상치 못한 결과 최소화
* 시험성 : 변경이 검증될 수 있는 능력

## 이식성
다른 환경에서 적용

* 적용성 : 다른 환경으로 변경될 수 있는 능력
* 설치성 : 임의의 환경에 설치
* 대체성 : 동일한 목적을 위해 다른 소프트웨어 대신 사용
* 공존성 : 자원을 공유하는 환경에서 다른 소프트웨어와 공존할 수 있는 능력


# 3장 애플리케이션 설계
# 소프트웨어 아키텍처
소프트웨어의 골격이 되는 기본 구조

기본 원리로 모듈화, 추상화, 단계적 분해, 정보은닉이 있다

설계 단계는 상위설계와 하위설계로 구분할 수 있다

상위설계
* 아키텍처, 예비설계
* 전체적 구조
* DB, 인터페이스, 구조

하위설계
* 모듈, 상세
* 내부 구조 및 행위
* 컴포넌트, 자료 구조, 알고리즘

## 모듈화
소프트웨어의 기능들을 모듈 단위로 나누는 것

모듈이란 특정 기능을 처리할 수 있는 소스 코드

자주 사용하는 것은 공통 모듈로

## 추상화
문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것

유사한 것 만들어서 테스트하거나 하는 것

추상화의 유형
* 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체
* 과정 추상화 : 수행과정 정의 안함, 전반적 흐름만 파악할 수 있게 설계
* 데이터 추상화 : 세부적 속성이나 용도 정의 안함
제과자

## 단계적 분해
niklaus wirth 에 의해 제안된 하향식 설계 전략으로 문제를 상위에서 하위로 구체화

추상화의 반복에 의해 세분화

## 정보 은닉
모듈 내부는 감춰저 다른 모듈이 접근하거나 변경하지 못함

유지보수 용이해짐

## 소프트웨어 아키텍처의 품질 속성
품질 평가를 위한 품질 평가 요소들

시스템 측면
* 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성 등등

비즈니스 측면
* 시장 용이성, 비용과 혜택
* 예상 시스템 수명
* 기타 속성

아키텍처 측면
* 개념적 무결성
* 정확성, 완결성, 구축 가능성

## 협약에 의한 설계
소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세

포함될 조건에는 선행, 결과, 불변 조건이 있다

# 아키텍처 패턴
아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

시간도 단축시키고 의사소통도 좋아지고 좋다

레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, MVC 패턴 등이 있다

## 레이어 패턴
계층 구분하는 것

## 클라이언트 서버 패턴
서버와 클라이언트

## 파이프 필터 패턴
데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴

필터는 재사용성이 좋고 추가가 용이

필터를 재배치하여 다양한 파이프라인 구축 가능

데이터 변환, 버퍼링 등에 주로 사용

## MVC 패턴
알지?

# 객체지향
현실 세계의 개체를 하나의 객체로 만들어 프로그래밍

객체 클래스 캡슐화 상속 다형성 연관성

## 객체
데이터와 함수를 묶은 모듈

상태를 가지고, 관계가 있고, 그렇다

## 클래스
공통된 속성과 연산을 갖는 객체의 집합, 객체의 타입

각각의 객체들이 갖는 속성과 연산을 정의하는 틀

클래스에 속한 각각의 객체를 인스턴스, 클래스로부터 객체를 생성하는 것을 인스턴스화라고 한다

## 캡슐화
데이터와 함수를 하나로 묶는 것

정보은닉

## 상속
상위클래스의 모든 속성을 하위클래스로 물려줌

다중 상속, 한 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것

## 다형성
하나의 메시지에 대해 클래스에 따라 고유한 방법으로 응답

## 연관성
객체들은 서로 관계를 갖는다

* 연관화(association) : 2개 이상의 객체가 상호 관련됨
* 분류화(classfication) : 동일한 형의 특성을 갖는 객체들을 모아 구성
* 집단화(aggregation) : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성
* 일반화(generalization) : 공통적인 성질로 추상화한 상위 객체 구성
* 특수화(specialization) : 상위 객체를 구성화하여 하위 객체를 구성

# 객체지향 분석 및 설계
OOA 객체지향 분석, 사용자의 요구사항을 분석하여 

클래스와, 속성과 연산, 그들 간의 관계 등을 정의하여 모델링하는 작업

## 객체지향 분석 방법론
* Rumbaugh : 분석 활동을 객체, 동적, 기능 모델로 나누어 수행
* Booch : 미시적 개발 프로세스와 거시적 개발 프로세스 모두 사용, 클래스 객체를 분석 및 식별하고 클래스의 속성과 연산을 정의
* Jacobson : Use Case 강조
* Coad와 Yourdon 방법 : E-R 다이어그램을 사용하여 객체의 행위를 모델링
* Wirfs-Brock : 분석 설계 구분이 없다

## 럼바우의 분석 기법 **
모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링

객체 모델링 -> 동작 모델링 -> 기능 모델링 순으로 진행

* 객체 모델링
    * 객체를 찾아 속성과 연산과 관계 식별하여 객체 다이어그램으로 표시
* 동적 모델링
    * 상태 다이어그램을 이용하여 시간에 따른 객체의 흐름 등 동적인 행위 표현
* 기능 모델링
    * 자료 흐름도를 이용하여 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현

## 객체지향 설계 원칙
SOLID

* 단일 책임
* 개방 폐쇄 : 변경에는 유현, 캡슐화
* 리스코프 치환 : 자식은 부모의 역할 다 해야하고, 부모의 역할을 무시하거나 재정의하면 안됨
* 인터페이스 분리 원칙 : 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 미치면 안됨
* 의존 역전 원칙 : 추상성이 높은 객체와 관계를 맺어야 한다는 원칙

# 모듈
시스템의 각 기능들

단독으로 컴파일 가능, 재사용 가능

독립성이 높아야 하고 높기 위해서 결합도 낮고 응집도 높고

## 결합도
모듈 간의 상호 의존하는 정도

* data coupling 
    * 모듈 간 인터페이스가 자료 요소로만 구성될 때 결합도
    * 호출하며 인수로 필요한 자료 넘겨주는 것
    * 변경이 전혀 영향을 미치지 않는다
* 스탬프 결합도
    * 인터페이스롤 배열 등 자료구조가 전달될 때
    * 자료구조의 변화에 영향을 미침
* 제어 결합도
    * 한 모듈이 다른 모듈을 제어하기 위해 제어 신호를 이용해 통신하거나, flag, switch 등 제어요소를 전달
    * 한 모듈이 다른 모듈의 처리 절차를 알아야 한다
    * 하위 모듈이 상위 모듈에 처리 명령을 전달하는 권리 제어현상이 발생
* 외부 결합도
    * 어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때
    * 참조되는 데이터 범위를 각 모듈에서 제한 가능
* 공통 결합도
    * 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도
    * 공통 데이터 영역을 조금만 수정해도 모든 모듈에 영향을 미치므로 독립성이 약해짐
* 내용 결합도
    * 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도
    * 한 모듈에서 다른 모듈의 내부로 제어가 이동하는 경우도 포함

## 응집도
정보 은닉의 개념을 확장한 것으로 내부 요소들의 서로 연관된 정도

* 기능적 응집도 : 모든 기능 요소들이 단일 문제와 연관되어 수행
* 순차적 응집도 : 모듈 내의 활동으로부터 나온 출력 데이터를 그 다음  활동의 입력 데이터로 사용
* 교환적(Communication) 응집도 : 동일한 입출력을 사용하여 서로 다른 기능을 수행
* 절차적(procedural) 응집도 : 모듈이 다수의 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우의 응집도
* 시간적(Temporal) 응집도 : 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도
* 논리적(Logical) 응집도 : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도
* 우연적(coincidental) 응집도 : 묘듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우

## 팬인(Fan-In)/팬아웃(Fan-out)
팬인은 어떤 모듈을 제어하는 모듈의 수

팬아웃은 어떤 모듈에 의해 제어되는 모듈의 수

인아웃을 분석하여 시스템의 복잡도를 알 수 있다

팬인이 높으면 재사용 측면에서 설계가 잘 되어있지만 단일 장애점 발생가능 하므로 중점 관리 필요

팬아웃이 높은 경우 불필요하게 다른 모듈을 호출하고 있는지 검토 필요

## N-S 차트
논리의 기술에 중점을 둔 도형을 이요한 표현 방법
* 연속 선택 및 다중 선택 반복 등의 제어 논리 구조를 표현
* GOTO 사용안함
* 선택과 반복구조를 시각적으로 표현
* 이해하기 쉽고, 코드 변환이 용이
* 총체적 구조 표현과 인터페이스를 나타내기 어려움
* 단일 입구 단일 출구

# 공통 모듈
여러 프로그램에서 공통적으로 사용할 수 있는 모듈

인증이나 계산같은 것

공통 모듈 구현시 명세 기법 준수해야 함

* 정확성 : 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 명확히 표시
* 명확성 : 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성한다
* 완전성 : 시스템 구현을 위해 필요한 모든 것을 기술한다
* 일관성 : 공통 기능들 간 상호 충돌이 발생하지 않도록 작성
* 추적성 : 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 한다

## 재사용
재사용은 이미 개발된 기능 파악해 재구성하여 새로운 시스템이나 기능에 넣을 수 있게 최적화하는 것

결합도는 낮고 응집도는 높아야 함

규모에 따른 분류
* 함수와 객체 : 클래스나 메소드 단위의 코드 재사용
* 컴포넌트 : 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식
* 애플리케이션 : 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식

## 효과적인 모듈 설계 방안
* 결합도 줄이고 응집도 늘리기
* 복잡도와 중복성 줄이고 일관성 유지
* 모듈 크기는 작게
* 하나의 입구와 하나의 출구
* 자료 제공

# 코드
기호, ID 같은 것

주민번호 등

기능
* 식별기능 : 데이터 간의 성격에 따라 구분이 가능
* 분류기능 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화
* 배열기능 : 의미를 부여하여 나열
* 표준화기능 : 다양한 데이터를 기준에 맞추어 표현
* 간소화기능 : 복잡한 데이터를 간소화


## 코드의 종류
* 순차 코드(sequence) : 자료의 발생순서, 순서대로 부여
* 블록 코드(block) : 공통성이 있는 것 블록으로 구분, 각 블록 내에서 일렬번호 부여, 과목코드같은 것
* 10진 코드(Demical) : ??? 도서관 도서번호??
* 그룹 분류 코드 : 대 중 소분류, 학번
* 연상 코드 : 이딴거 ㄹ쓰낟고?
* 표의 숫자 코드 : 항목의 성질을 코드에 적용
* 합성 코드 : 여러개 합치는 거

## 코드 부여 체계
이름만으로 개체의 용도와 적용 범위를 알 수 있도록 코드를 부여하는 방식

유일하고, 잘 정리되고, 등등

단계별

# 디자인패턴
코드 칠때 참조하는 전형적인 해결방식 

GoF 라 불리는 4명이 처음으로 구체화 및 체계화

GoF의 디자인 패턴은 많은 디자인패턴 중 일반적인 것 분류해서 정리

생성패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성

## 디자인패턴 장단점
장점 
* 범용적인 코드 스타일로 구조 파악이 용이
* 생산성
* 검증됨
* 원활한 의사소통
* 유연한 대처

단점
* 초기 투자 비용이 부담
* 객체지향 기반이라 다른 기반에는 적합하지 않음

## 생성패턴
객체의 생성과 참조 과정을 캡슐화하여 객체가 생성되거나 변경되어도 프로그램의 구조에 영향을 크게 받지 않도록 하여 프로그램에 유연성을 더함

* 추상 팩토리 : 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 객체들의 그룹으로 생성하여 추상적으로 표현
* 빌더 : 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성, 객체의 생성과 표현 방법을 분리해 동일한 객체 생성에도 다른 결과
* 팩토리 메소드 : 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화
* 프로토타입 : 원본 객체를 복제하는 방법으로 객체를 생성, 비용이 큰 경우 주로 사용
* 싱글톤 : 클래스의 인스턴스가 하나뿐, 여러 프로세스에서 동시 참조 불가

## 구조 패턴
클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴

* 어댑처 : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
* 브리지 : 구현부에서 추상층을  분리하여, 서로가 독립적으로 확장할 수 있도록 구성, 기능과 구현을 두 개의 별도 클래스
* 컴포짓 : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
* 데코레이터 : 객체 간의 결합을 통해 능동적으로 기능을 확장
* Facade : 복잡한 서브 클래스들 위에 상위 인터페이스 구성, 서브 클래스의 기능을 간편하게 사용
* Flyweight : 인스턴스가 필요하면 가능한 공유
* Proxy : 접근을 대신 수행

## 행위 패턴
객체들 상호작용이나 책임 분배 방법을 정의

* 책임 연쇄 : 객체가 둘 이상 있으면 하나가 처리하지 못하면 다음 객체로 
* 커맨드 : 요청을 객체로 캡슐화하여 
* 인터프리터 : 언에에 문법 표현을 정의
* 반복자 : 자료 구조와 같이 접근이 잦은 객체느 동일한 인터페이스 사용
* 중재자 : 객체들 간의 상호작용을 캡슐화하여 객체로 정의 
* 메멘토 : 특정 시점에서 객체 내부 상태를 객체화하여 이전으로 돌아감
* 옵서버 : 한 객체의 상태가 변하면 객체에 상속된 다른 객체들에 변화된 상태를 전파
* 상태 : 객체의 상태에 따라 동일한 동작을 다르게 처리할 때 사용
* 전략 : 동일한 계열을 알고리즘들을 개별적으로 캡슐화하여 상호 교환 가능
* 템플릿 메소드 : 상위 클래스에서 골격을 정의, 하위 클래스에서 세부 처리를 구체화, 유사한 서브클래스를 묶어 상위 클래스에 재정의
* 방문자 : 각 클래스에서 데이터 처리 기능을 별도의 클래스로, 이 클래스가 다른 클래스들을 방문


# 인터페이스 설계

# 인터페이스 요구사항 검증
## 요구사항 검증
사용자의 요구사항이 요구사항 명세서에 정확하게 기술되었는지 확인

설계 및 구현에 발견되면 비용이 커지므로 검증필요

계획 수립 -> 검토 및 오류 수정 -> 베이스라인 설정 순으로 수행한다

## 인터페이스 요구사항 검토 계획 수립
관계자들이 체크리스트 작성

## 인터페이스 요구사항 검토 및 오류 수정
체크리스트 항목에 따라 인터페이스 요구사항 명세서 검토

## 인터페이스 요구사항 베이스라인 설정
공식적 승인 후 설계 및 구현을 위해 명세서 베이스라인 설정

## 요구사항 검증 방법

요구사항 검토 : 검토 당담자들이 명세서 수작업으로 분석
* 동료 검토(peer review) : 작성자가 설명하면 동료가 결함을 발견
* 워크 스루(walk through) : 검토전 명세서를 미리 배포하면 사전검토 후 결함발견
* 인스펙션(inspection) : 작성자를 제외한 다른 검토 전문가들이 명세서를 확인하며 결함을 발견

프로토타이핑
* 견본품

테스트 설계 
* 테스트

CASE 도구 활용
* 일관성 분석을 통해 요구사항 변경사항 추적 관리 등을 확인

## 인터페이스 요구사항 검증의 주요 항목
완정성, 일관성, 명확성, 기능성, 검증가능성, 추적가능성, 변경용이성

# 미들웨어 솔루션 명세
미들웨어 : 미들 + 소프트웨어

클라이언트와 서버가 통신하는데 돕는 중계자들, 다른 기종간 원만한 통신이 이루어지게 하는 것

위치투명성 제공, 실제 위치를 알 필요는 없다, 논리적 명칭만으로 액세스 가능

## DB
ODBC 처럼 원격의 데이터베이스와 연결하기 위한 미들웨어

## RPC(Remote Procedure Call)
원격 프로시저를 로컬 프로시저처럼 호출하는 방식의 미들웨어

## MOM(Message Oreiented Middleware)
Message Q 같은 것, 메시지 기반의 비동기형 메시지를 전달하는 방식의 미들웨어, FCM?

## TP-Monitor(Transaction Processing Monitor)
온라인 트랜잭션 업무에서 트랜잭션 처리 및 감시하는 미들웨어

사용자가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용

## ORB(Object Request Broker)
객체 요청 브로커, 객체 지향 미들웨어로 코바 표준 스펙을 구현한 미들웨어

## WAS
동적 웹 컨텐츠 처리하기 위한 미들웨어, 웹 환경을 구현하기 위한 미들웨어

## 미들웨어 솔루션 식별
확인하고 목록 작성



# 데이터 입.출력 구현

# 자료구조
자료 저장방법, 자료 조직하고 구조화

# 트리
* Preorder : root - left - right
* inorder : left - root - right
* postorder : left - right - root

# 데이터베이스 개요
* 통합 : 중복 배제
* 저장 : 접근가능한 저장됨
* 운영 : 꼭 필요
* 공용 : 여러 시스템이 공동으로 소유

## DBMS 
Definition(테이블 생성), manipulation(CRUD), 제어(보안권한)

## 스키마 
DB 구조를 기술한 메타데이터의 집합

* 외부스키마 : 사용자가 본 DB 논리적 구조
* 개념스키마 : 접근권한, 관계 제약조건, 무결성 규칙에 대한 명세 등
* 내부스키마 : 물리적 저장장치입장에서의 DB 구조

# 제품 소프트웨어 패키징

# 소프트웨어 패키징
실행파일들을 묶어 배포용 설치 파일

소스코드는 모듈화

## 패키징 시 고려사항
사용자가 필요한 저장공간, 성능 등 최소 환경을 정의

내부 콘텐츠에 대한 암호화 및 보안을 고려

DRM(저작권) 고려

## 패키징 작업 순서
패키징 주기는 개발 기법에 따라 달라짐

애자일의 경우 2~4주, 각 주기가 끝날 때마다 패키징


# DRM(Digital Right Management)
디지털 컨텐츠가 저작권가가 의도한 용도로만 사용되도록 생산 유통 이용까지의 전 과정에 활용되는 컨텐츠 관리 미치 및 보호 기술

## 디지털 저작권 관리의 흐름 및 구성요소
* 클리어링 하우스 : 저작권 관리, 결제 등등
* 컨텐츠 제공자 : 라이선스를 클리어링 하우스에 등록
* 패키저 : 컨텐츠를 메타 데이터와 함께 배포가능한 형태로 묶어 암호화
* 컨텐츠 분배자 : 컨텐츠 유통, 앱스토어, 클리어링 하우스에 라이선스 요청
* 컨텐츠소비자 : 컨텐츠 구매 주체, 클리어링 하우스에 요금지불하고 라이선스 발급, 
* DRM 컨트롤러 : 배포된 컨텐츠의 이용 권한을 통제하는 프로그램
* 보안 컨테이너 : 컨텐츠 원본을 안전하게 유통하기 위한 전자적 보안장치

## 디지털 저작권 관리의 기술요소
* Encryption : 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술
* Key management : 키 저장 및 분배
* packeger
* Identification
* Right expression
* Policy Management
* Tamper Resistance(크랙 방지)
* Authentication


# 소프트웨어 패키징 형상관리
형상관리는 소프트웨어 개발 과정에서 변경사항 관리하기 위한 활동

## 중요성
무절제한 변경 방지, 추적, 가시성, 관리, 여러 명의 개발자 동시에 개발

## 형상 관리 기능
* 형상식별 : 관리번호, 트리구조로 구분 
* 버전제어 : 
* 형상통제 : 변경 요구 검토
* 형상감사 : 무결성 확인하여 승인
* 형상기록 : 기록

## 주요 기능
* repository : 저장소
* import : 저장소에 처음 푸시
* checkout : 수정을 위해 저장소에서 받아옴
* checkin : 수정 후 저장소 갱신
* commit : 여러 checkin 의 경우 충돌확인 후 diff 사용해서 충돌부분 보여줌
* update : 로컬을 최신으로 동기화

# 소프트웨어 버전 관리 도구
## 공유 폴더 방식
로컬 컴퓨터의 공유 폴더에 저장되어 관리

개발자가 개발이 완료된 파일을 약속된 공유 폴더에 매일 복사

SCCS 등등

## 클라이언트/서버 방식
버전 관리 자료가 중앙 시스템에서만 저장되어 관리되는 방식

## 분산 저장소 방식
버전 관리를 로컬과 서버에서 함께 수행


# 애플리케이션 테스트
validation 하고 verification 한지 확인하고 찾아내는 것

* validation : 사용자 입장에서 요구사항에 부합한지
* verification : 개발자 입장에서 명세서에 맞게 만들어졌는지


## 애플리케이션 테스트의 기본원리
* 완벽한 테스트는 불가
* 20%의 코드에서 80%의 문제 발생
* 테스트케이스는 게속 보완해야 함
* 테스트는 개발자와 관계없는 별도의 팀에서 수행해야 한다
* 테스트는 작은 부분에서 점점 확대


# 애플리케이션 테스트의 분류
* 정적 테스트 : 실행하지 않고 소스 코드나 명세서를 대상으로 분석, 초기에 결합 발견 가능
* 동적 테스트 : 실행하여 오류 찾는다, 전 단계에서 가능, 블랙박스 테스트 화이트박스 테스트

## 테스트기반에 따른 테스트
* 명세 기반 테스트 : 사용자의 요구사항 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트
* 구조 기반 테스트 : 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트
* 경험 기반 테스트 : 테스터 경험 기반 테스트, 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 사용

## 시각에 따른 테스트
* 검증(verification) : 개발자가의 시각에서 제품의 생산과정을 테스트
* 확인(validation) : 사용자의 시각에서 제푸므이 결과를 테스트

## 목적에 따른 테스트
무엇을 목적으로 테스트를 진행하는지

* 회복 : 결함을 준 후 복구되는지
* 안전 : 보안
* stress : 트래픽
* performance : 성능 효율성
* structure : 내부 코드 복잡도
* regression : 변경 또는 수정된 코드에 새로운 결함이 없음을 확인
* parallel : 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교

# 테스트 기법에 따른 애플리케이션 테스트
## 화이트박스 테스트
* 기초 경로 검사
    * 대표적인 화이트박스 테스트 기법
    * ??? 실행 경로의 기초를 정의하는 지침
* 제어 구조 검사
    * 조건 검사 : 모듈 내의 논리적 조건을 테스트하는 테스트 케이스 설계 기법
    * 루프 검사 : 프로그램의 반복 구조에 초점을 맞춰 실시하는 테케 설계 기법
    * 데이터 흐름 검사 : 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테케 설계 기법

## 화이트박스 테스트의 검증 기준
* 문장 검증 기준 : 소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스 설계
* 분기 검증 기준 : 결정 검증 기준이라고도 불리며, 소스 코드의 모든 조건문에 대해 조건이 True 인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계
* 조건 검증 기준 : 소스 코드의 조건문에 포함된 개별 조건식의 결과가 True 인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스 설계
* 분기/조건 기준 : 분기와 조건 검증을 모두 만족하는 설계, 조건문이 True 인 경우와 False 인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스 설계

## 블랙박스 테스트
각 기능이 완전히 작동되는 것을 입증하는 테스트

누락되거나 부정확하거나 등등 발견하기 위해 사용

동치분할검사, 경계값 분석, 원인-효과 그래프 검사, 오류 예측 검사, 비교 검사 등이 있따

* Equivalence Partitioning Testing, 동치 분할 검사
    * 입력 자료에 맞춰 테스트 케이스 만들고 검사
    * 타당한 입력과 타당하지 않은 입력의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법
* 경계값 분석
    * 입력 자료에만 치중한 동치 분할 기법을 보오나하기 위한 기법
    * 입력조건의 중앙값보다 경계값에서 오류가 발생할 확율이 높으니 경계값을 테스트 케이스로 선정
* 원인-효과 그래프 검사
    * 오류 날만한 점 찾아서 효용성 높은 테스트 케이스 선정
* 오류 예측 검사 
    * 개인적인 경험에 빗대어 테스트하는 보충적 기법, 데이터 확인 검사라고도 함
* 비교 검사
    * 여러 버젼의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트

# 개발 단계에 따른 애플리케이션 테스트
개발단계와 테스트단계의 관계를 연결하여 표현한 V-모델

요구사항, 분석 설계, 구현 -> 단위테스트, 통합테스트, 시스템테스트, 인수 테스트

## 단위 테스트
코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트

사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선

알고리즘 오류에 따른 원치 않는 결과 등등 검출 가능

* 구조 기반 테스트 
    * 프로그램 내부 구조 및 복잡도를 검증하는 화이트박스 테스트 시행
* 명세 기반 테스트 
    * 목적 및 실행 코드 기반의 블랙박스 테스트 시행

## 통합 테스트
단위 테스트가 완료된 모듈들 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트

모듈이나 통합된 컴포넌트 간의 상호 작용 오류를 검사한다

## 시스템 테스트
개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽히 동작하는지

최대한 사용 환경과 유사하게 만든 후 진행

* 기능적 요구사항 : 명세서, 비즈니스 절차, 유스케이스 등 명세서 기반의 블랙박스 테스트
* 비기능적 요구사항 : 성능, 회복 보안 등 구조적 요소에 대한 화이트박스 테스트 

## 인수 테스트
사용자 요구사항 충족하는지

사용자가 직접 테스트

* 사용자 인수 테스트 : 사용자가 시스템 사용의 적절성 여부를 확인
* 운영상의 인수 테스트 : 관리자가 시스템 인수시 수행하는 테스트, 백업복원, 재난 복구 등 확인
* 계약 인수 테스트 : 계약상의 인수/검수 조건을 준수하는지 여부를 확인
* 규정 인수 테스트 : 소프트웨어가 규정에 맞게 개발되었는지 확인
* 알파 테스트 : 개발자앞에서 사용자가 테스트, 
* 베타 테스트 : 사용자 앞에서 최종 사용자가 테스트, 실제 사용

# 통합 테스트
테스트가 끝난 모듈을 통합할 때 하는 테스트

* 비점진적 : 단계적 통합 절차 없이 다 통합하고 테스트하는 것
* 짐진적 통합 방식 : 개별 모듈을 테스트하면서 통합하는 방법

## 하향식 통합 테스트
상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트

주요 제어 모듈을 기준으로 아래 단계로 통합하며 테스트 깊이 우선이나 넓이 우선으로 테스트

테스트 초기부터 사용자에게 시스템 구조를 보여줄 수 있다

상위 모듈에서는 테스트케이스를 사용하기 어렵다

하향식 통합 방법은 다음과 같은 절차로 수행

1. 주요 제어 모듈은 작성된  프로그램으로 실행, 하위 모듈은 stub으로 대체
2. 깊이 우선 또는 넓이 우선으로 하위 모듈 stub에서 실제 모듈로
3. 모듈 통합마다 테스트
4. 회귀 테스트

## 상향식 통합 테스트
하위에서 상위모듈로 

stub은 필요없다, 대신 cruster클러스터가 필요

1. 하위 모듈을 클러스터로 결합
2. 상위 모듈에서 데이터 입출력을 확인하기 위해 더미 모듈인 드라이버 작성
3. 통합된 클러스터 단위로 테스트
4. 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체

## 회귀 테스팅
혹시 다른 오류 생겼나 다시 테스트

# 테스트 오라클
테스트 결과가 올바른지 판단을 위해 사전에 정의된 참 값을 대입하여 비교하는 기법 및 활동

참, 샘플링, 추정, 일관성 검사

# 테스트 자동화
휴먼에러를 줄일 수 있다

테스트품질 향상 등등 이점

## 테스트 자동화 도구의 유형
유형에 따라 다음과 같이 분류

* 정적 분석 도구 
    * 실행하지 않고 분석, 테스트를 수행하는 사람이 소스코드를 이해해야 가능
* 테스트케이스 생성 도구
    * 자료 흐름도 : 자료 원시 프로그램 입력받아 파싱한 후 자료 흐름도 작성
    * 기능 테스트 : 주어진 기능을 구동시키는 모든 가능한 상태를 파악하여 입력작성
    * 입력 도메인 분석 : 원시 코드의 내부를 참조하지 않고, 입력 변수의 도메인을 분석하여 테스트 데이터 작성
    * 랜덤 테스트 : 입력 값을 무작위로 추출하여 테스트
* 테스트 실행 도구
    * 스크립트 언어를 사용하여 테스트를 실행
* 성능 테스트 도구
    * 처리량, 응답 시간 등을 인위적으로 만들어 성능 확인
* 테스트 통제 도구
    * 테스트 계획 수행 결함관리 등을 수행함, 형상관리도구, 결함 추적 도구 등이 있다
* 테스트 하네스 도구
    * 테스트하는 환경의 일부분, 테스트를 지원하기 위해 생긴 코드와 데이터

# 애플리케이션 성능 분석
성능측정지표
* 처리량 : 일정 시간 내에 애플리케이션이 처리하는 일의 양
* 응답 시간 : 요청 응답까지 걸린 시간
* 경과 시간 : 작업걸린시간
* 자원 사용률 : CPU 사용량


## 성능 테스트 도구
성능 점검을 위해 부하나 스트레스를 가하며 성능측정

# 복잡도
## 시간 복잡도
수행시간 수치화

빅오, 세타, 오메가

각각 최악, 평균, 최상 표기

## 순환 복잡도
프로그램의 논리적인 복잡도 측정을 위한 소프트웨어

# 애플리케이션 성능 개선
## 소스 코드 최적화
* 클린 코드 : 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순 명료한 코드
* 나쁜 코드 : 복잡하고 이해하기 힘들고 복잡하게 얽혀있고 그런 코드

작성 원칙
* 가독성 : 읽기 좋은 들여쓰기, 단어 선택
* 단순성 : 코드를 간단하게 작성, 하나의 함수는 하나의 기능만 수행
* 의존성배제 : 다른 모듈에 미치는 영향을 최소화
* 중복성 최소화 : 
* 추상화

## 최적화 유형
* 클래스 분할 배치 : 하나의 클래스는 하나의 역할만 하도록 응집도 높이고 크기를 작게 작성
* 느슨한 결합 : 인터페이스로 추상화된 것 사용
* 코딩 형식 준수 : 줄바꿈, 호출하는 함수 선배치, 지역 변수는 함수의 맨 처음 선언
* 좋은 이름 사용 : 
* 적절한 주석문 사용 : 

## 소스 코드 품질 분석 도구
결함을 발견하기 위해 사용하는 도구

* 정적 분석 도구 : 실행하지 않고 황ㄱ인 
* 동적 분석 도구 : 코드 실행


# 인터페이스 구현

# 모듈 연계를 위한 인터페이스 기능 식별
## 모듈 연계의 개요
내외부 모듈 혹은 내부 모듈간 데이터 교환을 위해 관계를 설정하는 것

EAI, ESB

## EAI
* 기업 내 애플리케이션 플랫폼 간의 상호 연동
* 비즈니스간 통합 및 연계성 증대 

구축 유형
* Point to Point
    * 애플 1 : 1 연결
* Hub & Spoke 
    * 단일 접점인 허브 시스템 이용해 데이터 전송
    * 확장 및 유지보수가 용이
* Message Bus(ESB)
    * 애플 사이에 미들웨어, 확장성이 뛰어나며 대용량 처리가 용이
* Hybrid 
    * Hus와 Message 혼합
    * 그룹 내에서는 Hub, 그룹 간에는 Message
    * 데이터 병목현상 최소화 가능

## ESB
애플리케이션 사이에 ESB 

애플보다는 서비스 중심의 통합을 지향

범용적으로 사용하기 위해 결합도를 약하게 유지한다

## 모듈 간 연계 기능 식별








