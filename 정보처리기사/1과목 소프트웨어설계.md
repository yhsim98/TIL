# 요구사항 확인
## 소프트웨어 생명주기
개발 방법론의 바탕. 소프트웨어 개발과정을 단계별로 나눈 것

소프트웨어 공학
* 위기 극복을 위해 연구된 학문
* 소프트웨어의 품질과 생산성 향상을 목적
* 기본 원칙 3가지
    * 현대적 기술을 게속적으로 적용
    * 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증
    * 명확한 기록 유지

소프트웨어 생명 주기 모형
1. 폭포수형 모형
2. 프로토타입 모형
3. 나선형 모형
4. 애자일

## 폭포수형 모형
순차적으로 한 단계식 진행해 나간다. 전단계가 수행되어 완료되기 전에는 다음 단계로 진행할 수 없다

가장 오래되고 가장 폭넓게 사용됬다. 두 개 이상의 과정이 병행하여 수행되지 않는다.

타당성 -> 요구분석(문서화) -> 설계 -> 구현 -> 테스트 -> 유지보수

## 프로토타입 모형
개발초기 시스템의 모형을 간단히 만들어 사용자에게 보여 주고, 사용자가 정보시스템을 직접 사용해보게 함으로써 프로토타입을 재구축하는 과정을 사용자가 만족할 때까지 반복해 나가며 시스템을 개선시켜 나가는 방식

요구문제 -> 프로토타입 설계 -> 프로토타입 개발 -> 고객평가

요구사항이 부정확하거나 할 때 사용한다. 변경이 용이하지만 비용이나 시간이 많이든다.


## 나선형 모형
고객과의 소통을 통하여 계획수립과 위험분석, 구축, 고객 평가의 과정을 거쳐 소프트웨어를 개발하는 방식. 복잡한 개발에서 위험 요소를 분석하고 해결할 수 있도록 지원하는 모델

점진적으로 개발과정이 반복된다.

비용과 시간이 많이 들어 대규모 시스템에 알맞다.

키워드는 위험분석

계획 -> 위험 분석 -> 개발 -> 평가 를 반복

요구사항 추가 가능, 유지보수 과정이 필요없다

## 애자일
고객과의 소통에 초점을 맞춘 방법론이다.

요구사항을 받아 우선순위를 부여

개인 상호작용에 가치를 둔다.

짧은 개발 주기를 반복한다.

문서화 보다는 실행sw 에 가치를 둔다.

고객과 협업에 가치를 두고 변화에 대응하는 것에 가치를 둔다.

애자일 12가지 실행지침 
* 고객만족
* 요구사항 적극수용
* 매주 브리핑
* 고객과 개발자가 함께 일함
* 얼굴을 맞대고 의견교환
* 작동하는 sw로 진행상황 
* 설계 중요
* 단순화
* 정기적으로 팀원간 브리핑

## 스크럼 기법
애자일 기반, 팀이 중심이 되어 개발의 효율성을 높임

팀원 스스로 팀을 구성, 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 함

스크럼 팀은 제품 책임자, 스크럼 마스터, 개발팀으로 구성

제품 책임자
* 이해관계자 중 이해도가 높고, 요구사항 책임, 의사 결정할 사람, 주로 개발 의뢰자나 사용자
* 이해관계자들의 의견을 종합하여 제품에 관한 요구사항을 작성
* 백로그 작성하고 우선순위 지정, 팀원들은 우선순위 수정 불가
* 테스트를 수행하며 주기적으로 요구사항 우선순위 갱신

스크럼 마스터
* 스크럼 팀이 작동하도록 조언을 하는 가이드
* 일일 회의 주관하여 진행 사항을 점검하고, 개발 과정에서 발생된 장애 요소를 공론화하여 처리

개발팀
* 제품 책임자와 마스터를 제외한 모든 팀원, 개발자 외에도 디자이너나 테스터 등 모든 사람
* 7 ~ 8 명이 적당

### 스크럼 개발 프로세스
제품 백로그
* 제품 개발에 필요한 모든 요구사항을 우선순위에 따라 나열한 목록
* 지속적으로 업데이트된다
* 백로그의 사용자 스토리를 기반으로 릴리즈 계획을 수립한다

스프린트 계획 회의
* 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립한다
* 요구사항을 task 라는 작업 단위로 분할한 후 개발자별로 수행할 작업 목록인 스프린트 백로그를 작성한다

스프린트
* 실제 작업을 진행하는 과정, 2 ~ 4 주 기간 내에서 진행
* 스프린트 백로그에 작성된 태스크를 대상으로 작업 시간을 추정한 후 개발 담당자에게 할당
* 개발자가 원하는 태스크를 직접 선별할 수 있도록 하면 좋다
* 할당된 태스크는 Todo, inprogress, done 의 상태를 갖는다

일일 스크럼 회의
* 모든 팀원이 매일 약속된 시간 약 15분 정도 짧은 시간동안 진행 상황 점검
* 보통 서서 하며, 남은 작업 시간 소멸 차트에 표시
* 스크럼 마스터는 발견된 장애 요소를 해결할 수 있도록 도와줌

스프린트 검토 회의
* 제품이 요구사항에 부합되는지 사용자 포함된 참석자 앞에서 테스팅 수행
* 스프린트의 한 주당 한 시간 내에 진행
* 제품 책임자는 개선할 사항 피드백 후 다음 스프린트에 반영할 수 있도록 제품 백로그 업데이트

스프린트 회고
* 스프린트 주기를 돌아보며 규칙 준수, 개선점 확인
* 스프린트 끝난 시점에 하거나 일정 주기로 수행


# XP(eXtreme Programming)
XP 는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객참가와 개발 과정의 반복을 극대화하여 개발 생산성 향상시키는 방법

짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 개발하는 것이 목적

릴리즈의 기간을 짧게 반복, 고객의 요구사항 반영에 대한 가시성을 높인다

소규모 인원의 프로젝트에 효과적

5가지 핵심 가치
* 의사소통
* 단순성
* 용기
* 존중
* 피드백


## XP 개발 프로세스
사용자 스토리
* 고객의 요구사항을 시나리오로 표현
* 기능 단위로 구성하고, 필요한 경우 간단한 테스트 사항도 기재

릴리즈 계획 수립
* 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 한다
* 부분 혹은 전체 개발 완료 시점에 대한 일정을 수립한다

스파이크
* 요구사항의 신뢰도를 높이고 기술 문제에 대한 위험을 감소시키기 위해 별도로 만드는 간단한 프로그램
* 처리할 문제 외의 다른 조건은 모두 무시하고 작성한다

이터레이션
* 하나의 릴리즈를 더 세분화 한 단위를 이터레이션이라고 한다
* 일반적으로 1~3주 정도의 기간으로 진행된다
* 이 기간 중에 새로운 스토리가 작성될 수 있으며, 작성된 스토리는 진행 중인 이터레이션 혹은 다음 이터레이션에 포함될 수 있다

승인 검사
* 하나의 이터레이션 안에서 계획된 릴리즈 단위의 부분 완료 제품이 구현되면 수행하는 테스트
* 사용자 스토리 작성 시 함께 기재한 테스트 사항에 대해 고객이 직접 수행
* 테스트 과정에서 발견한 오류사항은 다음 이터레이션에 포함
* 테스트 이후 새로운 요구사항이 작성되거나 요구사항의 상대적 우선순위가 변경될 수 있다
* 테스트가 완료되면 다음 이터레이션을 진행한다

소규모 릴리즈
* 릴리즈를 소규모로 하게 되면, 고객의 반응을 기능별로 확인할 수 있어, 고객의 요구사항에 좀 더 유연하게 대응할 수 있다
* 계획된 릴리즈 기간 동안 진행된 이터레이션이 모두 완료되면 고객에 의한 최종 테스트를 수행한 후 릴리즈, 즉 최종 결과물을 고객에게 전달한다
* 릴리즈가 최종 완제품이 아닌 경우 다음 릴리즈 일정에 맞게 개발을 계속 진행한다

## XP의 주요 실천방법
* Pair Programming : 다른 사람과 프로그래밍 하는 것
* Collective Ownership : 개발 코드에 대한 권한과 책임을 공동 소유
* Test-Driven Development : 테스트 주도 개발
* Whole Team : 전체 팀이 각자 역할
* Continuous Integratio : 모듈 게속적 통합
* Design Improvement : 리펙토링
* Small Releases : 짧은 릴리즈


# 현행 시스템 파악
새로 개발하는 시스템의 개발 범위를 명확히 설정하기 위해 현행 시스템의 구성과 제공 기능, 시스템 간의 전달 정보, 사용되는 기술 요소, 소프트웨어, 하드웨어, 네트워크의 구성 등을 파악한다

## 현행 시스템 파악절차
* 1단계 : 시스템 구성, 기능, 인터페이스 파악
* 2단계 : 아키텍처 구성, 소프트웨어 구성 파악
* 3단계 : 하드웨어 구성, 네트워크 구성 파악

## 시스템 구성 파악
조직의 주요 업무를 담당하는 **기간 업무**와, 이를 지원하는 **지원 업무**로 구분하여 기술

단위업무의 명칭, 주요 기능들 명시

## 시스템 기능 파악
기능을 주요기능, 하부기능, 세부기능으로 구분하여 계층형으로 표시

## 시스템 인터페이스 파악
시스템간 주고받는 데이터의 종류, 형식, 프로토콜, 연계 유형, 주기 등을 명시한다

통신규약 같은것도

## 아키텍처 구성 파악
업무 수행에 어떠한 기술 요소들이 사용되는지 최상위 수준에서 계층별로 표현한 아키텍처 구성도

## 소프트웨어 구성 파악 
소프트웨어 제품명 용도 라이선스 적용 방식, 라이선수 수 등 명시

상용 소프트웨어의 경우 라이선스 적용 방식의 기준과 보유한 라이선스의 파악이 중요

aws, mysql, sage, oracle, window 등등

## 하드웨어 구성 파악
서버의 사양과 수량, 이중화의 적용 여부

## 네트워크 구성 파악
네트워크 구성도, 보안 취약성 분석

장애가 발생한 경우 발생 원인을 찾아 복구하는 용도로 활용

# 개발 기술 환경 파악
## 개발 기술 환경의 정의
운영체제, DBMS, 미들웨어 등을 선정할 때 고려해야 할 사항을 기술, 오픈 소스 사용 시 주의해야 할 내용을 제시

## 운영체제
컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환령을 제공하는 소프트웨어

## 운영체제 식별 시 고려사항
가용성, 성능, 기술 지원, 주변 기기, 구축 비용

## 데이터베이스 관리 시스템
가용성, 성능, 기술지원, 상호호환성, 구축비용

## WAS
사용자의 요구에 따라 변하는 동적 컨텐츠를 처리하기 위해 사용되는 미들웨어

가용성, 성능, 기술지원, 구축비용

# 요구사항 정의
요구사항은 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 제약조건 등

소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거 제공

의사소통 원할, 잘 정의해야 함

## 요구사항 유형
기술하는 내용에 따라 기능 요구사항과 비기능 요구사항으로 나뉨

기술관점과 대상의 범위에 따라 시스템 요구사항과 사용자 요구사항으로 나뉨

* 기능 요구사항
    * 시스템이 무엇을 하는지, 어떤 것을 입출력 하는지, 수행해야 하는 기능
* 비기능 요구사항
    * 시스템 장비구성
    * 성능, 인터페이스
    * 데이터 요구사항
    * 테스트, 보안, 품질
    * 제약사항
    * 등등

* 사용자 요구사항
    * 사용자 관점에서 본 시스템이 제공해야 할 요구사항
    * 사용자를 위한 것으로 친숙한 표현으로 이해하기 쉽게 작성된다
* 시스템 요구사항
    * 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구사항
    * 전문적이고 기술적인 용어로 표현됨
    * 소프트웨어 요구사항이라고도 한다

## 요구사항 개발 프로세스
개발 대상에 대한 요구사항을 체계적으로 도출하고 분석한 후 분석 결과를 명세서에 정리한 다음 마지막으로 이를 확인 및 검증하는 일련의 구조화된 활동

도출 -> 분석 -> 명세 -> 확인

## 요구사항 도출
사용자나 시스템 등 관련자들이 의견 교환하여 요구사항 어딨는지, 어떻게 수집할건지 식별하고 이해하는 과정

요구사항 도출은 지속적으로 반복

청취나 인터뷰, 브레인스토밍 등등

## 요구사항 분석
분석과 중재 기술

명확하지 않거나 모호한 것 발견 걸러냄


## 요구사항 명세
관찰 및 모델 작성

모델작성 문서화

## 요구사항 검증(확인)
확인, 검증

# 요구사항 분석
소프트웨어 개발의 실질적인 첫 단계로 사용자의 요구사항을 이해하고 문서화하는 활동

일정이나 비용의 타당성, 제약 설정

요구 추출, 해결법 결정

문서화

## 구조적 분석 기법
자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법

* 도형 중심의 분석도구
* 도형 중심의 도구라 사용자와 분석가 간의 대화가 용이
* 하향식 방법을 사용하여 시스템 세분화, 분석의 중복 배제
* 논리적 일관성, 자료 흐름도, 자료 사전, 소단위 명세서, 상태 전이도 등등 사용한다
    * 구자자소개상

## 자료 흐름도
자료의 흐름이나 기능 등을 도형으로 나타낸 것

* 프로세스(process) : 처리 변경
* 자료 흐름(data flow) : 흐름
* 자료 저장소(data store) : 저장
* 단말(Terminator) : 출력 입력
* 프자자단

## 자료 사전
자료 흐름도의 자료를 자세히 정의하고 기록

메타 데이터
* = : 정의
* ```+```: 연결
* () : 생략
* [|] : 선택
* {} : 반복
* ** : 설명

# 요구사항 분석 case
요구사항 분석을 위한 CASE(자동화 도구)

자동으로 분석하고 명세서 기술하도록 개발된 도구

SADT
SREM
RSL
PSL/PSA
TAGS

# Hipo
시스템 분석 설계나 문서화 시 사용되는 기법, 시스템 입력, 처리, 출력의 기능을 나타냄

* 가시적 도표 : 시스템의 전체적인 기능과 흐름을 보여주는 계층 구조도
* 총체적 도표 : 프로그램을 구성하는 기능을 기술한 것으로 입력, 처리, 출력에 대한 전반적인 정보를 제공
* 세부적 도표 : 총체적 도표에 표시된 기능을 구성하는 기본 요소들을 상세히 기술하는 도표

# UML(unified modeling language)
의사소통이 원할이 이뤄지도록 표준화한 표현법, 대표적인 객체지향 모델링 언어

사물(things), 관계(relationship), 다이어그램(diagram) 등이 있다

## 사물(things)
모델을 구성하는 가장 중요한 기본 요소, 객체

* 구조 : 클래스, 컴포넌트
* 행동 : 관계
* 그룹 : 패키지
* 주해 : 주석

## 관계
연관성

* 연관관계 association
    * 서로 연관된 것
    * 실선
    * 관계에 참여하는 객체 개수 표시
* 집합관계 aggregation
    * 포함
    * 포함하는 쪽이 마름모 가짐
    * 서로 독립적 이지만 종속적
* 포함관계 composistion
    * 영향을 미친다
    * 특이한 집합관계
    * 생명주기를 함께한다
    * 포함하는 쪽으로 꽉찬 마름모
* 일반화 normalization
    * 자식같은 것
    * 하위 개념
    * 상위로 빈 화살표
* 의존관계 dependency
    * 연관은 있으나 필요에 의해 서로에 영향을 주는 짧은 시간 동안만 연관을 유지
    * 할인율, 등급 관계 등
    * 하나가 다른 하나를 매개변수로 사용하는 관계
    * 주는 쪽에서 받는 쪽으로 점선 화살표
* 실체화관계 realization
    * 기능, 인터페이스
    * 점선
    * 구현체에서 기능으로 점선 화살표

## 다이어그램 **
사물과 관계를 도형으로 표현

구조적 다이어그램
* 클래스 다이어그램 class
    * 클래스와 클래스 속성 클래스 사이의 관계
* 객체 다이어그램 object
    * 인스턴스를 특정 시점의 객체와 객체 사이의 관계
    * 럼바우 객체지향 분석 기법에서 객체 모델링에 활용
* 컴포넌트 다이어그램 component
    * 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
* 배치 다이어그램 deployment
    * 결과물, 프로세스 등 물리적 요소들의 위치 표현
    * 노드와 통신 경로로 표현
    * 구현 단계에서 사용한다
* 복합체 구조 다이어그램 composite structure diagram
    * 클래스나 컴포넌트가 복합 구조를 갖는 경우 내부 구조 표현
* 패키지 다이어그램 package
    * 패키지간의 관계

행위 다이어그램
* 유스케이스 다이어그램 use case
    * 요구 분석 모델링 작업에 사용
    * 사용자와 사용 사례로 구성
* 시퀀스 다이어그램 sequence
    * 상호 작용하는 시스템이나 객체들이 주고받는 메시지 표현
* 커뮤니케이션 다이어그램 communication
    * 객체들이 주고받는 메시지 + 객체 관계
* 상태 다이어그램 state
    * 객체 변화에 따른 다른 객체 변화
    * 럼바우
* 활동 다이어그램 activity
    * 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름
* 상호작용 개요 다이어그램 intreation overview
    * 상호작용 다이어그램 간의 제어 흐름을 표현
* 타이밍 다이어그램 timing
    * 객체 상태 변화와 시간 제약을 명시적으로 표현

스테레오 타입
``<<>>``
UML 기본 기능 외의 추가적인 기능 표현


# 주요 다이어그램
## use case 다이어그램
이 시스템을 통해 할 수 있는 것을 사용자 관점에서 표현

* system scope : 시스템 내부에서 수행되는 기능들을 외부와 구분하는 것
* actor : 시스템과 상호작용하는 모든 요소, 
    * 주액터 : 시스템 사용 이득얻는 대상, 사람
    * 부액터 : 주액터 달성을 위해 서비스를 제공하는 외부 시스템, 기관이나 조직
* use case : 사용자가 보는 관점에서 표현한 것
* relationship : 액터와 유스케이스, 유스케이스와 유스케이스 간의 관게, 포함 확장 일반화

## class 다이어그램
클래스의 속성과 오퍼레이션, 이 들 사이의 관계

문서화하는데 사용

객체 속성이나 함수 정보 잘 표현

클래스 제약조건 관계로 구성

클래스
* 속성과 동작
* 이름, 속성, 오퍼레이션(메소드)

제약조건
* 조건

관계
* 클래스 사이의 연관성

## 시퀀스 다이어그램
객체가 시간의 흐름에 따라 상호작용하는 과정을 액터 객체 메시지 등의 요소를 사용하여 그림으로 표현한 것

객체들 상호작용하며 주고받는 메시지

구성요소
* 액터 : 서비스를 요청하는 외부요소
* 객체 : 메시지를 주고받는 주체
* 생명선 : 객체가 메모리에 존재하는 기간, 라이프사이클
* 실행 상자 : 객체가 메시지를 주고받으며 구동되고 있음을 표현함
* 메시지 : 객체가 상호 작용을 위해 주고받는 메시지


# 화면 설계 
# 사용자 인터페이스(UI)
사용자와 시스템 간의 상호작용이 원할하게 이뤄지도록 도와주는 장치나 소프트웨어

## 특징
편하고 좋고 매개체 

## 구분
* CLI(Command line) : 명령과 출력이 텍스트
* GUI(graphical user) : 아이콘이나 메뉴 를 마우스로
* NUI(natural user) : 사용자의 말이나 행동

## UI 기본원칙 **
* 직관성 : 누구나 사용 가능
* 유효성 : 정확하고 완벽하게 달성
* 학습성 : 쉽게 배우고 익힐 수 있다
* 유연성 : 요구사항을 최대한 수용하고, 실수를 최소화해야 한다

## UI 설계 지침
* 사용자 중심
* 일관성
* 단순성
* 결과 예측 가능
* 가시성
* 표준화
* 접근성
* 명확성
* 오류 발생 해결

## UI 개발 시스템의 기능
UI 개발 시스템이 가져야 할 기능
* 사용자의 입력을 검증할 수 있어야 한다
* 에러 처리와 그와 관련된 에러 메시지를 표현할 수 있어야 한다
* 도움과 프롬프트를 제공해야 한다

# UI 설계 도구
설계에 사용하는 도구 결과를 미리 보여준다

## 와이어프레임
기획 초기, 페이지에 대한 개략적인 레이아웃이나 UI 요소의 뼈대

개발자와 디자이너가 협의하거나 현재 진행 상태 등을 공유하기 위해 사용

## MockUp
좀 더 실제 화면과 유사하게 만든 정적인 행태의 모형

## 스토리보드
와이어프레임에 추가적인 설명

디자이너와 개발자가 최종적으로 참고하는 작업 지침서

## 프로토타입
UI 를 통해 간단한 작동 구현, 동적인 모형

## 유스케이스
사용자 측면의 요구사항

사용자의 목표를 달성하기 위해 수행할 내용을 기술

# 품질 요구사항
품질은 소프트웨어 요구사항이 얼만나 충족되는가 

ISO/IEC 9126
* 소프트웨어의 품질 특성과 평가를 위한 표준 지침
* 특성
    * 기능성 : 적절, 적합, 정밀, 보안, 준수 등
    * 신뢰성 : 성숙성, 고장 허용성, 회복성
    * 사용성 : 이해성, 학습성, 운용성..
    * 효율성 : 시간 효율성, 자원 효율성
    * 유지 보수성 : 분석성, 변경성, 안정성, 시험성

## 기능성
요구사항을 만족하는 기능을 제공하는지

* 적절성/적합성 : 적절한 기능을 제공하는지
* 정밀성/정확성 : 요구하는 결과를 정확하게 산출하는지
* 상호 운용성 : 다른 시스템과 서로 어울려 작업하는 능력
* 보안성 : 정보에 대한 접근을 권한에 따라 허용하거나 차단할 수 있는 능력
* 준수성 : 표준, 관례 준수

## 신뢰성
일관되게 기능 제공

* 성숙성 : 결함으로 인한 고장을 피해갈 수 있는 능력
* 고장 허용성 : 결함에도 규성된 성능 수준 유지
* 회복성 : 고장나도 복구할 수 있는 거

## 사용성
쉽게 배우고 사용, 다시 사용하고 싶은 정도

* 이해성 : 소프트웨어의 적합성, 사용 방법등을 사용자가 이해할 수 있는 능력
* 학습성 : 사용법 학습능력
* 운용성 : 사용자가 소프트웨어 운용, 제어
* 친밀성 : 사용자가 소프트웨어 다시 사용하고 싶게 만드는 능력

## 효율성
한정된 자원, 속도

* 시간 효율성
* 자원 효율성

## 유지 보수성
변화나 새로운 요구사항에 확장할 수 있는 정도

* 분석성 : 결함이나 고장의 원인, 수정될 부분들을 식별하는 능력
* 변경성 : 변화 쉽게 구현
* 안정성 : 변화로 인한 예상치 못한 결과 최소화
* 시험성 : 변경이 검증될 수 있는 능력

## 이식성
다른 환경에서 적용

* 적용성 : 다른 환경으로 변경될 수 있는 능력
* 설치성 : 임의의 환경에 설치
* 대체성 : 동일한 목적을 위해 다른 소프트웨어 대신 사용
* 공존성 : 자원을 공유하는 환경에서 다른 소프트웨어와 공존할 수 있는 능력


# 3장 애플리케이션 설계
# 소프트웨어 아키텍처
소프트웨어의 골격이 되는 기본 구조

기본 원리로 모듈화, 추상화, 단계적 분해, 정보은닉이 있다

설계 단계는 상위설계와 하위설계로 구분할 수 있다

상위설계
* 아키텍처, 예비설계
* 전체적 구조
* DB, 인터페이스, 구조

하위설계
* 모듈, 상세
* 내부 구조 및 행위
* 컴포넌트, 자료 구조, 알고리즘

## 모듈화
소프트웨어의 기능들을 모듈 단위로 나누는 것

모듈이란 특정 기능을 처리할 수 있는 소스 코드

자주 사용하는 것은 공통 모듈로

## 추상화
문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것

유사한 것 만들어서 테스트하거나 하는 것

추상화의 유형
* 제어 추상화 : 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체
* 과정 추상화 : 수행과정 정의 안함, 전반적 흐름만 파악할 수 있게 설계
* 데이터 추상화 : 세부적 속성이나 용도 정의 안함
제과자

## 단계적 분해
niklaus wirth 에 의해 제안된 하향식 설계 전략으로 문제를 상위에서 하위로 구체화

추상화의 반복에 의해 세분화

## 정보 은닉
모듈 내부는 감춰저 다른 모듈이 접근하거나 변경하지 못함

유지보수 용이해짐

## 소프트웨어 아키텍처의 품질 속성
품질 평가를 위한 품질 평가 요소들

시스템 측면
* 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성 등등

비즈니스 측면
* 시장 용이성, 비용과 혜택
* 예상 시스템 수명
* 기타 속성

아키텍처 측면
* 개념적 무결성
* 정확성, 완결성, 구축 가능성

## 협약에 의한 설계
소프트웨어 컴포넌트에 대한 정확한 인터페이스를 명세

포함될 조건에는 선행, 결과, 불변 조건이 있다

# 아키텍처 패턴
아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제

시간도 단축시키고 의사소통도 좋아지고 좋다

레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, MVC 패턴 등이 있다

## 레이어 패턴
계층 구분하는 것

## 클라이언트 서버 패턴
서버와 클라이언트

## 파이프 필터 패턴
데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴

필터는 재사용성이 좋고 추가가 용이

필터를 재배치하여 다양한 파이프라인 구축 가능

데이터 변환, 버퍼링 등에 주로 사용

## MVC 패턴
알지?

# 객체지향
현실 세계의 개체를 하나의 객체로 만들어 프로그래밍

객체 클래스 캡슐화 상속 다형성 연관성

## 객체
데이터와 함수를 묶은 모듈

상태를 가지고, 관계가 있고, 그렇다

## 클래스
공통된 속성과 연산을 갖는 객체의 집합, 객체의 타입

각각의 객체들이 갖는 속성과 연산을 정의하는 틀

클래스에 속한 각각의 객체를 인스턴스, 클래스로부터 객체를 생성하는 것을 인스턴스화라고 한다

## 캡슐화
데이터와 함수를 하나로 묶는 것

정보은닉

## 상속
상위클래스의 모든 속성을 하위클래스로 물려줌

다중 상속, 한 클래스가 두 개 이상의 상위 클래스로부터 속성과 연산을 상속받는 것

## 다형성
하나의 메시지에 대해 클래스에 따라 고유한 방법으로 응답

## 연관성
객체들은 서로 관계를 갖는다

* 연관화(association) : 2개 이상의 객체가 상호 관련됨
* 분류화(classfication) : 동일한 형의 특성을 갖는 객체들을 모아 구성
* 집단화(aggregation) : 관련 있는 객체들을 묶어 하나의 상위 객체를 구성
* 일반화(generalization) : 공통적인 성질로 추상화한 상위 객체 구성
* 특수화(specialization) : 상위 객체를 구성화하여 하위 객체를 구성

## 객체지향 분석 및 설계
