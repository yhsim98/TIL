# 프로그래밍 언어 활용

# 서버 개발
WAS 로직 개발해서 탑재

# 배치 프로그램
사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것을 의미한다.

* 정기 배치 : 정기적으로 배치
* 이벤트성 배치 : 조건
* On-Demand : 사용자 요청 시 수행

배치 프로그램이 갖추어야 할 필수 요소
* 대용량 데이터 처리 가능
* 자동화 가능
* 견고성
* 안정성/신뢰성 : 오류 발생하면 추적 가능
* 성능 : 다른 프로그램 방해하면 안됨, 속도

# 배치 스케줄러
batch processing 이 설정된 주기에 맞춰 자동으로 수행되도록 지원하는 도구

* 스프링 배치
    * 스프링의 배치 스케줄러
    * 데이터베이스나 파일의 데이터를 교환하는데 필요한 컴포넌트들을 제공
    * 로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능을 제공

# 변수
영어, 숫자, 언더바만 쓸 수 있음

숫자는 첫글자로 불가

지역적 변수들
* 자동 변수
    * auto
    * 메모리, 스택 영역에 생성
* 레지스터 변수 

전역적 변수들
* 정적 변수(외부)
    * static
    * 메모리(데이터), 힙???
???

# C데이터 우선순위
산술 -> 시프트 -> 관계 -> 비트 -> 논리

c언어 출력 &x : 16진수

C언어에서 배열에서 주소는 byte 만큼 올라감 4Byte 정수형이면 ```int a[3]``` -> 0 4 8

# 파이썬
표준입력은 input(), input().split()

print(출력값1, 출력값2, sep='', end=''), 출력값사이 seq 들어가고 끝에 end 붙음

range() : ```a = list(range(1, 15, 3)) -> [1, 4, 7, 10, 13]``` 

slice : 문자열이나 리스트같은 객체에서 일부를 잘라 반환  

```
a = [1, 2, 3, 4, 5]

a[1:3] -> [2, 3]
a[1:4:2] -> [2, 4]

객체명[초기위치(default 0):최종위치(default 끝):증가값(default 1)]
- 면 역순
[-a::] -> 끝에서 a번째부터 끝까지
[:-a:-1] -> 끝에서부터 a전까지 역순으로  
```

```
if 조건:
    ㅁㄴㅇㄹ
elif 조건:

for 변수 in range(최종값)
```

```
class (name):
    asdf

    def asdf(self, asdf): // self는 자기 클래스 변수 참조한다는 뜻
        sdfa
        asdf
        return asdf
```



# 스크립트 언어
HTML 문서 안에 직접 프래그래밍 언어를 삽입하여 기계어로 컴파일 없이 별도의 번역기가 소스를 분석하여 동작하게 하는 언어

파이썬 JS PHP JSP ASP 등등

* 자바스크립트 
    * 클라이언트용 스크립트 언어
    * 객체지향 언어의 성격도 가짐, 클래스 앤 상속
    * 프로토타입 개념 활용 가능

# 라이브러리
## c 라이브러리
* stdio
* math
* string
* stdlib
    * 자료형변환, 난수, 메모리 할당 등등
* time

## java
* lang
    * 기본적으로 필요한 인터페이스 자료형 예외처리 등등
    * import 없어도 됨
* util
    * 난수, 컬렉션 등등
* io
* net : 네트워크
* awt : 사용자 인터페이스

# 운영체제의 개념
자원관리, 사용자가 편리하게 사용할 수 있는 환경 제공

유틸리티와 하드웨어 사이

## 목적
처리능력, 반환시간, 사용가능도, 신뢰도 향상

## 기능
프로세서, 메모리, io장치, 주변장치, 등 자원 관리

자원 스케줄링

사용자와 시스템간 인터페이스

하드웨어와 네트워크 관리

데이터 관리 및 공유기능

시스템 오류 검사 및 복구, 자원보호, 가상 계산기(vitual merchine???)

## 주요 자원관리
* 프로세스 관리
    * 스케줄링, 동기화 관리 담당
    * 생성 제거 시작 정지 메시지 전달 등등
* 기억장치 관리
    * 프로세스에게 메모리 할당 및 회수 관리 담당
* 주변장치 관리
    * 입, 출력장치 스케줄링 및 전반적인 관리 담당
* 파일 관리
    * 파일 생성 삭제 변경 유지 등등 관리 담당

# UNIX/LINUX/MacOS
## UNIX
시분할 시스템을 위해 설계된 대화식 운영체제, 대부분 C언어로 작성되어 이식성이 높으며 장치, 프로세스 간의 호환성이 높다.

Multi-use, Multi-Tasking 지원, 트리 구조의 파일 시스템, 등등

## UNIX 시스템의 구성
커널(Kernel)
* UNIX의 가장 핵심적인 부분
* 컴퓨터가 부팅될 때 메모리에 적재된 후 상주하면서 실행
* 하드웨어를 보호하고 프로그램과 하드웨어간 인터페이스 역할
* 프로세스 관리, 기억장치 관리, 파일 관리 등등 여러 기능 수행

쉘(Shell)
* 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행함
* 시스템과 사용자 간의 인터페이스
* 메모리에 상주안함, 명령어가 포함된 파일 형태로 존재, 보조 기억장치에서 교체 처리가 가능
* 파이프라인 지원, 

명령어 해석, 사용자 인터페이스하면 쉘, Unix의 핵심적인 부분 무슨무슨 관리하면 커널

## Linux
* 유닉스와 호환, 

## MacOS
애플꺼

## File Descriptor 파일 서술자
파일을 관리하기 위한 시스템이 필요로 하는, 파일에 대한 정보를 가진 제어 블록, 파일 제어 블록(PCB)

파일마다 독립적으로 존재하며, 시스템에 따라 다른 구조를 가질 수 있음, 보조장치 내에 저장되어있다 해당 파일이 open 될 때 주기억장치로 옮겨짐

사용자가 직접 참조는 불가

# 기억장치 관리
레지스터 - 캐시 - 주기억장치 - 보조기억장치 로 구성됨

관리 전략으로 fetch placement replacement

## fetch 반입 전략
디스크에 있는 
## 배치 전략
* 최초 적합(First Fit) : 프로그램이나 데이터가 들어갈 수 있는 것 중 첫번쨰 분할영역
* Besf FIt : 단편화를 가장 작게 남기는 영역
* worst fit : 남아있는 공간 중 가장 큰 공간

# 가상기억장치 구현 기법
보조기억장치 일부를 주기억장치처럼 사용

실행시 필요한 블럭만 주기억장치에 불연속적으로 할당

메모리보다 용량이 큰 프로그램을 실행하는데 사용 가능

이용률과 다중 프로그래밍의 효율을 높일 수 있다

페이징과 세그멘테이션 기법으로 가상기억장치 구현

## Paging 페이징 기법
일정한 크기로 나눠서 저장, 맵 테이블로 서치 비용 감소

가상기억장치에 보관되어 있는 프로그램과 메모리의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켯 ㅓ 사용

일정하게 나눠진 프로그램을 페이지라 하고, 페이지 크기로 일정하게 나누어진 메모리의 단위를 페이지 프레임이라 한다

외부 단편화는 발생하지 않지만 내부 단편화 발생 가능

페이지 크기가 작으면 단편화가 감소되지만 매핑 테이블이 커지고 접근회수가 늘어 전체적인 io 시간은 늘어남

크면 단편화가 처지지만 io 효율 늘어남

## 세그멘테이션 기법
가상기억장치에 보관된 프로그램을 다양한 크기로 나눠서 저장, 그냥 저장??

프로그램ㅇ르 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트??

공간절약을 위해 사용

다른세그먼트 영역 침범 불가, 외부 단편화 발생 가능

(2, 167) 이면 2번에 167번째

## 페이징 교체 알고리즘
페이지 폴트일때 어떤 메모리 삭제할 것인지

* OPT(Optimal replacement) 최적 교체
    * 가장 오랫동안 사용하지 않을 메모리 교체
    * 성능 측정용
* FIFO(First In First Out)
    * 가장 먼저들어온놈
* LRU(Least Recently Used)
    * 가장 오랫동안 안쓴놈
    * 스택이나 카운터
* LFU
    * 가장 적게쓰 ㄴ것
    * 활발하게 사용되는 친구는 변경안함
* NUR 
    * 최근에 사용하지 않은 페이지 교체
    * 최근에 안썼으면 앞으로도 안씀

## Locality
한번 참조한 곳을 다시 참조하는 성질이 있다

* Temporal Locality
    * 일정 시간에 집중적으로 엑세스
    * 루프, 스택 등등
* Spatial Locality
    * 특정 위치 집중적 엑세스
    * 배열 순회

## Working Set
프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합

자주 참조되는 워킹셋을 메모리에 상주시킴으로서 페이지 폴트를 줄임

## Prepaging
처음에 과도한 페이지 폴트를 막기 위해 필요할 것 같은거 한번에 적재

## Thrashing 스래싱
프로세스 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상

자주 페이지 폴트나면 발생, 시스템 성능 저하

다중 프로그래밍 정도가 너무 높아지면 스래싱이 일어나 CPU 이용률이 감소한다

# 프로세스 
CPU 프로세서에 의해 처리되는 프로그램, 즉 실행중인 작업

PCB를 가졌거나, 메모리에 올라왔거나, 프로시저가 활동중이거나 등등

비동기적 

## PCB
운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳, 데이터 저장소

각 프로세스마다 고유의 PCB가 있고, 프로세스가 완료되면 PCB는 제거

포함된 정보
* 프로세스 현재 상태
* 포인터
* 프로세스 고유 식별자
* 스케줄링 및 프로세스 우선순위
* CPU 레지스터 정보

## 프로세스 상태전이
submit -> hold -> ready -(dispatch)-> run -> wait -(wake up)-> ready -> run -> terminated

* dispatch : 프로세스가 프로세서 할당
* wake up : 대기상테에서 준비상태, 자원 할당받음
* spooling : ???
* traffic controller : 프로세스의 상태에 대한 조사와 통보??

## Thread
프로세스내에서의 작업 단위로서 자원을 할당받아 실행하는 프로그램의 단위

스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로서 프로세스의 역할을 담당

병행성, 처리효율, 응답시간 단축, 프로세스들 간의 통신이 향상??, 

# 주요 스케줄링 알고리즘
## FIFO - FCFS  선입선출
대기 큐에 들어온 순서대로 CPU 할당

비선점방식, 안쫒겨남

## SJF(Shortest Job First) 단기 작업 우선
실행 시간이 가장 짧은 프로세스에게 먼저 CPU 할당

비선점

데드록 발생 가능

## HRN Highst Response-ratio Next
대기 기산과 실행시간 같이 고려한다

(대기시간 + 서비스 시간) / 서비스시간

# 인터넷
## IP 주소
8비트씩 4개 

* A : 0 ~ 127
* B : 128 ~ 191
* C : 192 ~ 223
* D : 224 ~ 239

## subnetting
할당된 네트워크 주소를 다시 여러 개의 작은 네크워크로 분리

## IPv6
128비트

인증성 기밀성 데이터 무결성

패킷 확장 가능, 헤더 확장 가능

## IPv6의 구성
16비트씩 8부분

* 유니캐스트 : 단일 송수신
* 멀티캐스트 : 단일 송신 다중 수신
* 애니캐스트 : 단일 송신 가장 가까이 있는 단일 수신자 간의 통신

## 도메인 네임
DNS

# OSI 참조 모델
통신 규약

응용 표현 세션 전송 네트워크 데이터 링크 물리

## 물리 계층
실제 물리

## 데이터 링크 계층
두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당

흐름 제어, 프레임 동기화 등등 역할

동기화 오류제어 노드간 

## 네트워크 계층
개방 시스템들 간의 네트워크 연결을 관리 

## 전송 계층
종단 시스템 간에 투명한 데이터 전송

TCP, UDP 등의 표준이 있다

데이터 전송, 연결 헤제 등 담당

오류제어 흐름제어 단말간

## 세션 계층
데이터 복구
## 표현
데이터 변환
## 응용
사용자에게 제공

# TCP/IP
데이터 전달 표준 프로토콜

* TCP 전송 계층, 신뢰성 있는 연결, 스트림 전송 기능, 흐름제어, 오류제어 
* IP : 네트워크 계층, 비연결형, 경로선택기능

## 응용 계층 주요 프로토콜
* FTP : 원격 파일 전송 프로토콜
* SMTP : 전자 우편을 교환하는 서비스
* SNMP, DNS, HTTP
* MQTT(Message Queuing Telemetry Transport) : 발행-구독 기반 메시징 프로토콜

## 전송 계층의 주요 프로토콜
* TCP : 양방향 연결형 서비스, 가상 회선 연결, 순서, 오류 흐름제어
* UDP : 비연결형 서비스, 빠름, 속도, 전화 등
* RTCP : 패킷의 전송 품질을 제어하기 위한 프로토콜, 

## 인터넷 계층의 주요 프로토콜
* IP : 전송할 데이터에 주소 지정, 경로를 설정, 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않음
* ICMP
    * IP와 조합하여 통신 중 발생하는 오류의 처리와 전송 경로 변경 등을한다
* ARP(주소 분석 프로토콜)
    * 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소로 바꿈
* RARP
    * ARP와 반대로 물리적 주소를 IP 주소로 바꾼다

## 네트워크 액세스 계층의 주요 프로토콜

# 5장
# 소프트웨어 개발 방법론
## 구조적 방법론
정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리(Precess) 중심의 방법론

타당성 검토 -> 계획 -> 요구사항 -> 설계 -> 구현 -> 시험 -> 유지보수/운용

## 컴포넌트 기반 방법론
기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론

컴포넌트 재사용, 확장성 보장, 유지보수 비용 감소, 생산성 및 품질 향상

# SW 공학의 발전적 추세
## 소프트웨어 재사용 방법
* 합성 중심(Composition-Based) 
    * 모듈을 끼워 맞춰 소프트웨어를 완성시키는 방법
* 생성 중심(Generation-Based)
    * 추상화 형태를 쓰여진 명세를 구체화하여 프로그램을 만드는 방법

## 소프트웨어 재공학의 개요
## CASE의 개요
소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 자동화
* 다양한 시스템에서 사용되는 자동화 도구
* 소프트웨어 생명 주기의 전체 단계를 연결해주고 자동화해주는 도구 제공
* 재사용성 향상
* 모듈 관리를 자동으로 수행하므로 유지보수 간편해진다
* 주요 기능
    * 
* 원천 기술








