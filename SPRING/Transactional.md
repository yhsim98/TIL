https://mangkyu.tistory.com/154

# Spring이 제공하는 Transaction 핵심 기술
## 트랜잭션 동기화
트랜잭션 동기화란 트랜잭션을 시작하기 위한 Connection 객체를 특별한 저장소에 보관해두고 필요할 때 꺼내쓸 수 있도록 하는 기술이다.

트랜잭션 동기화 저장소는 작업 쓰레드마다 Connection 객체를 독립적으로 관리하기 때문에, 멀티쓰레드 환경에서도 안전하다.

하지만 JDBC가 아닌 Hibernate 와 같은 기술을 사용한다면 Connection이 아닌 Session 객체를 사용하기 때문에 문제가 생길 수 있다. 이러한 기술 종속적인 문제를 해결하기 위해 Spring은 트랜잭션 관리 부분을 추상화한 기술을 제공하고 있다.

## 트랜잭션 추상화
spring은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공한다. 이를 통해 기술에 종속적인 코드가 아닌 일관된 트랜잭션 처리가 가능하다.

[](!https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F6eLCk%2Fbtq5gFwQO4x%2FKT2qebNokRvImqLY6iKcK0%2Fimg.png)

## AOP를 이용한 트랜잭션 분리
@Transactional 을 통하여 aop를 적용하여 비즈니스 로직과 트랜잭션 처리 로직을 분리할 수 있게 되었다.

# Spring 트랜잭션의 세부 설정
Spring의 DefualtTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는 **네 가지 속성**을 정의하고 있다. 해당 4가지 속성은 트랜잭션을 세부적으로 이용할 수 있게 도와주며, @Transactional 어노테이션에도 공통적으로 적용할 수 있다.

## 트랜잭션 전파
트랜잭션 전파란 트랜잭션 경계에서 이미 진행중인 트랜잭션이 있거나 없을 때 어떻게 동작할 것인가를 결정하는 방식을 의미한다.

* A의 트랜잭션에 참여
    * B의 코드는 새로운 트랜잭션을 만들지 않고 진행중인 트랜잭션에 참여할 수 있다
    * 오류가 발생할 경우 A와 B의 모든 작업이 취소된다
* 독립적인 트랜잭션 생성
    * A와 B의 트랜잭션을 독립적으로 만들 수 있다
* 트랜잭션 없이 동작
    * B가 readonly 라면 굳이 B의 작업에 트랜잭션을 걸 필요가 없다

이렇게 이미 진행중인 트랜잭션이 어떻게 영향을 미칠 수 있는가에 대한 부분이 트랜잭션 전파 속성이다. 트랜잭션을 시작하는 것처럼 보이는 getTransaction() 코드가 begin 이 아닌 get으로 이름이 지어진 이유도 여기에 있다. 해당 트랜잭션은 다른 트랜잭션에 묶여있을 수 있기 때문이다. 

이 외에도 여러 처리 방법을 지원한다

## 격리수준
모든 DB트랜잭션은 격리수준을 가지고 있어야 한다. 서버에서는 여러 개의 트랜잭션이 동시에 진행될 수 있는데, 모든 트랜잭션을 독립적으로 만들고 순차 진행한다면 안전하겠지만, 성능이 떨어질 수 밖에 없다. 따라서 적절하게 격리수준을 조정해서 가능한 많은 트랜잭션을 문제없도록 동시에 진행시키는 것이 필요하다. 

이는 JDBC 드라이버나 DataSource 등에서 재설정할 수 있고, 트랜잭션 단위로 격리수준을 조정할 수도 있다.

## 제한시간
트랜잭션을 수행하는 제한시간을 설정할 수 있다. 제한시간의 설정은 트랜잭션을 직접 시작하는 PROPAGATION_REQUIRED 등등의 경우에 사용해야만 의미가 있다

## 읽기 전용
읽기 전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하려는 시도를 막아줄 수 있을 뿐만 아니라 데이터 액세스 기술에 따라 성능이 향상될 수 있다.


# 전파 속성
Spring이 제공하는 선언적 트랜잭션(@Transactional)의 장점 중 하나는 여러 트랜잭션 적용 범위를 묶어 하나의 커다란 트랜잭션 경계를 만들 수 있다는 점이다.
 
Spring이 트랜잭션을 어떻게 진행시킬 것인지 전파 속성을 설정할 수 있다.

7가지 전파속성이 있다.
* REQUIRED
* SUPPORTS
* MANDATORY
* REQUIRES_NEW
* NOT_SUPPORTED
* NEVER
* NESTED

## REQUIRED
* 디폴트 속성, 모든 트랜잭션 매니저가 지원함
* 이미 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작
* 하나의 트랜잭션이 시작된 후 다른 트랜잭션 경계가 설정된 메소드를 호출하면 같은 트랜잭션으로 묶인다

미리 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작한다. 

## SUPPORTS
* 이미 시작된 트랜잭션이 있으면 참여하고, 그렇지 않으면 트랜잭션 없이 진행한다
* 트랜잭션이 없어도 해당 경계 안에서 Connection 객체나 하이버네이트의 Session 등은 공유할 수 있음

## MANDATORY
* 이미 시작된 트랜잭션이 있으면 참여하고, 없으면 새로 시작하는 대신 예외를 발생시킴
* MANDATORY는 혼자서 독립적으로 트랜잭션을 진행하면 안되는 경우에 사용

## REQUIRES_NEW
* 항상 새로운 트랜잭션을 시작해야 하는 경우에 사용
* 이미 진행중인 트랜잭션이 있으면 이를 보류시키고 새로운 트랜잭션을 만들어 시작함

## NOT_SUPPORTED
* 이미 진행중인 트랜잭션이 있으면 이를 보류시키고, 트랜잭션을 사용하지 않도록 함

## NEVER
* 이미 진행중인 트랜잭션이 있으면 예외를 발생시키며, 트랜잭션을 사용하지 않도록 강제함

## NESTED
* 이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작함
* 중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것으로, 독립적인 트랜잭션을 만드는 REQUIRES_NEW와는 다르다
* NESTED에 의한 중첩 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만, 자신의 커밋과 롤백은 부모 트랜잭션에 영향을 주지 않는다

작업의 로그를 남기는 등의 경우에 해당 옵션을 사용하면 된다. 로그 실패했다고 작업가지 취소할 필요는 없다!!


# 격리 수준(Isolation)
트랜잭션 격리수준은 동시에 여러 트랜잭션이 진행될 때 트랜잭션의 작업 결과를 여타 트랜잭션에게 어떻게 노출할 것인지를 결정한다. 

스프링은 다음의 5가지 격리수준 속성을 지원한다.
* DEFAULT
* READ_UNCOMMITED
* READ_COMMITED
* REPEATABLE_READ
* SERIALIZABLE

## DEFUALT
* 사용하는 데이터 액세스 기술 또는 DB 드라이버의 디폴트 설정을 따른다
* 일반적으로 드라이버의 격리 수준은 DB의 격리 수준을 따르며, 대부분의 DB는 READ_COMMITED를 기본 격리수준으로 가진다
* 일부 DB는 디폴트 값이 다른 경우도 있으므로 DEFUALT를 사용할 때는 드라이버와 DB의 문서를 참고해서 기본 격리수준을 확인해야 한다

## READ_UNCOMMITTED
* 가장 낮은 격리수준으로써 하나의 트랜잭션이 커밋되기 전에 그 변화가 다른 트랜잭션에 그대로 노출되는 문제가 있다
* 하지만 가장 빠르기 때문에 데이터의 일관성이 조금 떨어지더라도 성능을 극대화할 때 의도적으로 사용한다

## READ_COMMITED
* SPRING은 기본 속성이 DEFAULT이며, DB는 일반적으로 READ_COMMITED가 기본 속성이므로 가장 많이 사용된다
* READ_UNCOMMITED와 달리 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다
* 대신 하나의 트랜잭션이 읽은 low를 다른 트랜잭션이 수정할 수 있어 처음 트랜잭션이 같은 low를 다시 읽을 때 다른 내용이 발견될 수 있다

## REPEATABLE_READ
* 하나의 트랜잭션이 읽은 low를 다른 트랜잭션이 수정할 수 없도록 막아주지만 새로운 low를 추가하는 것은 막지 않는다
* 따라서 SELECT로 조건에 맞는 로우를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 low가 발견될 수 있다

## SERIALIZABLE
* 가장 강력한 트랜잭션 격리 수준, 트랜잭션을 순차적으로 실행한다
* 여러 트랜잭션이 동시에 같은 테이블의 정볼르 엑세스할 수 없다
* SERIALIZABLE은 가장 안전하지만 가장 성능이 떨어지므로 극단적으로 안전한 작업이 필요한 경우가 아니라면 사용해서는 안된다

# 읽기 전용(readOnly)
Transaction을 readOnly로 설정하여 성능을 최적화할 수 있다.

* 읽기 전용으로 설정함으로써 성능을 최적화 함
* 쓰기 작업이 일어나는 것을 의도적으로 방지함
* 하이버네이트의 경우 readOnly=true로 한다면 플러시가 일어나지 않게 된다
* 따라서 트랜잭션을 커밋하더라도 영속성 컨텍스트가 플러시 되지 않아 엔티티의 수정/등록/삭제가 동작하지 않는다
* 변경 감지를 위한 스냅샷 비교와 같은 무거운 로직들을 수행하지 않으므로 성능이 향상된다
* readOnly가 true인 트랜잭션끼리의 동시성이 보장된다

# 롤백/커밋 예외
선언적 트랜잭션에서는 **런타임 예외가 발생하면 롤백하고, 예외가 발생하지 않았거나 체크 예외가 발생하였다면 커밋**한다. 여기서 체크 예외를 커밋 대상으로 삼은 이유는 체크 예외가 예외적인 상황이라기보다 반환값을 대신해 비지니스적인 의미를 담은 결과로 많이 사용되기 때문이다. 

하지만 롤백/커밋의 동작 방식의 변경을  원한다면 설정을 통해 동작 방식을 바꿀 수 있다. 

커밋 대상이지만 롤백을 발생시킬 예외나 클래스 이름은 각각 rollbackFor 또는 rollbackForClassName으로 지정할 수 있으며, 반대로 롤백 대상인 런타임 예외를 트랜잭션 카밋 대상으로 지정하기 위해서는 noRollbackFor 또는 noRollbackForClassName을 이용할 수 있다.

