# 데이터베이스 구축의 6단계
1. [요구수집 및 분석](#요구수집-및-분석)
2. [개념적 설계](#개념적-설계)
3. DBMS 선정
4. [논리적 설계](#논리적-설계)
5. 물리적 설계
6. 구현 및 테스트

# 트랜잭션이란?
DB에서 작업의 기본 단위로서, 데이터를 일관되게 변경하는 하나 이상의 데이터 조작어 문장으로 구성됨.

# DB 설계 전략
* 데이터 중심 DB 설계
    * DB의 내용과 구조에 치중해서 설계하는 방법
* 처리 중심 DB 설계
    * 데이터의 처리와 응용에 치중해서 설계하는 방법
* 2가지를 병행해서 진행하는 것이 일반적이다

# DBMS 선정 기준
경제성, 논리적 데이터 모델, 운영환경등에 따라 결정해야 한다.

# DB구축 시 고려사항
* 무결성 
    * DB에 저장된 데이터가 제약조건을 만족해야 한다
* 일관성 
    * 저장된 데이터들 간에, 또는 특정 질의에 대한 응답들 간에 모순이 없어야 한다
* 회복
    * 시스템에 장애가 발생한 경우, 장애 발생 이전의 일관된 DB 상태로 복구 가능해야 한다
* 보안 
    * 불법적인 접근에 대해 보호 가능해야 한다
* 효율성 
    * 응답시간 단축, 저장 공간 최적화, 시스템의 생산성 등을 고려해야 한다
* 확장
    * 시스템에 영향을 주지 않고 새로운 응용 프로그램이나 데이터를 추가할 수 있어야 한다

# 요구 수집 및 분석 단계의 주요 업무
1. 사용자 그룹 및 담당자 식별
2. 요구사항 수집
    1. 사용자의 요구사항 수집
    2. 범 기관적 제약조건 파악
    3. 기존 문서 조사
3. 요구사항 분석
    1. 업무 영역 분할
    2. 상세 업무 분석
4. 요구 분석 명세서 작성
5. 수용 범위 결정

* 범 기관적 제약조건 예 : 표준 용어, 표준 코드, 표준 도메인 등

# 개념적 설계란?
요구 분석 명세서를 기초로 DBMS와는 무관한 추상적인 형태로 사용자의 요구를 표현하는 것

## 개념적 설계의 주요 업무
개념적 모델링 + 트랜잭션 모델링

* 개념적 모델링
    * 데이터 중심 설계
    * 데이터 요구분석 명세서를 기초로 ER 모델 산출
    * 결과물 : ER 다이어그램
* 트랜잭션 모델링
    * 처리 중심 설계
    * 트랜잭션 요구 분석 명세서를 기초로 업무 단위의 유형별 트랜잭션 나열 
    * 결과물 : 트랜잭션 명세서

# DBMS 선정 기준
* 논리적 데이터 모델 
    * 개념적 설계 단계의 산출물인 개념적 DB 스키마를 가장 효율적이고 안정적으로 표현할 수 있는 논리적 데이터 모델을 기초로 하는 DBMS 선택
* 운영 환경 
    * DB를 구축할 하드웨어 환경과 운영체제 등을 고려해서 운영 환경에 적합한 DBMS 선택
* 경제성
    * DBMS의 가격과 하드웨어 구입 비용, 교육 비용, 운영 비용, 유지 비용 등 경제적인 측면을 고려해서 DBMS선택

# 논리적 설계란?
개념적 데이터 모델(개념적 스키마)을 DBMS가 지원하는 논리적 데이터 모델(논리적 스키마)로 변환하는 것


논리적 모델링 -> 트랜잭션 인터페이스 설계 -> 스키마 평가 및 정제

* 논리적 모델링 
    * 릴레이션 스키마
    * 무결성 제약조건 정의


# 물리적 설계란?
논리적 스키마(릴레이션 스키마와 무결성 제약조건)를 기초로 내부 스키마(물리적 데이터 구조)로 변환하는 것

물리적 모델링 + 트랜잭션 상세 설계


# 구현 및 테스트 단계
* 설계된 DB 구조를 DDL로 생성한다
* 기존 DB를 새로운 DB로 변환한다
* DB에 초기 데이터를 적재 한다
* 트랜잭션 처리용 응용 프로그램을 작성한다
* 유지보수를 위한 문서화 작업을 한다

# 테스트 단계
* 생성된 DB구조가 설계된 DB 구조와 일치하는지 확인
* 응용 프로그램과 DB의 연동이 원할한 지 확인
* 트랜잭션 유형별로 테스트 케이스를 선정하여, 데이터 조작이 원할한지 확인




# 요구수집 및 분석
## 요구 수집 단계의 주요 업무
* DB에 대한 잠재적인 사용자를 식별하고, 사용자가 원하는 DB의 용도 파악
* DB가 제공해야 할 정보 내역 수집
* 요구 수집한 내역을 체계적으로 정리하여 요구 분석의 기초 자료가 될 수 있도록 **요구 수집 명세서 작성**

## 요구 수집 방법
* 요구를 수집할 사용자 그룹 및 업무 담당자 식별
    * 직, 간접적인 방법을 통해서 전체적인 요구 사항 수집
* 범 기관적인 제약조건 식별
    * 기관의 규정, 표준 용어, 표준 도메인 등 파악
* 기준 문서 조사
    * 각종 양식, 보고서, 응용 프로그램 관련 메뉴얼 등
* 운영 환경 파악
    * DB 운영할 컴퓨터 환경, 업무 환경 등
* 요구 수집 명세서 작성

## 요구 분석 단계 주요 업무
1. 업무 영역 분할
    * 다양한 요구 수집 산출물을 기초로 업무 영역 분할도 작성
2. 요구 분석 명세서 작성 
    * 업무별 데이터 요구 분석 명세서 작성
    * 업무별 트랜잭션 요구 분석 명세서 작성
3. 요구사항 수용 범위 결정
    * 우선순위가 높고 제한된 기한 내에 구현 가능한 요구사항만 수용

## 요구 분석이 중요한 이유
요구 분석에 오류가 발생하면 아무리 많은 시간과 노력을 투자해도 원하는 시스템을 구축하기 어려운 경우가 많기 때문

## 업무 영역 분할
### 업무 영역 분할도
* 전체 업무를 요구 분석의 기본 단위가 되는 소단위의 업무 영역으로 분할하여 계층구조 형태로 표현한 것
* 조직의 업무 영역 분할이 명확한 경우, 이 과정을 생략하고 기존에 분할된 업무 영역 단위로 요구사항을 분석해도 됨 

## 데이터 요구 분석 명세서
요구 분석 단계의 중요한 산출물로서, 데이터 중심 DB 설계에 근거하여 업무별로 요구되는 데이터를 분석한 결과를 문서화한 것으로, 일종의 업무처리 규정문이라고 볼 수 있음

* 개체들의 속성과 개체와 개체사이의 관계는 어떤 것이 있는지 찾는데 필요한 정보를 넣는다.
* 단순 데이터 처리가 아니라, 어떤 관련된 업무가 있는지 관계는 어떤지 등등
## 트랜잭션 요구 분석 명세서
요구 분석 단계의 중요한 산출물로서, **처리 중심 DB 설계**에 근거해서 업무별로 요구되는 트랜잭션 즉, **데이터 조작 작업**을 문서화한 것

데이터 조작의 주체는 상관없이 해당 데이터를 조작하는 모든 과정을 분석하는 것

## 트랜잭션 요구 분석 명세서 작성 시 유의사항
* 분할된 업무 영역별로 요구되는 데이터 조작 작업을 간단히 표현한다
* 한 번에 하나의 데이터 조작만 포함하도록 작성한다
* 데이터 조작을 가능한 검색, 삽입, 삭제, 변경이라는 용어를 사용해서 표현한다
* 추후 트랜잭션 처리용 응용 프로그램을 작성할 때 참조가 되도록 작성한다

## 요구 분석의 특성
* 요구사항은 계속 변화한다
* 요구사항은 점차 확장된다
* 요구사항은 불완전하다
* 요구사항은 생명주기가 있다

## 요구 분석 명세서 검토 질문
* 요구사항이 이해하기 쉬운가
* 정확히 표현되었는가
* 애매모호하지는 않는가
* 필요를 충족시키는가
* 빈드시 필요한가
* 기한내에 수용할 수 있는가



# 개념적 설계
요구 분석 명세서를 토대로 DBMS와는 무관한 추상적인 형태의 사용자의 요구사항을 표현하는 것

## 개념적 설계 단계의 2가지 주요 업무
* 개념적 모델링
    * 데이터 중심의 DB 설계에 해당하며, 데이터 요구 분석 명세서를 기초로 ER 모델을 산출하고, ER 다이어그램으로 표현함
    * 개념적 스키마 모델링이라고도 칭함
* 트랜잭션 모델링
    * 처리(프로세스) 중심의 DB 설계에 해당하며, 트랜잭션 요구 분석 명세서를 기초로 업무 단위의 유형별 트랜잭션을 설계함

## 개념적 모델링
요구 분석 명세서를 토대로 DBMS와는 무관한 추상적인 형태로 사용자의 요구사항을 표현하는 것

ER 모델로 표현한다. ER 다이어그램으로 표현한 개념적 모델링 결과를 개념적 구조 혹은 개념적 스키마라고 한다

## 개념적 모델링 방법
### ER 모델 도출 순서
* 명세서를 기초로 핵심 개체 타입 식별
* 개체간의 관계 타입 식별
* 관계타입의 유형과 카디널리티 결정
* 개체 타입의 속성 식별
* 개체 타입의 식별자(후보 키) 결정
* 관계 타입의 속성 식별
* 개체 타입과 관계 타입, 속성을 모두 ERD로 표현
* ERD가 모든 요구사항을 반영하는지 검증


### 개체 식별
* 개체(Entity)
    * DB가 표현하려고 하는 유형, 무형의 정보 대상으로, "존재하면서 서로 구별될 수 있는 요소"
* 개체 식별의 중요성
    * 설계 단계에서 개체 식별은 중요하고, 어떤 개체가 식별되냐에 따라 속성과 관계가 달라질 수 있음
    * 개체 하나에 평균 5개 정도의 응용 프로그램이 개발되므로 개체 식별이 DB 구축의 성패를 좌우함

### 개체 식별 방법
* 개체 후보 식별
    * 데이터 요구 분석 명세서에서 주로 주어나 목적어로 표현된 것이 개체 후보
* 개체 후보 검토
    * 각 개체 후보의 실제 데이터 수와 대표 속성 파악
    * 동음이의어, 이음동의어 검토
    * 동사로 표현된 것이 개체로 잘못 추출된 것이 있는지 검토하고, 필요한 경우 개체 이름도 변경
* 최종 개체 선정
    * 실제 데이터가 2개 이상 존재하고, 2개 이상의 속성을 갖고 있는 개체 후보를 최종 개체로 선정
    * 동일한 의미를 갖는 개체가 있으면 제외시킴

### 개체 표현 방법
* 피터 첸 표기법
    * 하나 이상의 속성과 연결된 직사각형으로 표현하고, 식별자는 밑줄로 표시
* IE 표기법
    * 개체를 사각형으로 구분하고, 사각형 위에 개체 이름을 표시

### 개체 이름 부여 방법
* DB 내에서 유일
* 현업의 표준 용어를 사용
* 단수 명사사용
* 약어사용 하지말자
* 성격을 쉽게 알게
* 이름 부여 규칙을 미리 정하기
* 자료 사전 또는 용어 사전을 만들어 참조

### 개체 식별시 주의사항
* 개체가 될 가능성있는 모든 대상 추출하기
* 유사한 개체도 모두 추출하기
* 어떤 대상이 해당 개체에 속하는지 분명하도록 각 개체 정의하기
* 업무 처리 과정을 지나치게 고려하지 않기
* 개념은 확실히 잡고 가기
* 예외 상황은 일단 무시하고 넘어가기
* 최종적 선정되면 핵심 특징 파악하기

## 관계 식별
* 관계
    * 개체들 간의 의미 있는 연결 또는 연관성을 의미하는 요소 
### 관계 식별 방법
1. 명세서에서 동사로 표현된 부분이 관련성을 표현하는 경우
2. 식별된 개체중 관계로 표현하는 것이 더 적합한 경우
3. 관계 이름 부여
4. 관계 유형 설정
5. 관계를 설명하는 속성 파악
6. 관계 이름과 유형, 속성 등이 포함된 최종 관계 목록 작성

### 관계 식별 시 유의사항
* 관계는 개체들 간의 상호 연관성으로, 개체와 관련된 업무를 수행하는 일종의 업무 규칙에 해당 -> 주로 동사
* 업무를 충분히 파악한 다음 전체 업무를 고려해서 넓은 시각으로 분석
* 업무 규칙이 변경됨에 따라 관계도 변경될 수 있음
* 식별된 개체 가운데 '관계'로 표현하는 것이 적합한 것이 있는지 검토
* 관계는 관계에 포함된 양쪽 개체의 식별자를 속성으로 갖게 됨

### 관계 표현 방법
* 피터 첸
* IE

### 관계 이름 부여 방법
* 가능한 두 개체의 연관성을 나타내는 동사
* 현재 시제
* 개체들 간의 관련성이 명확하도록 표현
* 관계 이름은 DB 내에서 유일해야 함
* 부연 설명이 필요없는 일반적인 용어로 표현

## 속성 식별
### 속성 식별 방법
1. 데이터 요구 분석 명세서에서 개체를 설명하는 명사를 속성으로 식별
2. 관계를 설명하는 명사를 관계속성으로 식별
3. 후보키가 없으면 후보키 역할을 할 속성 추가
4. 추가적으로 필요한 속성 식별


### 유의사항
* 유일한 식별자
* 가능한 모든 속성 식별
* 필요한 경우 속성 이름 변경

### 식별자 관련 유의사항
* 모든 개체는 하나 이상의 식별자(후보 키)를 포함
* 식별자는 반드시 유일한 값을 가져야 함
* 식별자는 불변값
* 최종 식별자 즉 기본키는 논리적 모델링 단계에서 식별자 가운데 하나를 선택해서 결정 가능

### 속성 표현 방법
* 피터 첸
    * 각 속성은 타원
    * 후보키는 밑줄
* IE
    * 식별자와 설명자를 구분해서 표현

### 이름 부여 방법
* 한 개체 안에서는 유일해야 함
* 유지보수할때 불편하니까 개체 이름을 속성 이름의 접두어로 사용하지 않는다
* 현업의 표준 언어 사용
* 단어와 단어는 '_' 로 연결


## ER 다이어그램 작성
1. 개체 타입 표시
2. 개체 타입들 간의 관계 표시
3. 관계 타입의 유형 표시
4. 관계 타입의 카디널리티 표시
5. 개체 타입의 속성 표시
6. 관계 타입의 속성 표시


# 트랜잭션 모델링
## 트랜잭션이란?
* 하나의 논리적 기능을 수행하기 위한 작업 단위로서, 데이터를 일관되게 변경하는 하나 이상의 데이터 조작 명령문으로 구성됨
* DB의 무결성이 보장되는 상태에서 요청된 작업을 완수하기 위한 작업의 기본 단위로 간주됨

## 트랜잭션 모델링 주요 업무
업무 단위별로 데이터 조작 작업을 유형별로 세분해서 명세서 작성, 데이터 조작과 관련된 제약조건도 정의

## 트랜잭션 모델링의 필요성
* 주요 트랜잭션의 기능적 요구사항을 DB 설계 초기에 파악할 수 있음
* 추후 구축 단계에서 트랜잭션을 처리하는 응용 프로그램을 작성할 때 기초 자료가 됨
* 스키마에 트랜잭션이 필요로 하는 정보가 모두 포함되어 있는지 확인 가능

트랜잭션 요구 분석 명세서 -> 트랜잭션 모델링 -> 트랜잭션 명세서

## 트랜잭션 명세서 작성 방법
* DB 설계에 반영할 필요가 있는 주요 트랜잭션을 식별한 다음, 각 트랜잭션의 내부적인 제어 흐름을 파악해서 트랜잭션의 유형을 구분함
* 입력 및 출력 정보 표시 및 트랜잭션의 상대적인 중요도 등 작성

## 트랜잭션 모델링 단계에서 트랜잭션 유형 구분
* 삽입, 삭제, 변경, 검색, 혼합

## 제약조건 정의
ER 다이어그램에 없는 정보를 정의  



# 개체 심화 요소란?
보다 세분화된 개념적 모델링을 위해 개체를 세분화한 요소

* 키 개체, 메인 개체, 액션 개체, 약한 개체, 코드 개체, 관계 개체 등

## 키 개체
* 해당 업무에서 원래부터 존재하는 개체로서, 다른 개체와의 관계에 의해 생성된 개체가 아닌 원래 독립적으로 존재하는 개체
* 다른 개체의 부모 개체가 되므로 가장 우선해서 추출함
* 사원, 부서, 고객, 상품 등

* 부모개체
    * 다른 개체가 파생되는 근원이 되는 개체
    * 다른 개체와는 무관하게 독립적으로 존재하는 개체
* 자식개체
    * 부모 개체로부터 파생된 개체, 부모 개체 없이 존재 불가

## 메인 개체
* 키 개체들 간의 업무적인 관련성 때문에 생성되는 개체
* 해당 업무에서 핵심적으로 관리되는 데이터(부모개체)로부터 추출됨
* 매인 개체는 ER 모델에서는 대개 '관계'에 해당함

* 관계 개체와 메인 개체간의 차이점
    * 관계 개체는 두 개체 간의 M : N 관계로 인해 생성되는 개체이다
    * 메인 개체는 1 : 1 유형과 1 : N 유형의 관련성까지 모두 포함하는 개체이다

## 액션 개체
* 메인 개체로부터 파생되면서 내용이 자주 바뀌는 개체
* 초기 분석 단계에서는 잘 드러나지 않지만 모델링을 세분화하는 단계에서 도출됨

## 약한 개체
* 독립적으로 존재하지 못하고 소유 개체가 있어야 존재할 수 있는 개체
* 고유한 식별자가 없기 때문에 자신의 구분자(부분 키)를 소유 개체의 식별자와 결합해서 복합 식별자를 지정해야 함

## 코드 개체
* 정보를 간단히 표현하기 위한 기호를 나타내는 개체
* 실제 업무에서 사용하는 코드도 있지만 데이터를 효율적으로 표현하기 위해서 생성하는 경우도 있음
* 개념적 설계 단계에서 모두 식별할 필요는 없음
* 코드 개체는 참조용이므로 다른 개체와 관계를 맺을 필요가 없음
* 전공 코드 개체 등등

## 관계 개체란?
* 두 개체간의 M : N 관계로 인해 생성되는 개체로, 교차 개체라고도 칭한다
* ER 모델을 피터 펜 표기법으로 표현할 때는 M : N 관계도 마름모로 표현할 수 있지만, IE 표기법으로 표현할 때 M : N  관계를 정확히 표현하기 위해서 관계 개체를 생성해서 표현해야 한다
* 관계 개체의 식별자는 양쪽 개체의 식별자를 합친 복합 식별자로 지정한다

# 관계 심화 요소란?
보다 세분화된 개념적 모델링을 위해 관계를 세분화한 요소

## 병렬 관계
두 개체 사이에 두 개 이상의 관계가 존재하는 것으로, 다중관계 라고도 한다.

## 직렬 관계
병렬 관계로 나열한 여러 관계를 하나의 상위 개념으로 통합해서 M : N 관계로 바꾸어서 표현한 관계

발주하다, 감독하다, 정산하다 -> 관리하다(관리유형)

## 순환 관계
하나의 개체가 다른 개체가 아닌 자기 자신과 관계를 맺는 것을 의미한다

* 1 : N 순환 관계
    * 기관의 조직도, 관리자 정보 등과 같이 계층 구조를 표현할 때 발생한다
* M : N 순환 관계
    * 선수 과목이나, 구성부품 정보 등과 같이 네트워크 구조를 표현할 때 발생한다


# 속성 심화 요소
## 기초 속성
* 업무로부터 추출된 일반적인 속성
* 데이터 요구 분석 명세서에 포함되어 있으며, 현업에서 정보를 제공해야 속성이 유지될 수 있다
* 삼품의 상품명, 가격 등

## 설계 속성
* 원래 존재하지는 않지만 필요에 따라 설계자가 추가한 속성
* 데이터 요구 분석 명세서에 포함되어 있지는 않지만, 설계를 진행하면서 새로 생성된 속성
* 대부분의 코드 속성이나 일련번호처럼 식별자 역할을 하도록 추가된 속성이 해당함

## 유도 속성
* 기본 속성으로부터 계산 등의 가공 처리를 통해서 생성된 속성
* 추출 속성이라고도 칭한다
* 저장 속성의 영향을 받으므로, 저장 속성의 값이 변경되면 함께 변경된다
* 중복의 의미가 있으므로 대개 개념적 모델링 단계에서 식별하지 않음(반드시 필요한 경우라면 별도로 정리해서 구현 단계에서 참조함)


# 관계 행렬 활용
## 관계 행렬
개체들 간의 관계를 정의하기 위해서 사용하는 보조 도구

## 관계 행렬 작성 및 분석 방법
* 개체 타입을 가장 상위 행과 가장 좌측 열에 모두 표시한다
* 개체 타입들 간의 관계 유무를 셀에 표시한다
* 일차적으로 조금이라도 관련성이 있으면 모두 표시한다
.
.
.
.

## 슈퍼 서브 타입 정제

### 정제 기준
* 서브타입 개체에 독자적으로 고유한 속성이 없거나 독자적인 관계가 없는 경우 -> 별도의 개체로 표현하지 않고 슈퍼 타입의 속성으로 표현
* 서브타입으로 분할했을 때 개념적 모델링이 너무 복잡한 경우
    * 분할하지 않음
* 서브 타입으로 분할된 수가 너무 많은 경우
    * 각각을 독립된 개체로 분리

### 슈퍼-서브 타입 정제 방법
* 슈퍼 타입 개체를 기준으로 통합하는 방법
* 서브타입 개체를 기준으로 통합하는 방법
* 슈퍼 타입과 서브 타입 개체를 각각 분리하는 방법

### 슈퍼 타입 개체 기준으로 통합하는 경우
* 응용 프로그램에서 서브타입을 구분해서 처리하지 않는 경우
* 서브 타입 개체에 속하는 데이터를 명확하게 구분하기 어려운 경우
* 서브 타입 개체에 사용되는 속성 수가 매우 적은 경우
* 서브타입 개체와 연결된 관계도 통합한다

### 서브 타입 개체 기준으로 통합하는 경우
* 응용 프로그램에서 서브 타입을 확실히 구분해서 처리하는 경우
* 슈퍼 타입 개체에 속하는 속성의 수가 많지 않은 경우
* 슈퍼 타입 개체의 관계가 적은 경우
* 슈퍼 타입 개체에 접근하는 응용 프로그램의 수가 적은 경우

통합방법
1. 슈퍼 타입 개체에 있던 모든 속성을 각각의 서브타입 개체로 이동한다
2. 슈퍼 타입 개체에 연결된 관계를 각각의 서브타입 개체에 연결한다
3. 슈퍼 타입 개체를 삭제한다

### 슈퍼 타입과 서브타입 개체를 각각 구분하는 경우
* 데이터 모델의 유연성을 보장해야 하는 경우
* 서브 타입을 구분해서 처리하는 응용 프로그램과 구분 없이 처리하는 응용 프로그램의 수가 비슷하고, 추후 다양한 응용 프로그램이 추가될 예정인 경우

각각 분리하는 방법
1. 슈퍼타입, 서브타입 개체를 각각 개별 개체로 분리한다
2. 분리된 슈퍼 타입 개체와 서브타입 개체를 1 : 1 관계로 연결한다
3. 서브타입 개체를 기준으로 1 : 1 관계를 단순화한다(슈퍼 타입 개체의 기본 키를 서브타입 개체의 기본 키로 추가함)

# 카테고리 정제
## 카테고리란? 
별개의 개체 타입들의 집합

## 카테고리 정제 방법
1. 카테고리(서브타입 개체)를 독립된 개체로 만들고, 기본 키를 포함시킨다
2. 카테고리에 속하는 모든 개체 타입(슈퍼 타입 개체)을 카테고리 개체와 각각 1 : N 관계로 연결한다

# 속성을 개체로 전환하기
## 속성 값이 없는 경우
많은 개체가 널 값을 갖는 속성은 별도의 개체로 분리하고, 원래 개체와 1 : 1 관계로 연결

## 속성 값이 여러 부분으로 구성된 경우
속성의 수가 많으면서 특징을 구분할 수 있는 여러 부분으로 구성된 경우, 특징 별로 별도의 개체로 분리(기본 키 포함)

사원 -> 사원, 급여정보, 학력정보

# 개체,관계 속성검증
## 개체 검증 방법
1. 유용한 정보를 제공하는가?
    * 업무에 활용되지 않고 값이 변하지 않는 개체는 삭제
2. 유일한 식별자(후보 키)를 포함하고 있는가?
    * 없다면 데이터의 일관성과 무결성 보장을 위해 설계 속성 추가
3. 속성의 수가 2개 이상인가?
    * 속성이 하나 밖에 없는 경우, 다른 개체의 속성으로 표현
4. 실제 데이터가 2개 이상 존재하는가?
    * 데이터가 하나 밖에 없다면 업무적으로 관리할 필요가 없는 개체일 가능성이 크기 때문에 삭제함

## 관계 검증 방법
1. 관계가 현재 업무 규칙에 적절한 것인가?
2. 관계명이 두 개체 사이의 업무적 연관성을 표현하는 구체적인 이름인가?
3. 관계의 유형이 적절한가?
4. 관계의 카디널리티가 적절한가?
5. 필수/선택 여부, 즉 전체 참여와 부분 참여가 적절한가?

## 속성 검증 방법
1. 각기 다른 의미를 갖는 여러 개의 속성을 묶어서 하나의 속성으로 정의한 것은 아닌가?
    * 그렇다면 각각을 별개의 속성으로 구분
2. 속성이 단 하나의 값만 갖는 것이 아닌가?
    * 모든 개체가 동일한 하나의 값만을 갖는 속성이 있다면 제거
3. 코드 값을 갖는 속성이 현업에서 통상적으로 사용되는 코드 값ㅇ르 갖는가?
    * 그렇지 않다면 코드 사용 억제
4. 전산 처리에 필요한 플래그 형태의 속성이 아닌가?
    * 플래그 형태의 속성은 제외시킴
        * 플래그 : 어떤 상태의 진위를 나타낼 때 사용하는 값이나 변수
        * 사원 개체의 연봉협상여부 등

# 논리적 설계
개념적 데이터 모델을 DBMS가 지원하는 논리적 데이터 모델로 변환하는 것

## 주요 업무
* 논리적 모델링 
    * ERD로 표현된 개념적 스키마를 논리적 스키마(릴레이션 스키마)로 변환한 다음, 정규화 과정을 통해 보다 바람직한 모델로 변환하고, 요구 분석 명세서를 기초로 무결성 제약조건을 정의함
* 트랜잭션 인터페이스 설계
    * 트랜잭션 모델링을 기초로 인터페이스를 설계함

## 릴레이션 스키마(Relation Schema)란?
가장 대표적인 논리적 데이터 모델인 관계 데이터 모델의 기본이 되는 릴레이션을 구성하는 속성들의 집합.  
릴레이션 이름과 속성 이름들로 표현한다.

## 릴레이션 스키마 변환 과정
1. ERD의 개체와 관계를 릴레이션 스키마로 변환
    * 릴레이션명(속성, 속성 ....)
2. 각 릴레이션 스키마에 기본 키 표시
    * 기본 키 아래 밑줄 표시
3. 가능한 경우 릴레이션 스키마의 단순화
    * 일 대 일, 일 대 다 관계 유형 단순화
4. 정규화 
    * 보다 바람직한 구조의 릴레이션 형태로 변경

## 개체 변환
### 단순 속성을 갖는 개체 변환 방법
변환 방법 : 모든 속성이 릴레이션의 속성이 됨  
기본 키 : 개체의 후보 키 가운데 하나가 릴레이션의 기본 키가 됨
### 복합 속성을 갖는 개체 변환 방법
변환 방법 : 복합 속성을 구성하는 모든 속성이 릴레이션의 속성이 됨  
기본 키 : 복합 속성이 일반 속성인 경우와 후보 키에 대응하는 속성인 경우를 구분해서 판단

* 복합 속성이 일반 속성인 경우
    * 개체의 후보 키 가운데 하나가 릴레이션의 기본 키가 됨
* 기본 키가 복합 속성인 경우
    * 복합 속성을 구성하는 모든 속성들이 기본 키가 됨
    * 릴레이션 스키마에서 연결된 선으로 표시한다
    * 선이 따로 있으면 기본 키가 여러 개란 뜻이다

## 약한 개체 변환
변환 방법 : 약한 개체 타입에 대해서 릴레이션을 생성하고, 약한 개체 타입에 속한 모든 단순 속성들을 릴레이션에 포함시키고, 소유 개체 타입의 기본 키를 약한 개체 타입의 외래 키로 포함시킨다.
기본 키 : 약한 개체 타입의 부분 키(구별자)와 소유 개체 타입의 릴레이션을 참조하는 외래 키(FK)의 조합, 긴 밑줄로 전부 연결한다.

* 외래 키로 포함시킴으로써 관계 타입이 릴레이션으로 표현된 것이므로, **식별 관계 타입을 별도로 릴레이션으로 변환할 필요가 없다**

## 관계 변환
### 관계 변환의 특징
관계를 설명하는 속성 뿐만 아니라 관계에 속하는 개체들의 기본 키 속성이 모두 릴레이션의 속성이 된다.

### 관계 릴레이션의 기본 키
관계의 유형에 따라 기본 키를 결정하는 방법에 차이가 있다

* 일 대 일 관계 변환 방법
    * 기본 키 : 관계에 포함된 양쪽 개체 기본 키 중 하나가 기본 키가 될 수 있다
* 일 대 다 관계 변환 방법
    * 기본 키 : 관계에 포함된 개체 가운데 n측의 기본 키가 기본 키가 된다
* 다 대 다 관계 변환 방법
    * 기본 키 : 관계에 포함된 양쪽 개체의 기본 키들을 구성하는 모든 속성들의 조합이 기본 키가 된다
    * 양쪽을 포함시키더라도 기본 키를 충족하지 못하는 경우가 있다. 그 경우에는 다른 속성을 기본 키로 같이 포함시켜야 한다.
    * 강사, 강좌, 강의일자 등
    * 이 경우 따로 기본 키의 역할을 할 설계 속성을 만들면 편하다
* 일 대 다 **순환 관계** 변환 방법
    * **관계 릴레이션을 별도로 생성하지 않고,** 개체의 기본 키를 외래 키로 포함시킨다.
    * 관계의 속성도 개체 릴레이션에 포함시킨다.
    * 기본 키 : 개체의 기존 기본 키가 그대로 기본 키가 된다
* 다 대 다 순환 관계 변환 방법
    * **관계 릴레이션을 별도로 생성하고,** 개체의 기본 키를 2개의 외래 키로 포함시킨다. 
    * 관계 자체의 속성이 있다면 그 속성도 관계 릴레이션에 포함시킨다
    * 기본 키 : 2개의 외래 키가 조합되어 관계 릴레이션의 기본 키가 된다
    * 주의사항 : 동일한 기본 키가 두 번 추가되므로, **두 개의 속성 이름이 서로 달라야 한다** 
* 3진 관계 변환
    * 관계의 릴레이션을 생성한다
    * 3 개체의 모든 키본 키를 외래 키로 만들어 관계 릴레이션의 기본 키로 사용한다
    * 기본 키의 조건이 되지 않는다면 추가로 다른 속성을 기본 키로 추가한다
    * 설계 속성을 추가하면 편해진다

## 다중치 속성 변환
변환 방법 : 다중치 속성을 위한 별도의 릴레이션을 생성하고, 다중치 속성을 갖는 개체 타입의 기본 키를 외래 키로 포함시킨다  
기본 키 : 외래 키와 다중치 속성의 조합이 기본 키가 된다


## 릴레이션 단순화
* 일 대 일 관계 단순화
    * 관계를 표현하는 릴레이션을 따로 생성하지 않고, 관계에 포함된 두 개체 릴레이션 가운데 하나에 통합해서 단순화 시킴
* 일 대 다 관계 단순화
    * 관계를 표현하는 릴레이션을 따로 생성하지 않고, 관계에 포함된 n측 개체 릴레이션에 1측 개체의 기본 키를 외래 키로 포함시키고 관계 자체의 속성도 포함시켜서 단순화 시킨다
* 부분관계면 하지 말라

## 개체 타입 통합
자세히 보지는 않는다

기본 키와 속성이 비슷하면 구별하는 속성을 추가하고 통합할 수 있다.




# 이력 데이터 모델링
## 이력(history) 데이터란??
하나의 업무 단위가 시간의 흐름에 따라 반복적으로 발생하거나 변경 또는 진행되는 과거 및 현재 데이터

## 이력 데이터 관리의 장점
* 과거 특정 시점의 데이터 조회 가능
* 변경 내역 관리 가능
* 오류 발생 시 현재 정보를 가장 최근 이력 정보로 복구 가능

## 고려사항
* 시간이 경과함에 따라 데이터가 변할 수 있나?
* 시간이 경과함에 따라 관계가 변할 수 있나? 
    * 각 개체간 관계가 바뀔 수 있다
* 과거 데이터를 조회할 필요가 있나?
* 변경 내역을 조회할 필요가 있나?
* 과거 버전을 보관할 필요가 있나?

## 이력 개체의 특징
* 하나의 개체에서 발생하는 이력을 관리하기 위해서 발생하는 개체로, 과거 특정 시점에 대한 정보를 제공하는 것을 목적으로 함
* 이럭 개체(약한 개체)의 기본 키는 부분 키에 소유 개체의 기본 키를 결합해서 지정하고, 필요하면 날짜나 일렬번호를 기본 키에 추가함
* 소유 개체의 기본 키는 이력 개체의 외래 키가 됨
* 이력 개체에 필요한 대부분의 속성은 소유 개체에 존재함

## 이력 데이터의 3가지 유형
### 발생 이력
* 데이터가 발생할 때마다 이력 정보를 남겨야 하는 경우
    * 약한 개체로 발생 이력 저장
* 요금청구, 이자계산, 급여계산 등

### 변경 이력
* 데이터가 변경될 때마다 변경 전후 차이를 확인해야 하는 경우
    * 약한 개체로 변경 이력 저장
    * 온라인 쇼핑몰에서 고객이 주문후 주문 정보를 변경하는 등

### 진행 이력
* 접수나 예약, 공사 진행 등과 같이 업무가 진행되는 상황을 남겨야 하는 경우
    * 언제, 누가, 어떤 업무를 했는지 약한 개체로 진행 이력 저장


## 이력 데이터 모델링 형태
### 시점 이력
* 데이터 변경이 발생한 시점만 관리하는 것
    * 환율이 변경되면 그 시점과 환율 저장, 환율이 언제 얼마로 변했는지, 정해진 시간이 없다

### 선분 이력
* 데이터 변경이 발생한 **시작 시점부터 종료 시점**까지 전체 시간을 관리하는 것
    * 각 통화의 특정 시간 동안 유효한 환율 관리??

# 코드 데이터 모델링
## 코드란?
업무 또는 정보시스템에서 쉽게 구분할 수 있도록 데이터들을 간단하게 구분해 놓은 단위

## 코드 구분
1. 한 개의 값(속성)이 반복적으로 나타나는 코드
2. 여러 개의 값(속성)이 반복적으로 나타나는 코드
    * 너무 코드가 복잡하고 많아지면 그냥 나누는게 좋다

## 코드 데이터 모델링 시 유의사항
* 코드 개체는 주로 코드 값을 참조하는 용도로 사용되므로 다른 개체와 관계를 맺지 않아도 된다
* 코드를 코드 값으로 변환할 때 SQL문에서 조인이나 DECODE문 등을 사용해서 변환하거나 응용 프로그램을 통해서 변환할 수 있다


# 무결성 제약조건 
* DB에 저장된 데이터의 정확성과 일관성 유지를 위해서 DB가 항상 만족해야 하는 조건
* 데이터의 정확성, 유효성, 일관성, 신뢰성을 보장하기 위해서 **무분별한 데이터 갱신으로부터 데이터를 보호**하려면 무결성 제약조건이 필요하다

## 관계 테이터 모델의 무결성 제약조건
* 개체 무결성 : 기본 키는 튜플들을 유일하게 식별하기 위해 널 값을 가질 수 없다는 제약조건
* 참조 무결성 : 외래 키는 반드시 피참조 릴레이션의 기본 키 값이나 널 값을 가져야 한다는 제약조건
* 도메인 무결성 : 특정 속성이 반드시 미리 정의된 도메인에 존재하는 값을 가져야 한댜는 제약조건
* 사용자 정의 무결성 : 위의 3가지 무결성 범주에 포함되지 않는 특정 업무 규칙을 명시적으로 정의한 제약조건

## 개체 무결성
* 기본 키는 널값 가지면 안됨
* 기본 키는 개체를 유일하게 식별할 수 있어야 함
* 기본 키는 유일성을 보장하는 최소한의 집합이어야 함

### 기본 키 선정시 유의사항
* 기본 키는 변경되지 않아야 함
* 데이터 보안이 요구되지 않아야 함
* 후보 키 가운데 업무 활용도가 높고 업무상 의미 있으며, 개체의 특성을 잘 나타내는 속성 선택

## 무결성 제약조건 정의 방법
* 묵시적 정의 : 릴레이션을 정의할 때 기본 키와 외래 키를 정의하면, 개체무결성과 참조 무결성이 묵시적으로 정의됨
* 명시적 정의 : 개체 무결성과 참조 무결성 이외에, 데이터의 정확성과 일관성 유지를 위해서 특정 속성이 만족해야 하는 무결성 제약조건은 명시적으로 정의해야 함


# 데이터 표준화
## 데이터 표준화란? 
시스템 별로 산재되어 있는 데이터의 명칭과 정의, 규칙, 형식 등에 대한 원칙을 수립해서 전사적으로 적용하는 것

# 트랜잭션 인터페이스 설계
사용자 그룹별 접근 가능한 범위와 DB 서버에 접근하는 방법 등을 결정해서 트랜잭션 전체적인 골격 및 인터페이스를 정의함

## 주요 업무
* 그룹별 접근 가능 데이터 범위 정하고, 접근 방법 및 인터페이스를 절차적 기술
* DB서버에 접근하는 방법

# 릴레이션 정규화
## 갱신 이상(Update Anomaly)
관계 DB를 조작할 때 데이터의 중복으로 인해 발생하는 문제

* 갱신 이상의 종류
    * 삽입 이상
        * **불필요한 데이터를 함께 삽입**하지 않으면 어떤 데이터를 삽입하는 것이 불가능한 문제
    * 수정 이상
        * **중복된 데이터 가운데 일부만 수정**되어 데이터의 불일치가 발생하는 문제
    * 삭제 이상
        * 어떤 데이터를 삭제하면 **유용한 데이터도 함께 삭제**되는 문제

### 갱신이상의 원인
릴레이션 스키마를 생성할 때 속성들 간의 종속성을 충분히 고려하지 않아서 불필요한 데이터가 중복되었기 때문. 즉, 한 개체의 속성들 간에 존재하는 **여러 개의 종속 관계를 하나의 릴레이션으로 표현**했기 때문이다.

### 갱신 이상 해결 방법
릴레이션 스크마를 변환해서 속성들 간의 여러 종속 관계를 분해해야 한다.

릴레이션을 분해해서 하나의 종속관계는 하나의 릴레이션으로 표현해야 한다. 


## 함수적 종속
속성들 간의 대응관계를 보다 수학적으로 규명하기 위한 이론. 릴레이션이 갖고 있는 갱신 이상을 발견하기 위한 수단이다.

### 함수적 종속 표현방법
속성 Y는 속성 X에 함수적으로 종속된다 : X -> Y  
X : 결정자, Y : 종속자

## 함수적 종속 다이어그램(FDD)
함수적 종속 관계를 그림으로 표현하는 방법, 화살표로 연결해서 종속관계를 표현한다

## 완전 함수적 종속과 부분 함수적 종속
결정자가 복합 속성인 경우 구별해야 한다.

* 완전함수종속 
    * 결정자인 복합 속성에 포함되는 속성 가운데 단독으로 결정자 역할을 하는 속성이 없으면 종속자가 결정자에 완전 함수적 종속이라고 한다
* 부분 함수 종속
    * 결정자인 복합 속성에 포함되는 속성 가운데 단독으로 결정자 역할을 하는 속성이 있으면 종속자가 결정자에 부분 함수적 종속이라고 한다
* 이행적 함수적 종속
    * 한 릴레이션의 속성 a,b,c 가 다음과 같은 필요충분조건을 만족하는 경우
        * A -> B ^ B -> C
        * 속성 C가 속성 A에 이행적 함수적 종속이라고 한다

## 정규화란?
* 스키마 변환을 통해서 일련의 제약 조건을 만족하는 릴레이션을 만드는 과정 
* 속성들 간의 종속성을 분석해서 **하나의 릴레이션에는 하나의 종속성만 갖도록 릴레이션을 분해**하는 과정
* 갱신 이상의 발생 요인인 데이터 중복을 최소화하기 위해 제약조건을 기초로 릴레이션을 분해하는 과정

## 정규화 원칙
1. 데이터의 중복을 최소화
2. 정보가 사라지지 않아야 한다
    * 같은 의미의 정보를 유지하면서 더 바람직한 구조로 변환해야 한다
3. 분리 원칙에 따라 분해해야 한다
    * 독립적인 관련성은 별개의 릴레이션으로 표현한다
    * 릴레이션 각각에 대해 독립적인 조작이 가능해야 한다

## 정규화되지 않은 릴레이션의 문제점
* 데이터 중복으로 인해 갱신 이상 현상이 발생함
* 특정 정보를 표현하는 것이 불가능할 수 있음
* 널값을 많이 포함하게 됨
* 저장된 정보가 부정확할 수 있음

## 정규화 효과
* 중복된 데이터가 제거되어 갱신 이상이 감소함
* 데이터의 일관성 유지가 가능함
* 데이터 모델이 단순해짐
* 무결성 제약조건을 만족시키기 위해서 필요한 프로그램 코드 양이 감소함

## 정규화 문제점
릴레이션 분해로 인해 많은 조인 연산이 발생하므로 질의에 대한 응답시간이 느려질 수 있음

* 조인연산이란?
    * 두 릴레이션과 관련된 튜플을 하나의 튜플로 결합하는 연산으로, 두 릴레이션의 각 튜플들을 1 : 1 로 대응시킨 다음, 조건에 맞는 튜플들로만 구하는 연산

## 정규형
어떤 일련의 제약조건을 만족하는 릴레이션을 의미함

## 정규형 구분
데이터의 불필요한 중복 감소와 응답시간 단축이라는 상반된 목표를 달성하기 위해 릴레이션이 만족해야 하는 제약조건 구분

* 제약조건에 따라 제1정규형 ~ 제5정규형 그리고 보이스코드 정규형으로 구분함
* 정규형의 차수가 높아질수록 제약조건이 더 많아짐
* 관계형 DB는 제 1정규형만 취급함

## 정규화 단계
1. 원자값이 아닌 도메인 분해
2. 부분 함수적 종속 제거
    * 모든 속성이 기본 키에 완전 함수적 종속이어야 한다
3. 이행적 함수적 종속 제거
    * 속성들 간에 이행적 함수적 종속이 없어야 한다
4. 결정자가 후보 키가 아닌 함수적 종속 제거
5. 함수적 종속이 아닌 다치 종속성 제거
6. 후보 키를 통하지 않은 조인 속성 제거

제3 정규형을 최종 목표로 한다


### 다중치 속성을 포함하는 비정규형
1. 복구 개의 값 각각에 대해 하나씩의 튜플을 생성해서 새로운 릴레이션 생성
2. 동일한 값이 중복되어 나타나는 반복 그룹을 분리해서 2개의 새로운 릴레이션을 만듬


### 제 1정규형
제 1 정규형은 어떤 릴레이션 R에 속한 모든 속성들의 도메인이 원자 값이어야 한다는 제약조건을 만족하는 릴레이션

* 제1 정규형의 갱신 이상의 원인
    * 기본 키에 부분 함수적 종속 관계가 존재할 때 갱신 이상 현상 발생
        * 기본 키로 식별되는 개체와는 무관한 속성이 존재한다는 의미 즉, 두 가지 독립적인 정보가  하나의 릴레이션에 표현된 것
* 해결방법
    * 릴레이션을 분해하여 부분 함수적 종속을 제거히여 제 2 정규형을 만듦

* 무손실 분해
    * 프로젝션으로 분해된 릴레이션들은 조인을 통해 원래의 릴레이션으로 복귀될 수 있어야 함
    * 원래의 릴레이션에서 얻을 수 있는 정보는 분해된 릴레이션들로부터도 얻을 수 있으나 , 그 역은 성립하지 않는다

### 제 2정규형
제 2정규형은 어떤 릴레이션 R이 제 1정규형이면서 기본 키가 아닌 모든 속성이 기본 키에 완전 함수적 종속이어야 한다는 제약조건을 만족하는 릴레이션

* 제 2정규형의 갱신 이상의 원인
    * 이행적 함수적 종속 관계가 존재할 때 갱신 이상 현상 발생
* 제 2정규형의 갱신 이상 해결 방법
    * 릴레이션을 분해해서 이행적 함수적 종속을 제거하여 제 3정규형을 만듦
* 예
    * 지도받다(함수, 지도교수, 학과) -> 지도교수만 알아도 학과를 알 수 있다
    * 삽입 이상, 삭제 이상, 수정 이상 발생
* 제 2정규형 갱신 이상 해결
    * 릴레이션을 분해한다
    * 학생지도(학번, 지도교수(FK)), 교수소속(교수, 학과)

* 무손실 분해
    * 원래의 릴레이션에서 얻을 수 있는 정보는 분해된 릴레이션들로부터도 얻을 수 있으나, 그 역은 성립하지 않는다
    

### 제 3정규형
어떤 릴레이션 R에 제 2정규형이면서 기본 키가 아닌 모든 속성이 기본 키에 이행적 함수적 조건이 아니라는 제약조건을 만족하는 릴레이션

* 제 3정규형의 갱신 이상의 원인
    * 후보 키가 아닌 결정자가 존재할 때 갱신 이상 현상 발생
* 제 3정규형의 갱신 이상 해결 방법
    * 후보 키가 아니면서 결정자 역할을 하는 속성과 그 종속자를 분리해서, **모든 결정자가 후보 키가 되는 보이스/코드 정규형**으로 만듦
* 예시
    * 수강교과목((학번, 교과목)(pk), 담당교수)
    * 담당교수만 알아도 교과목을 알 수 있다 -> 삽입 이상, 삭제 이상, 수정 이상
* 갱신 이상 해결 : 릴레이션 분해
    * 후보 키가 아니면서 결정자 역할을 하는 담당교수 속성과 그 결정자에 함수적으로 종속하는 속성인 교과목 속성을 별도의 릴레이션으로 분해하고, 결정자 속성을 기본키로 정의
    * 교수담당교과목(담당교수, 교과목), 수강담당교수(학번, 담당교수)
* 약점
    * 복수의 후보 키를 갖고 있고, 후보 키들이 복합 속성으로 구성되고, 서로 중첩되는 경우에는 또 분리해야 한다

## 역정규화
정규화 단계가 진행될수록 릴레이션이 분해됨으로 원하는 정보를 얻기 위해 조인의 필요성 증가 -> 성능 저하

* 성능에 대한 요구를 만족시키기 위해 데이터 중복과 갱신 이상을 대가로 치르며 보다 낮은 정규형으로 되돌아가는 것
* 빈번하게 수행되는 검색 질의의 수행 속도를 높이기 위해 이미 분해된 두 개 이상의 릴레이션을 합쳐서 하나의 릴레이션으로 만드는 작업
* 대신 응용 프로그램에서 별도로 데이터 무결성을 보장하기 위한 비용이 발생될 수 있다



# 물리적 설계
## 물리적 모델링 주요 업무
1. 논리적 스키마를 기초로, DBMS의 특정과 구현 환경 등을 고려해서 내부 스키마 정의
2. 속성 즉, 테이블 갈럼의 데이터 타입과 크기, 제약조건 등 정의
3. 데이터 사용량의 예측을 통해서 역정규화 및 인덱스 설계 작업 수행

## 물리적 모델링의 특징
1. 논리적 모델링의 결과물인 하나의 릴레이션이 물리적으로 하나 이상의 테이블이 될 수 있음
2. 논리적 모델링을 기초로 시스템 환경(하드웨어, 운영체제, 디스크 용량, 네트워크, DBMS 제품 등)을 고려해서, 성능 향상을 목적으로 물리적 모델링 수행
3. 시스템 환경이 변경되면 물리적 모델링도 변경됨
4. 성능을 고려해서 통계 테이블이 추가되거나, 백업이나 복제 용도의 테이블이 추가될 수 있음


## 물리적 모델링 시 고려사항
1. 응답시간(Response Time)
    * DBMS가 트랜잭션을 처리해서 결과를 반환하는데 소요되는 시간인 응답시간을 최소화하도록 해야 한다
2. 저장 공간
    * DB 파일이나 인덱스 등을 저장하는데 필요한 저장 공간을 최소화하도록 해야 한다
3. 트랜잭션 처리도
    * 단위 시간당 처리할 수 있는 평균 트랜잭션의 수를 나타내는 트랜잭션 처리도가 성능에 큰 영향을 줌으로, 트랜잭션 처리도가 향상되도록 해야 한다


## 내부 스키마란?
논리적 스키마와 무결성 제약조건 정의를 기초로 생성한 저장 레코드 양식을 의미하며, 릴레이션을 테이블로 표현하고, 속성은 칼럼으로, 관련성은 외래 키로 표현하며, 데이터 타입과 크기, 제약조건 등을 포함한다.

### 물리적 구조 변경 방법
* 테이블 재정의
    * 성능 향상을 위해 역정규화를 통해서 테이블 구조를 재정의 할 수 있음
        * 사소한 성능 향상을 위해 데이터 무결성이 저해되지 않아야 함
        * 정규형 모델에 심각한 성능 저하를 유발하는 요건이 존재하는 경우에만 역정규화 함
    * 성능 향상을 위해 중복된 정보를 포함하는 테이블을 추가할 수 있음
    * 성능 향상을 위해 테이블을 수직 또는 수평 분할할 수 있음
* 칼럼 중복
    * 조인이 빈번하게 발생하는 경우 조인 조건에 해당하는 속성 중복
        * 자주 사용되는 검색 조건이 여러 테이블에 분산되어 있는 경우, 검색 조건에 포함되는 칼럼을 다른 테이블에 복사
    * 접근 경로를 단축하기 위해 부모 테이블에 자식 테이블의 특정 칼럼의 집계 값을 저장하는 칼럼 추가
    * 연관된 결과를 주로 사용하는 경우 연산된 값을 저장하는 칼럼 추가

## 테이블 추가
* 통계 테이블 추가
    * 자주 사용되는 통계 데이터가 여러 테입르에 산재되어 있는 데이터를 기초로 생성될 경우, 별도의 통계 테이블을 생성해서 추가함
* 부분 테이블 추가
    * 대용량 테이블의 특정 부분만 주로 사용되는 경우, 해당 부분만 복사해서 별도의 테이블을 생성할 수 있음

## 테이블 분할
* 수직 분할
    * 특정 칼럼을 분리해서 별도의 테이블로 관리함으로써 물리적인 I/O 양을 감소시켜서 검색 성능을 향상시킴
    * 자주 갱신, 자주 조회 각 따로 분할
* 수평 분할
    * 테이블의 행을 기준으로 분할해서 별도의 테이블로 괸리함으로써 물리적인 I/O 양을 감소시켜서 검색 성능을 향상시킴

## 칼럼 중복
* 동일 칼럼 추가
    * 검색 성능을 향상시키기 위해 자주 검색되는 칼럼을 중복시킴, 중복되는 칼럼은 변경이 거의 일어나지 않아야 함
* 파생 칼럼 추가
    * 다른 칼럼 값들을 기초로 계산된 합계, 평균, 개수 등의 파생된 값이 많이 활용되는 경우, 파생 칼럼을 추가하면 검색 성능이 향상됨
    * 데이터 무결성을 보장하기 위해 파생된 값의 기초가 되는 원래 칼럼의 값이 변경되는 경우, 파생된 값도 연쇄적으로 변경되도록 정의해야 함
* 기본 키의 일부에 해당하는 칼럼 추가
    * 기본 키가 여러 가지 정보를 포함하고 있는 경우, 그중 일부가 자주 사용되면 분리해서 별도의 칼럼을 추가

## 인덱스란?
* 포인터를 사용해서 행(ROW)의 검색을 촉진할 수 있는 DB 객체
* 인덱스가 DB 성능에 큰 영향을 주므로, 트랜잭션의 양과 데이터 분포, 사용 빈도 등을 고려해서 적절한 수의 인덱스를 설계해야 함

## 인덱스의 특징
1. 테이블 행에 대한 직접적이고 빠른 접근 제공
2. 인덱스는 행을 식별할 수 있도록 칼럼의 값과 행의 논리적인 주소로 구성되며, 별도의 저장공간에 저장됨
3. 인덱스는 DBMS에 의해서 자동으로 생성되거나, 사용자에 의해 명시적으로 생성될 수 있음
4. 인덱스를 생성하면 일반적으로 물리적인 디스크 I/O가 감소되지만, 인덱스를 너무 많이 생성하면 오히려 DML 처리 효율을 저하시킴
5. 인덱스는 DBMS에 의해서 자동으로 사용되고 유지됨
6. 인덱스는 테이블과는 논리적, 물리적으로 독립적임
7. 기본 테이블에 영향을 주지 않고 생성하거나 제거할 수 있음
8. 기본 테이블을 제거하면, 인덱스도 자동으로 제거됨

## 인덱스 선성 시 고려사항
1. 데이터 양이 적은 테이블은 인덱스를 생서하는 것보다 전체 테이블 스캔이 더 효율적
2. 인덱스가 많으면 검색 속도는 향상되지만 갱신 처리시에 오버헤드 발생
3. 검색과 나머지 DMS의 비용은 1 : 4 정도이므로 검색 효율만을 위해서 지나치게 많은 인덱스를 생성하는 것은 좋지 않음
4. 검색 대상이 넓은 경우, 즉 전체 데이터 가운데 상당수의 데이터를 검색 하는 경우, 인덱슬르 사용하는 것은 오히려 비효율적

## 인덱스 선정 기준
* 분포도가 좋은 칼럼(데이터 종류가 많은 칼럼)은 인덱스를 단독으로 생성해서 활용도를 향상시킴
* SQL문의 WHERE절, ORDER BY절, GROUP BY절에 자주 사용되는 칼럼에 인덱스 생성
* 기본 키에 대해서는 인덱스가 자동으로 생성되므로 별도 생성 불필요
* 자주 조합되어 사용되는 칼럼의 경우, 결합 인덱스 생성
* 테이블 간의 조인 조건으로 자주 사용되는 컬럼에 인덱스 생성
* 실제로 사용될 접근을 기초로 인덱스 선정


## 인덱스로 부적합한 대상
* 수정이 자주 발생되는 칼럼
* 분포도가 좋지 않음 칼럼
* 검색되는 행이 전체 행의 대부분에 해당하는 경우
* 검색 조건으로 자주 사용되지 않는 칼럼

## 인댁스 대상 선정
1. 먼저 대상 테이블을 선정한 다음 SQL문에서 조인 조건(WHERE절)으로 자주 사용되거나, ORDER BY절, GROUP BY절 등에서 자주 사용되는 칼럼 선정
2. 자주 사용되는 칼럼 가운데 평균 분포도가 10% 이내 또는 15%이내인 칼럼 선정
    * 분포도 = 1 / 칼럼 값의 종류 * 100 = 해당 칼럼 값을 갖는 행의 평균 수 / 테이블의 총 행의 개수 * 100
3. 자주 조합되어 사용되는 칼럼의 경우, 결합 인덱스 생성


