# 데이터베이스 구축의 6단계
1. [요구수집 및 분석](#요구수집-및-분석)
2. [개념적 설계](#개념적-설계)
3. DBMS 선정
4. [논리적 설계](#논리적-설계)
5. 물리적 설계
6. 구현 및 테스트

# 트랜잭션이란?
DB에서 작업의 기본 단위로서, 데이터를 일관되게 변경하는 하나 이상의 데이터 조작어 문장으로 구성됨.

# DB 설계 전략
* 데이터 중심 DB 설계
    * DB의 내용과 구조에 치중해서 설계하는 방법
* 처리 중심 DB 설계
    * 데이터의 처리와 응용에 치중해서 설계하는 방법
* 2가지를 병행해서 진행하는 것이 일반적이다

# DBMS 선정 기준
경제성, 논리적 데이터 모델, 운영환경등에 따라 결정해야 한다.

# DB구축 시 고려사항
* 무결성 
    * DB에 저장된 데이터가 제약조건을 만족해야 한다
* 일관성 
    * 저장된 데이터들 간에, 또는 특정 질의에 대한 응답들 간에 모순이 없어야 한다
* 회복
    * 시스템에 장애가 발생한 경우, 장애 발생 이전의 일관된 DB 상태로 복구 가능해야 한다
* 보안 
    * 불법적인 접근에 대해 보호 가능해야 한다
* 효율성 
    * 응답시간 단축, 저장 공간 최적화, 시스템의 생산성 등을 고려해야 한다
* 확장
    * 시스템에 영향을 주지 않고 새로운 응용 프로그램이나 데이터를 추가할 수 있어야 한다

# 요구 수집 및 분석 단계의 주요 업무
1. 사용자 그룹 및 담당자 식별
2. 요구사항 수집
    1. 사용자의 요구사항 수집
    2. 범 기관적 제약조건 파악
    3. 기존 문서 조사
3. 요구사항 분석
    1. 업무 영역 분할
    2. 상세 업무 분석
4. 요구 분석 명세서 작성
5. 수용 범위 결정

* 범 기관적 제약조건 예 : 표준 용어, 표준 코드, 표준 도메인 등

# 개념적 설계란?
요구 분석 명세서를 기초로 DBMS와는 무관한 추상적인 형태로 사용자의 요구를 표현하는 것

## 개념적 설계의 주요 업무
개념적 모델링 + 트랜잭션 모델링 

* 개념적 모델링
    * 데이터 중심 설계
    * 데이터 요구분석 명세서를 기초로 ER 모델 산출
    * 결과물 : ER 다이어그램
* 트랜잭션 모델링
    * 처리 중심 설계
    * 트랜잭션 요구 분석 명세서를 기초로 업무 단위의 유형별 트랜잭션 나열 
    * 결과물 : 트랜잭션 명세서

# DBMS 선정 기준
* 논리적 데이터 모델 
    * 개념적 설계 단계의 산출물인 개념적 DB 스키마를 가장 효율적이고 안정적으로 표현할 수 있는 논리적 데이터 모델을 기초로 하는 DBMS 선택
* 운영 환경
    * DB를 구축할 하드웨어 환경과 운영체제 등을 고려해서 운영 환경에 적합한 DBMS 선택
* 경제성
    * DBMS의 가격과 하드웨어 구입 비용, 교육 비용, 운영 비용, 유지 비용 등 경제적인 측면을 고려해서 DBMS선택

# 논리적 설계란?
개념적 데이터 모델(개념적 스키마)을 DBMS가 지원하는 논리적 데이터 모델(논리적 스키마)로 변환하는 것


논리적 모델링 -> 트랜잭션 인터페이스 설계 -> 스키마 평가 및 정제

* 논리적 모델링 
    * 릴레이션 스키마
    * 무결성 제약조건 정의


# 물리적 설계란?
논리적 스키마(릴레이션 스키마와 무결성 제약조건)를 기초로 내부 스키마(물리적 데이터 구조)로 변환하는 것

물리적 모델링 + 트랜잭션 상세 설계


# 구현 및 테스트 단계
* 설계된 DB 구조를 DDL로 생성한다
* 기존 DB를 새로운 DB로 변환한다
* DB에 초기 데이터를 적재 한다
* 트랜잭션 처리용 응용 프로그램을 작성한다
* 유지보수를 위한 문서화 작업을 한다

# 테스트 단계
* 생성된 DB구조가 설계된 DB 구조와 일치하는지 확인
* 응용 프로그램과 DB의 연동이 원할한 지 확인
* 트랜잭션 유형별로 테스트 케이스를 선정하여, 데이터 조작이 원할한지 확인




# 요구수집 및 분석
## 요구 수집 단계의 주요 업무
* DB에 대한 잠재적인 사용자를 식별하고, 사용자가 원하는 DB의 용도 파악
* DB가 제공해야 할 정보 내역 수집
* 요구 수집한 내역을 체계적으로 정리하여 요구 분석의 기초 자료가 될 수 있도록 **요구 수집 명세서 작성**

## 요구 수집 방법
* 요구를 수집할 사용자 그룹 및 업무 담당자 식별
    * 직, 간접적인 방법을 통해서 전체적인 요구 사항 수집
* 범 기관적인 제약조건 식별
    * 기관의 규정, 표준 용어, 표준 도메인 등 파악
* 기준 문서 조사
    * 각종 양식, 보고서, 응용 프로그램 관련 메뉴얼 등
* 운영 환경 파악
    * DB 운영할 컴퓨터 환경, 업무 환경 등
* 요구 수집 명세서 작성

## 요구 분석 단계 주요 업무
1. 업무 영역 분할
    * 다양한 요구 수집 산출물을 기초로 업무 영역 분할도 작성
2. 요구 분석 명세서 작성 
    * 업무별 데이터 요구 분석 명세서 작성
    * 업무별 트랜잭션 요구 분석 명세서 작성
3. 요구사항 수용 범위 결정
    * 우선순위가 높고 제한된 기한 내에 구현 가능한 요구사항만 수용

## 요구 분석이 중요한 이유
요구 분석에 오류가 발생하면 아무리 많은 시간과 노력을 투자해도 원하는 시스템을 구축하기 어려운 경우가 많기 때문

## 업무 영역 분할
### 업무 영역 분할도
* 전체 업무를 요구 분석의 기본 단위가 되는 소단위의 업무 영역으로 분할하여 계층구조 형태로 표현한 것
* 조직의 업무 영역 분할이 명확한 경우, 이 과정을 생략하고 기존에 분할된 업무 영역 단위로 요구사항을 분석해도 됨 

## 데이터 요구 분석 명세서
요구 분석 단계의 중요한 산출물로서, 데이터 중심 DB 설계에 근거하여 업무별로 요구되는 데이터를 분석한 결과를 문서화한 것으로, 일종의 업무처리 규정문이라고 볼 수 있음

* 개체들의 속성과 개체와 개체사이의 관계는 어떤 것이 있는지 찾는데 필요한 정보를 넣는다.
* 단순 데이터 처리가 아니라, 어떤 관련된 업무가 있는지 관계는 어떤지 등등
## 트랜잭션 요구 분석 명세서
요구 분석 단계의 중요한 산출물로서, **처리 중심 DB 설계**에 근거해서 업무별로 요구되는 트랜잭션 즉, **데이터 조작 작업**을 문서화한 것

데이터 조작의 주체는 상관없이 해당 데이터를 조작하는 모든 과정을 분석하는 것

## 트랜잭션 요구 분석 명세서 작성 시 유의사항
* 분할된 업무 영역별로 요구되는 데이터 조작 작업을 간단히 표현한다
* 한 번에 하나의 데이터 조작만 포함하도록 작성한다
* 데이터 조작을 가능한 검색, 삽입, 삭제, 변경이라는 용어를 사용해서 표현한다
* 추후 트랜잭션 처리용 응용 프로그램을 작성할 때 참조가 되도록 작성한다

## 요구 분석의 특성
* 요구사항은 계속 변화한다
* 요구사항은 점차 확장된다
* 요구사항은 불완전하다
* 요구사항은 생명주기가 있다

## 요구 분석 명세서 검토 질문
* 요구사항이 이해하기 쉬운가
* 정확히 표현되었는가
* 애매모호하지는 않는가
* 필요를 충족시키는가
* 빈드시 필요한가
* 기한내에 수용할 수 있는가



# 개념적 설계
요구 분석 명세서를 토대로 DBMS와는 무관한 추상적인 형태의 사용자의 요구사항을 표현하는 것

## 개념적 설계 단계의 2가지 주요 업무
* 개념적 모델링
    * 데이터 중심의 DB 설계에 해당하며, 데이터 요구 분석 명세서를 기초로 ER 모델을 산출하고, ER 다이어그램으로 표현함
    * 개념적 스키마 모델링이라고도 칭함
* 트랜잭션 모델링
    * 처리(프로세스) 중심의 DB 설계에 해당하며, 트랜잭션 요구 분석 명세서를 기초로 업무 단위의 유형별 트랜잭션을 설계함

## 개념적 모델링
요구 분석 명세서를 토대로 DBMS와는 무관한 추상적인 형태로 사용자의 요구사항을 표현하는 것

ER 모델로 표현한다. ER 다이어그램으로 표현한 개념적 모델링 결과를 개념적 구조 혹은 개념적 스키마라고 한다

## 개념적 모델링 방법
### ER 모델 도출 순서
* 명세서를 기초로 핵심 개체 타입 식별
* 개체간의 관계 타입 식별
* 관계타입의 유형과 카디널리티 결정
* 개체 타입의 속성 식별
* 개체 타입의 식별자(후보 키) 결정
* 관계 타입의 속성 식별
* 개체 타입과 관계 타입, 속성을 모두 ERD로 표현
* ERD가 모든 요구사항을 반영하는지 검증


### 개체 식별
* 개체
    * DB가 표현하려고 하는 유형, 무형의 정보 대상으로, "존재하면서 서로 구별될 수 있는 요소"
* 개체 식별의 중요성
    * 설계 단계에서 개체 식별은 중요하고, 어떤 개체가 식별되냐에 따라 속성과 관계가 달라질 수 있음
    * 개체 하나에 평균 5개 정도의 응용 프로그램이 개발되므로 개체 식별이 DB 구축의 성패를 좌우함

### 개체 식별 방법
* 개체 후보 식별
    * 데이터 요구 분석 명세서에서 주로 주어나 목적어로 표현된 것이 개체 후보
* 개체 후보 검토
    * 각 개체 후보의 실제 데이터 수와 대표 속성 파악
    * 동음이의어, 이음동의어 검토
    * 동사로 표현된 것이 개체로 잘못 추출된 것이 있는지 검토하고, 필요한 경우 개체 이름도 변경
* 최종 개체 선정
    * 실제 데이터가 2개 이상 존재하고, 2개 이상의 속성을 갖고 있는 개체 후보를 최종 개체로 선정
    * 동일한 의미를 갖는 개체가 있으면 제외시킴

### 개체 표현 방법
* 피터 첸 표기법
    * 하나 이상의 속성과 연결된 직사각형으로 표현하고, 식별자는 밑줄로 표시
* IE 표기법
    * 개체를 사각형으로 구분하고, 사각형 위에 개체 이름을 표시

### 개체 이름 부여 방법
* DB 내에서 유일
* 현업의 표준 용어를 사용
* 단수 명사사용
* 약어사용 하지말자
* 성격을 쉽게 알게
* 이름 부여 규칙을 미리 정하기
* 자료 사전 또는 용어 사전을 만들어 참조

### 개체 식별시 주의사항
* 개체가 될 가능성있는 모든 대상 추출하기
* 유사한 개체도 모두 추출하기
* 어떤 대상이 해당 개체에 속하는지 분명하도록 각 개체 정의하기
* 업무 처리 과정을 지나치게 고려하지 않기
* 개념은 확실히 잡고 가기
* 예외 상황은 일단 무시하고 넘어가기
* 최종적 선정되면 핵심 특징 파악하기

## 관계 식별
* 관계
    * 개체들 간의 의미 있는 연결 또는 연관성을 의미하는 요소 
### 관계 식별 방법
1. 명세서에서 동사로 표현된 부분이 관련성을 표현하는 경우
2. 식별된 개체중 관계로 표현하는 것이 더 적합한 경우
3. 관계 이름 부여
4. 관계 유형 설정
5. 관계를 설명하는 속성 파악
6. 관계 이름과 유형, 속성 등이 포함된 최종 관계 목록 작성

### 관계 식별 시 유의사항
* 관계는 개체들 간의 상호 연관성으로, 개체와 관련된 업무를 수행하는 일종의 업무 규칙에 해당 -> 주로 동사
* 업무를 충분히 파악한 다음 전체 업무를 고려해서 넓은 시각으로 분석
* 업무 규칙이 변경됨에 따라 관계도 변경될 수 있음
* 식별된 개체 가운데 '관계'로 표현하는 것이 적합한 것이 있는지 검토
* 관계는 관계에 포함된 양쪽 개체의 식별자를 속성으로 갖게 됨

### 관계 표현 방법
* 피터 첸
* IE

### 관계 이름 부여 방법
* 가능한 두 개체의 연관성을 나타내는 동사
* 현재 시제
* 개체들 간의 관련성이 명확하도록 표현
* 관계 이름은 DB 내에서 유일해야 함
* 부연 설명이 필요없는 일반적인 용어로 표현

## 속성 식별
### 속성 식별 방법
1. 데이터 요구 분석 명세서에서 개체를 설명하는 명사를 속성으로 식별
2. 관계를 설명하는 명사를 관계속성으로 식별
3. 후보키가 없으면 후보키 역할을 할 속성 추가
4. 추가적으로 필요한 속성 식별


### 유의사항
* 유일한 식별자
* 가능한 모든 속성 식별
* 필요한 경우 속성 이름 변경

### 식별자 관련 유의사항
* 모든 개체는 하나 이상의 식별자(후보 키)를 포함
* 식별자는 반드시 유일한 값을 가져야 함
* 식별자는 불변값
* 최종 식별자 즉 기본키는 논리적 모델링 단계에서 식별자 가운데 하나를 선택해서 결정 가능

### 속성 표현 방법
* 피터 첸
    * 각 속성은 타원
    * 후보키는 밑줄
* IE
    * 식별자와 설명자를 구분해서 표현

### 이름 부여 방법
* 한 개체 안에서는 유일해야 함
* 유지보수할때 불편하니까 개체 이름을 속성 이름의 접두어로 사용하지 않는다
* 현업의 표준 언어 사용
* 단어와 단어는 '_' 로 연결


## ER 다이어그램 작성
1. 개체 타입 표시
2. 개체 타입들 간의 관계 표시
3. 관계 타입의 유형 표시
4. 관계 타입의 카디널리티 표시
5. 개체 타입의 속성 표시
6. 관계 타입의 속성 표시


# 트랜잭션 모델링
## 트랜잭션이란?
* 하나의 논리적 기능을 수행하기 위한 작업 단위로서, 데이터를 일관되게 변경하는 하나 이상의 데이터 조작 명령문으로 구성됨
* DB의 무결성이 보장되는 상태에서 요청된 작업을 완수하기 위한 작업의 기본 단위로 간주됨

## 트랜잭션 모델링 주요 업무
업무 단위별로 데이터 조작 작업을 유형별로 세분해서 명세서 작성, 데이터 조작과 관련된 제약조건도 정의

## 트랜잭션 모델링의 필요성
* 주요 트랜잭션의 기능적 요구사항을 DB 설계 초기에 파악할 수 있음
* 추후 구축 단계에서 트랜잭션을 처리하는 응용 프로그램을 작성할 때 기초 자료가 됨
* 스키마에 트랜잭션이 필요로 하는 정보가 모두 포함되어 있는지 확인 가능

트랜잭션 요구 분석 명세서 -> 트랜잭션 모델링 -> 트랜잭션 명세서

## 트랜잭션 명세서 작성 방법
* DB 설계에 반영할 필요가 있는 주요 트랜잭션을 식별한 다음, 각 트랜잭션의 내부적인 제어 흐름을 파악해서 트랜잭션의 유형을 구분함
* 입력 및 출력 정보 표시 및 트랜잭션의 상대적인 중요도 등 작성

## 트랜잭션 모델링 단계에서 트랜잭션 유형 구분
* 삽입, 삭제, 변경, 검색, 혼합

## 제약조건 정의
ER 다이어그램에 없는 정보를 정의  



# 개체 심화 요소란?
보다 세분화된 개념적 모델링을 위해 개체를 세분화한 요소

* 키 개체, 메인 개체, 액션 개체, 약한 개체, 코드 개체, 관계 개체 등

## 키 개체
* 해당 업무에서 원래부터 존재하는 개체로서, 다른 개체와의 관계에 의해 생성된 개체가 아닌 원래 독립적으로 존재하는 개체
* 다른 개체의 부모 개체가 되므로 가장 우선해서 추출함
* 사원, 부서, 고객, 상품 등

* 부모개체
    * 다른 개체가 파생되는 근원이 되는 개체
    * 다른 개체와는 무관하게 독립적으로 존재하는 개체
* 자식개체
    * 부모 개체로부터 파생된 개체, 부모 개체 없이 존재 불가

## 메인 개체
* 키 개체들 간의 업무적인 관련성 때문에 생성되는 개체
* 해당 업무에서 핵심적으로 관리되는 데이터(부모개체)로부터 추출됨
* 매인 개체는 ER 모델에서는 대개 '관계'에 해당함

* 관계 개체와 메인 개체간의 차이점
    * 관계 개체는 두 개체 간의 M : N 관계로 인해 생성되는 개체이다
    * 메인 개체는 1 : 1 유형과 1 : N 유형의 관련성까지 모두 포함하는 개체이다

## 액션 개체
* 메인 개체로부터 파생되면서 내용이 자주 바뀌는 개체
* 초기 분석 단계에서는 잘 드러나지 않지만 모델링을 세분화하는 단계에서 도출됨

## 약한 개체
* 독립적으로 존재하지 못하고 소유 개체가 있어야 존재할 수 있는 개체
* 고유한 식별자가 없기 때문에 자신의 구분자(부분 키)를 소유 개체의 식별자와 결합해서 복합 식별자를 지정해야 함

## 코드 개체
* 정보를 간단히 표현하기 위한 기호를 나타내는 개체
* 실제 업무에서 사용하는 코드도 있지만 데이터를 효율적으로 표현하기 위해서 생성하는 경우도 있음
* 개념적 설계 단계에서 모두 식별할 필요는 없음
* 코드 개체는 참조용이므로 다른 개체와 관계를 맺을 필요가 없음
* 전공 코드 개체 등등

## 관계 개체란?
* 두 개체간의 M : N 관계로 인해 생성되는 개체로, 교차 개체라고도 칭한다
* ER 모델을 피터 펜 표기법으로 표현할 때는 M : N 관계도 마름모로 표현할 수 있지만, IE 표기법으로 표현할 때 M : N  관계를 정확히 표현하기 위해서 관계 개체를 생성해서 표현해야 한다
* 관계 개체의 식별자는 양쪽 개체의 식별자를 합친 복합 식별자로 지정한다

# 관계 심화 요소란?
보다 세분화된 개념적 모델링을 위해 관계를 세분화한 요소

## 병렬 관계
두 개체 사이에 두 개 이상의 관계가 존재하는 것으로, 다중관계 라고도 한다.

## 직렬 관계
병렬 관계로 나열한 여러 관계를 하나의 상위 개념으로 통합해서 M : N 관계로 바꾸어서 표현한 관계

발주하다, 감독하다, 정산하다 -> 관리하다(관리유형)

## 순환 관계
하나의 개체가 다른 개체가 아닌 자기 자신과 관계를 맺는 것을 의미한다

* 1 : N 순환 관계
    * 기관의 조직도, 관리자 정보 등과 같이 계층 구조를 표현할 때 발생한다
* M : N 순환 관계
    * 선수 과목이나, 구성부품 정보 등과 같이 네트워크 구조를 표현할 때 발생한다


# 속성 심화 요소
## 기초 속성
* 업무로부터 추출된 일반적인 속성
* 데이터 요구 분석 명세서에 포함되어 있으며, 현업에서 정보를 제공해야 속성이 유지될 수 있다
* 삼품의 상품명, 가격 등

## 설계 속성
* 원래 존재하지는 않지만 필요에 따라 설계자가 추가한 속성
* 데이터 요구 분석 명세서에 포함되어 있지는 않지만, 설계를 진행하면서 새로 생성된 속성
* 대부분의 코드 속성이나 일련번호처럼 식별자 역할을 하도록 추가된 속성이 해당함

## 유도 속성
* 기본 속성으로부터 계산 등의 가공 처리를 통해서 생성된 속성
* 추출 속성이라고도 칭한다
* 저장 속성의 영향을 받으므로, 저장 속성의 값이 변경되면 함께 변경된다
* 중복의 의미가 있으므로 대개 개념적 모델링 단계에서 식별하지 않음(반드시 필요한 경우라면 별도로 정리해서 구현 단계에서 참조함)


# 관계 행렬 활용
## 관계 행렬
개체들 간의 관계를 정의하기 위해서 사용하는 보조 도구

## 관계 행렬 작성 및 분석 방법
* 개체 타입을 가장 상위 행과 가장 좌측 열에 모두 표시한다
* 개체 타입들 간의 관계 유무를 셀에 표시한다
* 일차적으로 조금이라도 관련성이 있으면 모두 표시한다
.
.
.
.

## 슈퍼 서브 타입 정제

### 정제 기준
* 서브타입 개체에 독자적으로 고유한 속성이 없거나 독자적인 관계가 없는 경우 -> 별도의 개체로 표현하지 않고 슈퍼 타입의 속성으로 표현
* 서브타입으로 분할했을 때 개념적 모델링이 너무 복잡한 경우
    * 분할하지 않음
* 서브 타입으로 분할된 수가 너무 많은 경우
    * 각각을 독립된 개체로 분리

### 슈퍼-서브 타입 정제 방법
* 슈퍼 타입 개체를 기준으로 통합하는 방법
* 서브타입 개체를 기준으로 통합하는 방법
* 슈퍼 타입과 서브 타입 개체를 각각 분리하는 방법

### 슈퍼 타입 개체 기준으로 통합하는 경우
* 응용 프로그램에서 서브타입을 구분해서 처리하지 않는 경우
* 서브 타입 개체에 속하는 데이터를 명확하게 구분하기 어려운 경우
* 서브 타입 개체에 사용되는 속성 수가 매우 적은 경우
* 서브타입 개체와 연결된 관계도 통합한다

### 서브 타입 개체 기준으로 통합하는 경우
* 응용 프로그램에서 서브 타입을 확실히 구분해서 처리하는 경우
* 슈퍼 타입 개체에 속하는 속성의 수가 많지 않은 경우
* 슈퍼 타입 개체의 관계가 적은 경우
* 슈퍼 타입 개체에 접근하는 응용 프로그램의 수가 적은 경우

통합방법
1. 슈퍼 타입 개체에 있던 모든 속성을 각각의 서브타입 개체로 이동한다
2. 슈퍼 타입 개체에 연결된 관계를 각각의 서브타입 개체에 연결한다
3. 슈퍼 타입 개체를 삭제한다

### 슈퍼 타입과 서브타입 개체를 각각 구분하는 경우
* 데이터 모델의 유연성을 보장해야 하는 경우
* 서브 타입을 구분해서 처리하는 응용 프로그램과 구분 없이 처리하는 응용 프로그램의 수가 비슷하고, 추후 다양한 응용 프로그램이 추가될 예정인 경우

각각 분리하는 방법
1. 슈퍼타입, 서브타입 개체를 각각 개별 개체로 분리한다
2. 분리된 슈퍼 타입 개체와 서브타입 개체를 1 : 1 관계로 연결한다
3. 서브타입 개체를 기준으로 1 : 1 관계를 단순화한다(슈퍼 타입 개체의 기본 키를 서브타입 개체의 기본 키로 추가함)

# 카테고리 정제
## 카테고리란? 
별개의 개체 타입들의 집합

## 카테고리 정제 방법
1. 카테고리(서브타입 개체)를 독립된 개체로 만들고, 기본 키를 포함시킨다
2. 카테고리에 속하는 모든 개체 타입(슈퍼 타입 개체)을 카테고리 개체와 각각 1 : N 관계로 연결한다

# 속성을 개체로 전환하기
## 속성 값이 없는 경우
많은 개체가 널 값을 갖는 속성은 별도의 개체로 분리하고, 원래 개체와 1 : 1 관계로 연결

## 속성 값이 여러 부분으로 구성된 경우
속성의 수가 많으면서 특징을 구분할 수 있는 여러 부분으로 구성된 경우, 특징 별로 별도의 개체로 분리(기본 키 포함)

사원 -> 사원, 급여정보, 학력정보

# 개체,관계 속성검증
## 개체 검증 방법
1. 유용한 정보를 제공하는가?
    * 업무에 활용되지 않고 값이 변하지 않는 개체는 삭제
2. 유일한 식별자(후보 키)를 포함하고 있는가?
    * 없다면 데이터의 일관성과 무결성 보장을 위해 설계 속성 추가
3. 속성의 수가 2개 이상인가?
    * 속성이 하나 밖에 없는 경우, 다른 개체의 속성으로 표현
4. 실제 데이터가 2개 이상 존재하는가?
    * 데이터가 하나 밖에 없다면 업무적으로 관리할 필요가 없는 개체일 가능성이 크기 때문에 삭제함

## 관계 검증 방법
1. 관계가 현재 업무 규칙에 적절한 것인가?
2. 관계명이 두 개체 사이의 업무적 연관성을 표현하는 구체적인 이름인가?
3. 관계의 유형이 적절한가?
4. 관계의 카디널리티가 적절한가?
5. 필수/선택 여부, 즉 전체 참여와 부분 참여가 적절한가?

## 속성 검증 방법
1. 각기 다른 의미를 갖는 여러 개의 속성을 묶어서 하나의 속성으로 정의한 것은 아닌가?
    * 그렇다면 각각을 별개의 속성으로 구분
2. 속성이 단 하나의 값만 갖는 것이 아닌가?
    * 모든 개체가 동일한 하나의 값만을 갖는 속성이 있다면 제거
3. 코드 값ㅇ르 갖는 속성이 현업에서 통상적으로 사용되는 코드 값ㅇ르 갖는가?
    * 그렇지 않다면 코드 사용 억제
4. 전산 처리에 필요한 플래그 형태의 속성이 아닌가?
    * 플래그 형태의 속성은 제외시킴
        * 플래그 : 어떤 상태의 진위를 나타낼 때 사용하는 값이나 변수
        * 사원 개체의 연봉협상여부 등

# 논리적 설계
개념적 데이터 모델을 DBMS가 지원한느 논리적 데이터 모델로 변환하는 것

## 주요 업무
* 논리적 모델링 
    * ERD로 표현된 개념적 스키마를 논리적 스키마(릴레이션 스키마)로 변환한 다음, 정규화 과정을 통해 보다 바람직한 모델로 변환하고, 요구 분석 명세서를 기초로 무결성 제약조건을 정의함
* 트랜잭션 인터페이스 설계
    * 트랜잭션 모델링을 기초로 인터페이스를 설계함

## 릴레이션 스키마(Relation Schema)란?
가장 대표적인 논리적 데이터 모델인 관계 데이터 모델의 기본이 되는 릴레이션을 구성하는 속성들의 집합.  
릴레이션 이름과 속성 이름들로 표현한다.

## 릴레이션 스키마 변환 과정
1. ERD의 개체와 관계를 릴레이션 스키마로 변환
    * 릴레이션명(속성, 속성 ....)
2. 각 릴레이션 스키마에 기본 키 표시
    * 기본 키 아래 밑줄 표시
3. 가능한 경우 릴레이션 스키마의 단순화
    * 일 대 일, 일 대 다 관계 유형 단순화
4. 정규화 
    * 보다 바람직한 구조의 릴레이션 형태로 변경

## 개체 변환
### 단순 속성을 갖는 개체 변환 방법
변환 방법 : 모든 속성이 릴레이션의 속성이 됨  
기본 키 : 개체의 후보 키 가운데 하나가 릴레이션의 기본 키가 됨
### 복합 속성을 갖는 개체 변환 방법
변환 방법 : 복합 속성을 구성하는 모든 속성이 릴레이션의 속성이 됨  
기본 키 : 복합 속성이 일반 속성인 경우와 후보 키에 대응하는 속성인 경우를 구분해서 판단

* 복합 속성이 일반 속성인 경우
    * 개체의 후보 키 가운데 하나가 릴레이션의 기본 키가 됨
* 기본 키가 복합 속성인 경우
    * 복합 속성을 구성하는 모든 속성들이 기본 키가 됨
    * 릴레이션 스키마에서 연결된 선으로 표시한다
    * 기본 키가 여러 개인것과 엄연히 다르다

## 약한 개체 변환
변환 방법 : 약한 개체 타입에 대해서 릴레이션을 생성하고, 약한 개체 타입에 속한 모든 단순 속성들을 릴레이션에 포함시키고, 소유 개체 타입의 기본 키를 약한 개체 타입의 외래 키로 포함시킨다.
기본 키 : 약한 개체 타입의 부분 키(구별자)와 소유 개체 타입의 릴레이션을 참조하는 외래 키(FK)의 조합, 긴 밑줄로 전부 연결한다.

* 외래 키로 포함시킴으로써 관계 타입이 릴레이션으로 표현된 것이므로, **식별 관계 타입을 별도로 릴레이션으로 변환할 필요가 없다**

## 관계 변환
### 관계 변환의 특징
관계를 설명한느 속성 뿐만 아니라 관계에 속하는 개체들의 기본 키 속성이 모두 릴레이션의 속성이 된다.

### 관계 릴레이션의 기본 키
관계의 유형에 따라 기본 키를 결정하는 방법에 차이가 있다

* 일 대 일 관계 변환 방법
    * 기본 키 : 관계에 포함된 양쪽 개체 기본 키 중 하나가 기본 키가 될 수 있다
* 일 대 다 관계 변환 방법
    * 기본 키 : 관계에 포함된 개체 가운데 n측의 기본 키가 기본 키가 된다
* 다 대 다 관계 변환 방법
    * 기본 키 : 관계에 포함된 양쪽 개체의 기본 키들을 구성하는 모든 속성들의 조합이 기본 키가 된다
    * 양쪽을 포함시키더라도 기본 키를 충족하지 못하는 경우가 있다. 그 경우에는 다른 속성을 기본 키로 같이 포함시켜야 한다.
    * 강사, 강좌, 강의일자 등
    * 이 경우 따로 기본 키의 역할을 할 설계 속성을 만들면 편하다
* 일 대 다 **순환 관계** 변환 방법
    * **관계 릴레이션을 별도로 생성하지 않고,** 개체의 기본 키를 외래 키로 포함시킨다.
    * 관계의 속성도 개체 릴레이션에 포함시킨다.
    * 기본 키 : 개체의 기존 기본 키가 그대로 기본 키가 된다
* 다 대 다 순환 관계 변환 방법
    * **관계 릴레이션을 별도로 생성하고,** 개체의 기본 키를 2개의 외래 키로 포함시킨다. 
    * 관계 자체의 속성이 있다면 그 속성도 관계 릴레이션에 포함시킨다
    * 기본 키 : 2개의 외래 키가 조합되어 관계 릴레이션의 기본 키가 된다
    * 주의사항 : 동일한 기본 키가 두 번 추가되므로, **두 개의 속성 이름이 서로 달라야 한다** 
* 3진 관계 변환
    * 관계의 릴레이션을 생성한다
    * 3 개체의 모든 키본 키를 외래 키로 만들어 관계 릴레이션의 기본 키로 사용한다
    * 기본 키의 조건이 되지 않는다면 추가로 다른 속성을 기본 키로 추가한다
    * 설계 속성을 추가하면 편해진다

## 다중치 속성 변환
변환 방법 : 다중치 속성을 위한 별도의 릴레이션을 생성하고, 다중치 속성을 갖는 개체 타입의 기본 키를 외래 키로 포함시킨다  
기본 키 : 외래 키와 다중치 속성의 조합이 기본 키가 된다


## 릴레이션 단순화
* 일 대 일 관계 단순화
    * 관계를 표현하는 릴레이션을 따로 생성하지 않고, 관계에 포함된 두 개체 릴레이션 가운데 하나에 통합해서 단순화 시킴
* 일 대 다 관계 단순화
    * 관계를 표현하는 릴레이션을 따로 생성하지 않고, 관계에 포함된 n측 개체 릴레이션에 1측 개체의 기본 키를 외래 키로 포함시키고 관계 자체의 속성도 포함시켜서 단순화 시킨다

## 개체 타입 통합
자세히 보지는 않는다

기본 키와 속성이 비슷하면 구별하는 속성을 추가하고 통합할 수 있다.




# 이력 데이터 모델링
## 이력(history) 데이터란??
하나의 업무 단위가 시간의 흐름에 따라 반복적으로 발생하거나 변경 또는 진행되는 과거 및 현재 데이터

## 이력 데이터 관리의 장점
* 과거 특정 시점의 데이터 조회 가능
* 변경 내역 관리 가능
* 오류 발생 시 현재 정보를 가장 최근 이력 정보로 복구 가능

## 고려사항
* 시간이 경과함에 따라 데이터가 변할 수 있나?
* 시간이 경과함에 따라 관계가 변할 수 있나? 
    * 각 개체간 관계가 바뀔 수 있다
* 과거 데이터를 조회할 필요가 있나?
* 변경 내역을 조회할 필요가 있나?
* 과거 버전을 보관할 필요가 있나?

## 이력 개체의 특징
* 하나의 개체에서 발생하는 이력을 관리하기 위해서 발생하는 개체로, 과거 특정 시점에 대한 정보를 제공하는 것을 목적으로 함
* 이럭 개체(약한 개체)의 기본 키는 부분 키에 소유 개체의 기본 키를 결합해서 지정하고, 필요하면 날짜나 일렬번호를 기본 키에 추가함
* 소유 개체의 기본 키는 이력 개체의 외래 키가 됨
* 이력 개체에 필요한 대부분의 속성은 소유 개체에 존재함

## 이력 데이터의 3가지 유형
### 발생 이력
* 데이터가 발생할 때마다 이력 정보를 남겨야 하는 경우
    * 약한 개체로 발생 이력 저장
* 요금청구, 이자계산, 급여계산 등

### 변경 이력
* 데이터가 변경될 때마다 변경 전후 차이를 확인해야 하는 경우
    * 약한 개체로 변경 이력 저장
    * 온라인 쇼핑몰에서 고객이 주문후 주문 정보를 변경하는 등

### 진행 이력
* 접수나 예약, 공사 진행 등과 같이 업무가 진행되는 상황을 남겨야 하는 경우
    * 언제, 누가, 어떤 업무를 했는지 약한 개체로 진행 이력 저장


## 이력 데이터 모델링 형태
### 시점 이력
* 데이터 변경이 발생한 시점만 관리하는 것
    * 환율이 변경되면 그 시점과 환율 저장, 환율이 언제 얼마로 변했는지, 정해진 시간이 없다

### 선분 이력
* 데이터 변경이 발생한 **시작 시점부터 종료 시점**까지 전체 시간을 관리하는 것
    * 각 통화의 특정 시간 동안 유효한 환율 관리??

# 코드 데이터 모델링
## 코드란?
업무 또는 정보시스템에서 쉽게 구분할 수 있도록 데이터들을 간단하게 구분해 놓은 단위

## 코드 구분
1. 한 개의 값(속성)이 반복적으로 나타나는 코드
2. 여러 개의 값(속성)이 반복적으로 나타나는 코드
    * 너무 코드가 복잡하고 많아지면 그냥 나누는게 좋다

## 코드 데이터 모델링 시 유의사항
* 코드 개체는 주로 코드 값을 참조하는 용도로 사용되므로 다른 개체와 관계를 맺지 않아도 된다
* 코드를 코드 값으로 변환할 때 SQL문에서 조인이나 DECODE문 등을 사용해서 변환하거나 응용 프로그램을 통해서 변환할 수 있다


# 무결성 제약조건 
* DB에 저장된 데이터의 정확성과 일관성 유지를 위해서 DB가 항상 만족해야 하는 조건
* 데이터의 정확성, 유효성, 일관성, 신뢰성을 보장하기 위해서 **무분별한 데이터 갱신으로부터 데이터를 보호**하려면 무결성 제약조건이 필요하다

## 관계 테이터 모델의 무결성 제약조건
* 개체 무결성 : 기본 키는 튜플들을 유일하게 식별하기 위해 널 값을 가질 수 없다는 제약조건
* 참조 무결성 : 외래 키는 반드시 피참조 릴레이션의 기본 키 값이나 널 값을 가져야 한다는 제약조건
* 도메인 무결성 : 특정 속성이 반드시 미리 정의된 도메인에 존재하는 값을 가져야 한댜는 제약조건
* 사용자 정의 무결성 : 위의 3가지 무결성 범주에 포함되지 않는 특정 업무 규칙을 명시적으로 정의한 제약조건

## 개체 무결성
* 기본 키는 널값 가지면 안됨
* 기본 키는 개체를 유일하게 식별할 수 있어야 함
* 기본 키는 유일성을 보장하는 최소한의 집합이어야 함

### 기본 키 선정시 유의사항
* 기본 키는 변경되지 않아야 함
* 데이터 보안이 요구되지 않아야 함
* 후보 키 가운데 업무 활용도가 높고 업무상 의미 있으며, 개체의 특성을 잘 나타내는 속성 선택

## 무결성 제약조건 정의 방법
* 묵시적 정의 : 릴레이션을 정의할 때 기본 키와 외래 키를 정의하면, 개체무결성과 참조 무결성이 묵시적으로 정의됨
* 명시적 정의 : 개체 무결성과 참조 무결성 이외에, 데이터의 정확성과 일관성 유지를 위해서 특정 속성이 만족해야 하는 무결성 제약조건은 명시적으로 정의해야 함


# 데이터 표준화
## 데이터 표준화란? 
시스템 별로 산재되어 있는 데이터의 명칭과 정의, 규칙, 형식 등에 대한 원칙을 수립해서 전사적으로 적용하는 것

# 트랜잭션 인터페이스 설계
사용자 그룹별 접근 가능한 범위와 DB 서버에 접근하는 방법 등을 결정해서 트랜잭션 전체적인 골격 및 인터페이스를 정의함

## 주요 업무
* 그룹별 접근 가능 데이터 범위 정하고, 접근 방법 및 인터페이스를 절차적 기술
* DB서버에 접근하는 방법

