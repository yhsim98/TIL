도커를 사용하는 이유는 설치과정의 간략화 입니다.

docker를 사용하면 컨테이너기술과 이미지를 통해 간단하게 프로그램을 설치할 수 있습니다.

# 도커
컨테이너 기반의 오픈소스 가상화 플랫폼

## 서버에서 컨테이너의 개념
컨테이너 안에 다양한 프로그램, 실행환경을 컨테이너로 추상화하고 동일한 인터페이스를 제공하여 `프로그램의 배포 및 관리를 단순`하게 해줍니다.

## 컨테이너
코드와 모든 종속성을 패키지화하여 응용 프로그램이 한 컴퓨팅 환경에서 다른 컴퓨팅 환경으로 빠르고 안정적으로 실행되도록 하는 소프트웨어 표준 단위

컨테이너는 서로 호스트 OS의 커널을 공유한다

### 어떻게 컨테이너를 격리시킬까?
리눅스의 Cgroup과 namespaces를 사용하게 된다.

컨테이너와 호스트에서 실행되는 다른 프로세스 사이에 벽을 만드는 리눅스 커널 기능들이다.

* C Group
    * CPU, 메모리, Network Bandwith, HD i/o 등 프로세스 그룹의 시스템 리소스 사용량을 관리
    * 어떤 어플의 사용량이 많다면 해당 어플을 C group에 넣어 CPU와 메모리 사용 제한 가능
* 네임스페이스
    * 하나의 시스템에서 프로세스를 격리시킬 수 있는 가상화 기술
    * 별개의 독립된 공간을 사용하는 것처럼 격리된 환경을 제공하는 경량 프로세스 가상화 기술

## 컨테이너 이미지
코드, 런타임, 시스템 도구, 시스템 라이브러리 및 설정과 같은 응용 프로그램을 실행하는 데 필요한 모든 것을 포함하는 가볍고 독립적이며 실행 가능한 소프트웨어 페키지

환경에 독립적으로 리눅스건 윈도우건 균일하게 작동하도록 보장한다

* 이미지는 으용 프로그램을 실행하는데 필요한 모든 것을 포함하고 있다
* 컨테이너가 시작 될 때 실행되는 명령어
* 파일 스냅샷

이미지 설명
* container id
    * 컨테이너의 고유한 아이디 해쉬값
    * 실제로는 더욱 길지만 일부분만 표출
* IMAGE
    * 컨테이너 생성 시 사용한 도커 이미지
* COMMAND
    * 컨테이너 시작 시 실행될 명령어
    * 이미지에 내장되어 있다 보통
* CREATED
    * 컨테이너가 생성된 시간
* STATUS
    * 컨테이너의 상태
    * 실행중은 UP, 종료는 Exited, 일시정지는 Pause
* PORTS
    * 컨테이너가 개방한 포트와 호스트에 연결한 포트
    * 특별한 설정을 하지 않은 경우 출력되지 않는다
* NAMES
    * 컨테이너 고유한 이름
    * 도커 엔진이 임의로 형용사와 명사를 조합해 설정

# docker 컨테이너 생명주기
* create
* start
* running
* stopped
* deleted

## docker stop vs kill
stop은 하던 작업을 마저 후 종료

kill은 즉시 종료

## 실행중인 컨테이너에 명령어 전달
``docker exec <container id>``

exec를 이용하여 명령어를 전달할 수 있다

``-it``를 사용하면 명령어를 전달 후 지속적으로 상호작용 가능

마지막에 ``sh``를 붙이면 컨테이너 내부 shell 접속이 가능하다







