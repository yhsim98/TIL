데코레이터 패턴은 여러 패턴들과 유사한 구조를 가지고 있다.

 

다양하고 일정하지 않은 여러 객체들을 하나의 객체로 묶는 것을 Composite 패턴이라 하는데

데코레이터 패턴은 한 구성요소 만을 갖는 Composite 패턴이라 볼 수 있다.

그러나 목적에서 차이가 있다.

Composite 패턴은 목적이 생성되어 있는 객체들 간의 합성에 있고

데코레이터 패턴은 목적이 객체에 새로운 행동을 추가하는 데에 있다.

 

Strategy 패턴은 유사한 행위를 캡슐화하는 인터페이스를 정의하여

객체들의 행위를 유연하게 확장하는 방법으로 데코레이터 패턴과 구조가 비슷하다.

하지만 Strategy 패턴은 객체의 내부를 변화시키며

데코레이터 패턴은 새로운 객체를 추가하여 객체를 변경한다는 점에서 차이가 있다.

 

마지막으로 Adaptor 패턴은 서로 다른 인터페이스를 통일시켜 사용하는 패턴으로서

데코레이터가 기준 객체와 부가 객체를 연결하는 어댑터 역할을 하는 것과 유사하다.

그러나 데코레이터 패턴은 어댑터 패턴과 달리 인터페이스를 변경 없이

객체에 새로운 행동을 추가한다는 점에서 차이가 있다.

# 전략 패턴
알고리즘을 캡슐화해주고 실행시간에 선택

상속은 정적관계이다. 따라서 자식은 상속받을 메소드를 선택할 수 없다.

부모에 정의된 모든 메소드가 모든 자식에 적합하지 않을 수 있다.

## 해결법 1. 빈 메소드로 재정의한다
문제
1. 빈 메소드를 여러 번 만드는 것도 코드 중복사용
2. 사용자가 사전에 해당 메소드를 지원하는 지 알기 어렵다
3. 부모의 변화가 자식에게 의도치않은 영향을 줄 수 있다

## 해결법 2. 종류별로 인터페이스를 구현하는 클래스를 만들기
문제
1. 너무 많은 클래스가 생길 수 있다

## 해결법 3. 각 기능을 하는 interface 를 나눠 만들기
interface 을 이용하면 특정 기능을 제공하는 것과 제공하지 않는 것을 구분할 수 있다.

클래스에서 기능을 제외한 후 해당 기능을 하는 클래스들을 따로 만들기

문제
1. 코드 중복 문제가 존재한다
    * 인터페이스이니 같은 코드라도 구현하는 클래스에서 전부 구현해야 한다
    * 자바8의 default 메서드를 사용하더라도 여전히 동적 변화를 제공하기 힘들다
2. 다양한 조합 문제를 제공하기 어렵다

# 다양한 조합 문제
* 공통적으로 가진 기능이 있지만 이 기능이 다양하게 구현될 수 있다
* 다양하게 구현된 것들을 종종 실행시간에 바꾸어야 사용할 수 있다
* 이와 같은 기능이 여러 개 존재할 수 있다

# 관련 설계 원리
## 변하는 부분과 변하지 않는 부분을 분리해라
조합 문제의 해결책으로 상속은 좋은 해결책이 아니다.

interface 또한 구현을 포함하지 않기 때문에 좋은 해결책이 아니다

## 인터페이스를 통해 관계를 맺도록 해라
Has-a 관계와 의존관계 주입으로 구현

# 올바른 구현
1. 행동에 관한 인터페이스를 만든 후
2. 그것을 구현하는 각각의 클래스를 만든다
3. 필요로하는 각 클래스에 주입해준다

```
interface Fly{
    fly();
}

class FlyWithWings implements Fly{
    fly(){}
}

class FlyNoWay implements Fly{
    fly(){}
}

class RubberDuck{
    Fly fly = new FlyNoWay();
}

class GoldDuck{
    Fly fly = new FlyWithWings();
}
```
장점
* 코드 재사용이 가능해진다
    * 날개로 나는 모든 오리에 대한 구현은 한번
* 기존 클래스를 변경하지 않고 새 행위를 추가하기 쉽다
* 조건문을 사용하지 않고 구현이 가능하다

* 구현을 주입받음으로서 실행시간에 행동을 변경할 수 있다
* 새로운 타입을 만들기 쉽다, 행동을 주입하는 부분만 손보면 된다
* 새로운 행위 추가가 쉽다

