# 전통적 방식의 프로세스의 경우

-   하나의 프로세스는 `동시에 여러 작업을 수행하지 못합니다`
-   프로세스의 context switching은 `무겁습니다.`
-   프로세스끼리는 서로 `데이터 공유가 어렵습니다.`
    -   프로세스는 독립적인 메모리 공간을 가지기 때문입니다
-   CPU의 듀얼 코어를 사용하기 어렵습니다

이것을 스레드를 통해 해결하게 됩니다.

# 스레드

-   프로세스 : 자원을 할당받아 제어하여 작업을 처리
    -   자원과 제어로 나눌 수 있다
        -   자원 : 프로세서, 네트워크 연결, 외부 장치 등등
    -   여기서 제어를 스레드가 수행한다
-   스레드 : 자원을 제어하여 작업을 처리
    -   프로세스가 운영체제 입장에서의 작업 최소 단위라면, 스레드는 CPU 입장에서의 작업 최소 단위입니다
        -   스레드가 각자의 CPU를 할당받고 작업을 처리합니다
    -   한 프로세스에 하나 이상의 스레드가 있을 수 있습니다
        -   최소 하나이상 있어야 한다
        -   인텔리제이라는 하나의 프로그램에서 코드 입력, 자동 완성, 테스트 실행 등 여러 작업이 필요하다
        -   코드 입력 담당 쓰레드, 자동 완성 담당 쓰레드 이렇게 각각 쓰레드가 작업들을 담당
    -   같은 프로세스의 스레들끼리의 context switching은 가볍습니다.
        -   스레드들은 프로세스의 메모리 영역을 공유하기 때문입니다
    -   같은 프로세스에 속한 스레드는 프로세스의 특정 메모리 영역을 공유합니다
        -   덕분에 스레드들끼리 데이터 공유가 쉬워집니다
        -   컨텍스트 스위치의 비용도 감소됩니다
-   각 스레드는 제어 정보와 지역 데이터를 가집니다.
    -   제어 정보에는 Program Counter, Stack Pointer, 상태 정보 등이 있습니다
    -   지역 데이터에는 로컬 변수, 리턴 값 등 임시적인 값들이 있습니다
-   지역 데이터는 함수의 호출에 따른 임시적인 값들을 저장합니다
    -   지역 데이터는 메모리 stack영역에 저장되며, 서로 독립적입니다
    -   이것을 통해 같은 함수를 호출하더라도 스레드별로 독립적인 실행 흐름을 가질 수 있습니다
-   서로 공유하지 않습니다

#### Multithreaded Server Architecture

서버와 클라이언트 사이에도 멀티스레드를 구현한다. 클라이언트가 서버에게 요청을 보내면 서버는 새로운 스레드를 하나 생성해 요청을 수행한다. 프로세스를 생성하는 것보다 스레드를 생성하는 것이 더 빠르기 때문이다.

대표적으로 java spring이 있다.

#### 동시성(Concurrency)과 병렬성(Parallelism)

-   동시성
    -   싱글 프로세서 시스템에서 사용하는 방식
    -   프로세서가 여러 스레드를 번갈아가며 수행함으로써 마치 동시에 실행되는 것처럼 보이게 합니다 
-   병렬성
    -   멀티코어 시스템에서 사용하는 방식
    -   여러 코어가 각 스레드를 동시에 수행합니다

## 구성 요소

-   Thread ID
-   Register set
    -   PC, SP
    -   Program Counter란 Cpu register가 다음에 실행할 명령어 주소를 참조하기 위한 메모리 주소입니다
-   Stack(loacl data)
    -   반환값, 로컬변수 등 임시 데이터

## 스레드 메모리

![](https://2.bp.blogspot.com/-3AB4sE53Dfw/VMVNdWa_V0I/AAAAAAAAACo/UAGFO7f6_UA/s1600/euva3a00.p54z.gif)

-   같은 프로세스의 스레드들은 동일한 주소 공간을 공유합니다
-   스레드는 프로세스의 자원을 공유합니다
    -   heap, static, code 영역 등을 공유하게 됩니다
-   스레드는 각자의 작업 영역, `Stack 영역`을 가지게 됩니다
    -   스레드들끼리 공유되지 않는 고유한 영역입니다
    -   Stack 영역에는 지역변수, 매개변수, 리턴값 등 잠시 사용되었다가 사라지는 임시적인 값들이 저장되게 됩니다
    -   이것을 통해 같은 함수를 호출하더라도 스레드별로 독립적인 실행 흐름을 가질 수 있습니다

## 스레드 장점

-   사용자 응답성
    -   일부 스레드의 처리가 지연되도, 다른 스레드는 작업을 게속 처리 가능
-   자원 공유
    -   같은 프로세스의 스레드는 특정 메모리 영역를 공유하기 떄문에 같은 프로세스의 스레드들끼리의 context switching은 가볍습니다.
-   경제성
    -   프로세스의 생성, context switch에 비해 효율적
-   멀티 프로세서 활용
    -   병렬처리를 통해 성능 향상
    -   한 프로세스가 여러 프로세서 사용
        -   여러 코어를 활용하여 프로그램을 병렬적으로 실행이 가능합니다

# 스레드 context switching

## TCB(Thread Control brock)

하나의 스레드를 관리하는데 필요한 정보를 담고 있는 구조체입니다.

프로세스의 상태를 관리하는 PCB보다 적은 양의 정보가 담겨있습니다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FsxO0J%2FbtqEwQ5PbRD%2FkrWKDTE60qcaJpksIFcAy1%2Fimg.jpg)

-   스레드 ID
-   Stack Pointer : 스레드 고유의 stack 의 pointer
-   Program Counter : 스레드가 실행할 instruction의 주소
-   Thread condition : 스레드 상태(ready, running, waiting ....)
-   Thread Register values
-   해당 스레드가 소속된 PCB 주소

# 스래드의 구현

## 사용자 수준 스레드

-   사용자 영역의 스레드 라이브러리가 관리하는 스레드 
    -   스레드의 생성, 스케줄링 등
    -   win32 threads, java thread api 등이 있습니다
-   커널은 사용자 수준 스레드의 존재를 모릅니다
    -   커널의 괸리를 받지 않습니다
        -   커널의 개입 없이 동기화 및 스케줄링이 가능해 생성 맟 관리의 부하가 적고, 유연한 관리가 가능하다
        -   커널에 독립적으로 스케줄링 할 수 있어 이식성이 높다

## 커널 수준 스레드

-   멀티 스레드 환경에서는 `스케줄링 대상이 프로세스가 아닌 스레드` 입니다
-   여기서 `스레드란 커널 수준 스레드를 의미`합니다
-   사용자 수준의 스레드는 스레드 라이브러리에 의해 관리되고 커널은 사용자 수준 스레드를 알 지 못합니다
-   사용자 수준 스레드는 `CPU상에서 실행되기 위해 커널 수준 스레드에 매핑`되어야 합니다
-   커널이 스레드와 관련된 모든 작업을 관리합니다
-   프로세스는 커널 수준 스레드를 통해 하드웨어와 상호작용
    -   프로세서사용, IO 등 system call
-   커널 영역에서 스레드의 생성, 관리를 수행합니다
    -   context switching 등 부하가 크다

## N : 1 매핑

-   프로세스 하나에 커널 수준 스레드 하나
-   커널이 프로세스 단위로 자원 할당한다
    -   하나의 사용자 수준 스레드가 block 상태가 되면, 모든 스레드가 대기
    -   쓰레드 하나가 system call 등으로 block 되면 하나 뿐인 커널 수준 쓰레드가 상황을 처리하느라 **프로세스 전체가 block** 된다

## 1 : 1 매핑

-   하나의 유저 스레드에 하나의 커널 스레드
-   커널이 각 스레드를 개별적으로 관리한다
    -   프로세스 내 스레드들이 병행 수행 가능하다
        -   **하나의 스레드가 block 상태**가 되어도, **다른 스레드는 계속 작업 수행 가능**하다
-   유저 스레드와 커널 스레드가 1 : 1 이므로 유저 모드와 커널 모드의 전환이 자주 일어난다
    -   성능 저하 

## M : N 매핑

-   n개의 사용자 수준 스레드 : m개의 커널 스레드(n > m)
    -   사용자는 원하는 수만큼 스레드 사용
    -   커널 스레드는 자신에게 할당된 **하나의 사용자 스레드가 block 상태가 되더라도 다른 스레드 수행 가능**
    -   커널 스레드와 사용자 스레드가 **상황에 따라 동적으로 연결**된다
    -   하나의 프로세스에는 경량 프로세스(LWP)가 하나 이상 있다
    -   커널 스레드는 LWP와 1:1로 매핑된다
    -   사용자 수준 스레드는 LWP와  다대다로 매핑된다
-   효율적이면서도 유연함

### LWP

커널과 사용자 프로세스를 연결하는 인터페이스 역할을 합니다.

스레드 라이브러리는 사용자 스레드로부터 실행될 스레드를 선택하고, LWP를 구성합니다. LWP는 커널에 의해 스케줄링될 수 있는 커널 스레드로 매핑됩니다.

다음과 같은 특성이 있습니다.

-   여러 LWP는 프로세스 공간과 리소스를 공유한다
-   한 LWP는 수명 주기동안 다른 CPU에서 실행될 수 있다
-   LWP는 서로 독립적이다
-   각 LWP는 CPU에서 독립적으로 실행된다
-   각 LWP는 커널 스레드와 연결된다