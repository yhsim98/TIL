## Page reference string 
* 프로세스의 수행 중 참조한 페이지 번호 순서
* 





# Min Algorithm
* 앞으로 가장 오랫동안 참조하지 않을 page 교체
* 실현불가능함
    * page referene string을 알아야 한다
* 그래서 교체 기법의 성능 평가 도구로 활용됨

# Random Algorithm
* 무작위로 교체할 page 선택
* Low overhead
* No policy

# FIFO Algorithm
가장 먼저 들어온거 내보냄
성능은  FIFO anomaly frame 많은데 fault 많이남


# LRU algorithm

# LFU algorithm
* 가장 참조 횟수가 적은 Page를 교체
* page 참조 시마다, 참조 횟수를 누적시켜야 함
* Locality 활용
    * LRU 대비 적은 overhead
* 단점  
    * 최근 적재된 참조될 가능성이 높은 page가 교체 될 가능성이 있음
    * 참조 횟수 누적 overhead

# Not Used Recently Algorithm
* LRU approximation scheme
    * LRU보다 적은 overhead로 비슷한 성능 달성 목적
* Bit vector 사용
    * Reference bit vector (r), Update bit vector(m)
* 교체순서
    1. (0, 0) 
    2. (0, 1)
    3. (1, 0)
    4. (1, 1)

# Clock Algorithm
* NUR에서 초기화만 안함


# Other algorithms


# Working Set algorithm
* Locality
* working set
    * Process가 특정 시점에 자주 참조하는 page들의 집합
    * 최근 일정시간(델타)동안 참조된 page들의 집합
    * 시간에 따라 변함
* Window 
    * 현재 바라봐야하는 영역
    * size는 고정

* 성능평가
    * page fault 수 외 다른 지표도 함께 봐야 함
    * page frame도 고려해야 한다


# Page Fault Frequency algorithm
* Residence set size를 page fault rate에 따라 결정
    * Low page fault rate
        * 할당된 PF 감소
    

# Variable Min algorithm
* 최적의 델타값 R / U



# Page Size
* 시스템 특성에 따라 다름
    * No best answer
    * 점점 커지는 경향
* 일반적인 page size
    * 2^7 bytes ~ 2^22 bytes
* Small page size
    * Large page table
        * High overhead(kernal)
    * 내부 단편화 감소
    * I/O 시간 증가
        * page에 여러개 올려야 함
    * Locality 향상
    * Page fault 증가
* Large page size
    * Small page table
        * Low overhead(kernal)
    * 내부 단편화 증가
    * I/O 시간 감소
        * 한번에 올림
    * Locality 저하
    * Page fault 감소
* 현대에는 CPU와 Memory 발전 -> page size큰게 좋다

# Program Restructuring
* 가상 메모리 시스템의 특성에 맞도록 프로그램을 재구성
* Example
    * Paging system, Page size = 1KB
    * sizeof(int) = 4bytes
    * int zar[256][256]
    