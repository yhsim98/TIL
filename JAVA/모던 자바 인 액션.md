* Part 1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?
    * 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념



# Part 1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?
기존에는 CPU의 멀티 코어를 사용하기 위해 스레드를 사용했을 것이다. 하지만 자바 8 이 등장하며 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다

자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항에 기반한다. 

자바 8이 제공하는 새로운 기술로는 다음 3가지가 있다.
* 스트림 API
* 메서드에 코드를 전달하는 기법
* 인터페이스의 디폴트 메서드


자바 8은 sql 에서 표현식을 처리하는 것처럼 병렬 연산을 지원하는 스트림이라는 새로운 API 를 제공한다. 고수준 언어로 원하는 동작을 표현하면, 스트림 라이브러리에서 최적의 저수준 실행 방법을 선택하는 방식으로 동작한다. 즉, 스트림을 사용하면 훨씬 비용이 비싼 키워드인 synchronized를 사용하지 않아도 된다.

뿐만 아니라 메서드에 코드를 선달하는 기법이 생겼다. 이것을 통해서 새롭고 간결한 방식으로 동작 파라미터화를 구현할 수 있다.

## 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념
### 스트림 처리
스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다.

이론적으로 프로그램은 입력 스트림에서 데이터를 한개씩 읽어 들여 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

* 자바 8에는 스트림 API가 추가되었다. 스트림 API 는 파이프라인을 만드는 데 필요한 많은 메서드를 제공한다
    * 스트림 API 가 조립 라인처럼 어떤 항목을 연속적으로 제공하는 어떤 기능이라고 단순한게 생각하면 된다
* ```Stream<T>``` 는 T 형식으로 구성된 일련의 항목을 의미한다
* 기존에 한 번에 한 항목을 처리하던 것을 자바 8에서는 고수준으로 추상화하여 일련의 스트림으로 만들어 처리할 수 있다
* 스트림 파이프라인을 이용하여 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다
* 스레드라는 복잡한 작업을 사용하지 않고도 공짜로 병렬성을 얻을 수 있다

### 동작 파라미터화로 메서드에 코드 전달하기
자바 8부터는 코드 일부를 API 로 전달할 수 있게 되었다.

* 메서드를 다른 메서드의 인수로 넘겨줄 수 있게 되었다. 이런 기능을 **동작 파라미터화**라고 부른다

### 병렬성과 공유 가변 데이터
* 병렬성을 공짜로 얻을 수 있게 되었다
    * 대신 스트림 메서드로 전달하는 코드는 공유된 가변 데이터에 접근하지 않아야 한다
    * 이러한 함수를 stateless 함수라 한다
* 자바 8의 스트림을 이용하면 기존의 스레드 API보다 쉽게 병렬성을 활용할 수 있다

## 자바 함수
### 일급 시민
인스턴스 혹은 값 타입처럼 자유롭게 전달되고 값을 바꿀 수 있는 타입들

1급 시민의 조건은 다음과 같다
* 변수에 담을 수 있어야 한다
* 인자로 전달할 수 있다
* 반환값으로 전달할 수 있다

자바 8이전에는 메서드, 클래스 등은 이급 자바 시민에 해당했다. 메서드와 클래스는 그 자체로 값이 될 수 없었다. 

### 메서드와 람다를 일급 시민으로
스칼라와 그루비 등에서 메서드를 일급값으로 활용하면 프로그래밍이 수월해진다는 사실이 확인되었다.

자바8의 설계자들은 메서드를 값 타입으로 취급할 수 있도록 하여 프로그래머들이 더 쉽게 프로그램을 구현할 수 있는 환경을 제공하기로 하였고, 이러한 메서드를 값으로 취급할 수 있는 기능은 **스트림 같은 다른 자바 8 기능의 토대를 제공했다**.

다음 예제는 FileFilter 객체 내부의 accept 메서드 내부에 위치한 isHidden() 의 결과를 File.listFiles 에 전달하는 방법으로 숨겨진 파일을 필터링하는 코드이다.

```
File[] hiddenFiles = new File(".").listFiles(new FileFilter(){
    public boolean accept(File file){
        return file.isHidden();
    }
})
```

isHidden 은 File 클래스에 있는 메서드이다. listFiles 는 인수로 FileFilter 를 받는다.  
FileFilter 는 accept 라는 추상 메서드 하나만을 가지고 있는 인터페이스이다. accept 는 인수로 File 을 받는다.

File 에는 이미 isHidden 이 있지만 굳이 FileFilter 로 isHidden 을 복잡하게 감싼 다음 FileFilter 를 인스턴스화하고 있다.

자바 8 이후로는 다음처럼 코드를 구현할 수 있다

``` 
File[] hiddenFiles = new File(".").listFiles(File::isHidden);

```

isHidden 이라는 함수는 준비되어 있으므로 자바8의 메소드 참조 :: 를 이용하여 ```File::isHidden``` 이라는 메소드 참조를 사용하여 accept 는 isHidden 이라는 것을 나타낸 다음 listFiles 에 함수를 직접 전달하고 있다
* 메서드가 아닌 함수라는 표현을 사용하였다
* 함수는 하나의 기능을 수행하는 일련의 코드이다
    * 이름과 매개변수인 머리, 동작 과정과 반환값인 몸체로 구성되어 있다
    * 자바에서는 함수가 클래스를 떠나 존재할 수 없다
* 메서드는 객체의 기능을 구현하기 위해서 클래스 내부에 구현되는 함수이다

기존에 비해 문제 자체를 더 직접적으로 설명하고 있고, 메소드에 코드가 포함되어 있으므로 코드를 마음대로 전달할 수 있다.

객체를 참조를 이용하여 이리저리 주고받았던 것처럼 자바 8에서는 File::isHidden 같은 메서드 참조를 만들어 전달할 수 있게 되었다.

람다(또는 익명 함수) 를 이용하여 적절한  클래스나 메서드가 없을 경우 간결하게 구현할 수 도 있다.

``` 
(int x) -> x + 1
```














