# ORM이란?
Object-relational mapping의 약자이다. 한국어로 표현하자면 객체와 관계와의 설정으로 OOP에서 말하는 객체와 관계형 데이터베이스와의 설정이다

# 탄생배경
현대의 웹 어플리케이션에서 관계형 데이터베이스는 빠질 수 없는 요소이다. 그러다 보니 **객체를 관계형 데이터베이스에서 관리**하는 것이 중요해졌다.

하지만 관계형 데이터베이스는 SQL만 인식할 수 있기 때문에 각 테이블마다 많은 SQL문을 만들고 유지보수하는 어려움이 생겼다.

또한 **패러다임 불일치**  문제가 생겼다. 관계형 데이터베이스는 **어떻게 데이터를 저장할지**에 초점이 맞춰졌고, 객체지향 프로그래밍에서는 **메시지를 기반으로 기능과 속성을 한 곳에서 관리**하는 기술이다

두 언어의 사상부터가 다르기 때문에 패러다임 불일치가 생기게 된다

# 목적
* 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해준다
    * 객체 지향 프로그래밍은 클래스를 사용하고, 관계형 데이터베이스는 테이블을 사용한다
    * 객체 모델과 관계형 모델간의 관계 설정을 할 때 이질성이 발생하게 된다 
    * ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결한다
* 객체를 통해 간접적으로 데이터베이스 데이터를 다룬다

# ORM의 장단점

## 장점
* 객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다
    * ORM을 사용하면 SQL Query가 아닌 직관적인 코드로 데이터를 조작할 수 있어 개발자가 객체 모델로 프로그래밍하는 데 집중할 수 있도록 도와준다
    * 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다
    * 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다
    * SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다
* 재사용 및 유지보수의 편리성이 증가한다
    * ORM은 독립적으로 작성되어 있고, 해당 객체들을 재활용 할 수 있다
    * 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다
    * 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다
* DBMS에 대한 종속성이 줄어든다
    * 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하기 때문에 RDBMS의 데이터 구조와 Java의 객체지향 모델 사이의 간격을 좁힐 수 있다
    * 대부분 ORM 솔루션은 DB에 종속적이지 않다
    * 종속적이지 않다는 것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다 
    * 프로그래머는 Object에 집중함으로  극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다
    * 또한 자바에서 가공할 경우 equals, hashCode의 오버라이드 같은 자바의 기능을 활용할 수 있고, 간결하고 빠른 가공이 가능하다

## 단점 
* 완벽한 ORM 으로만 서비스를 구현하기가 어렵다
    * 사용하기는 편하지만 설계는 매우 신중하게 해야한다
    * 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다
    * 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다
    * 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다
    * DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)
* 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기가 어렵다 
    * 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다



### References
http://www.incodom.kr/ORM#h_702209f3f35878a32ee91352ddc6bbe7


# JPA 
JPA는 인터페이스로서 자바 표준명세서이다. 인터페이스인 JPA를 사용하기 위해서는 Hibernate, EclipseLink 등 구현체가 필요하다 

## Spring Data JPA 
구현체들을 좀 더 쉽게 사용하고자 추상화시킨 모듈 

Hibernate를 쓰는 것과 큰 차이는 없으나 두 가지 이유로 사용하는 것을 권장하고 있다

1. 구현체 교체의 용이성 
    * 구현체의 수명이 다해서 새로운 JPA 구현체가 대세로 떠오를 때 교체하기 쉽다
2. 저장소 교체의 용이성
    * 저장소를 바꿀 때 의존성만 교체하면 된다