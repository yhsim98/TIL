# TCP 세그먼트 개요
응용 프로세스 데이터 전송 과정
* 캡슐화를 거친다
    * 상위 계층 데이터에 헤더에 필요한 제어정보 추가해서 하위로 보내는 것
* application에서 TCP 로 내려오며 캡슐화가 되면 segment가 된다
* IP로 내려가면 datagram
* Ethernet으로 내려가면 frame

TCP 세그먼트
* 헤더 필드 + 데이터 필드
* 헤더 : manatory, 데이터 : optional
    * 헤더는 반드시 있어야 하지만, 데이터는 없을 수 있다

MSS(Maximum Segment Size)
* 데이터 필드에 포함되는 응용 메시지 조각의 최대크기
    * 세그먼트 데이터 가능한 최대 크기
* 데이터 링크의 MTU(Maximum Transmission Unit)에 의해 결정
* TCP 헤더 크기 + IP 헤더 크기 + MSS <= MT

## TCP 세그먼트 구성
![](http://www.ktword.co.kr/img_data/1889_1.JPG)

보통 필수 헤더정보는 20바이트이다

TCP 포트 번호(Port Number)
* 역할 : 응용 프로토콜 식별
* 클라이언트 포트 번호 : 연결 설정 시에 임의의 포트 번호 할당
* 서버 포트 번호 : 연결 설정 전에 미리 할당
    * 잘알려진 포트로 해야 함
* 출발지 포트 번호 : 세그먼트 송신자의 포트 번호, 16 비트 
* 목적지 포트 번호 : 세그먼트 수신자의 포트 번호, 16 비트

순서 번호
* 번호 부여 원칙 : 시작 순서 번호(ISN)부터 이미 송신된 바이트의 다음 바이트 번호(데이터의 첫번째 바이트 번호), 세그먼트 송신자에 의해 부여
    * 처음 연결할 때 결정한다
* ISN + 송신된 바이트수
* ISN : 3000, 송신된 바이트 수 : 1000 -> 순서번호 4000
* 세그먼트 번호가 아님

확인 번호
* 번호 부여 원칙 : 순서대로 수신된 세그먼트의 마지막 바이트의 다음 바이트 번호, 세그먼트 수신자에 의해 부여
    * 수신을 기대하는 세그먼트의 순서 번호이다
* 순서대로 수신된 세그먼트 순서 번호 + 수신 세그먼트 데이터 크기
* 세그먼트 순서 번호 : 4000, 데이터 : 1000 바이트 -> 확인 번호 = 5000
    * 순서 번호는 해당 번호부터 시작한다는 뜻이다
    * 해당 순서 포함이기 때문에 그냥 더하면 된다
* 누적 수신 확인
    * GO-Back-N은 누적 순서대로 들어오지 않는다면 ACK를 전송하지 않는다
    * TCP의 경우는 순서대로 들어오지 않더라도 ACK를 전송하지만, ACK의 확인번호를 가장 최근에 누적 순서대로 들어온 세그먼트의 확인번호를 전송한다  

헤더 길이 
* 헤더 필드 전체길이는 20~60 바이트, 4바이트 원드 단위로 표시

수신 윈도우 크기
* 수신 TCP가 수신 가능한 데이터 크기(버퍼 여유 공간)
* 수신 TCP가 ACK 세그먼트에 표시, 송신 윈도우 결정
* 최대 65535 바이트(16 비트 필드)

제어 플래그
* URG, ACK 등등

# TCP RTT
* 세그먼트 송신 후 ACK 수신까지 걸리는 시간
* 네트워크 상태에 따라 가변적인 시간

TCP의 RTT 추정
* 추정 RTT = (1 - a) * 기존 추정 RTT + a * 추정 RTT(새로 측정한 RTT)
* a = 0.125
* 지수이동가중평균

RTT 추정 예
* 시간에 따라 RTT 측정 : S1, S2, S3
* 초기 추정 RTT : RTT0
* RTT1 = 0.875 * RTT0 + 0.125 * S1
* 추정 RTT2 = 0.875 * RTT1 + 0.125 * S2
    * 0.875^2 * RTT0 + 0.875 * 0.125 * S1 + 0.125 * S2
    * 추정 올라가면 여기서 0.875만 추가로 곱해주면 됨

TCP RTT 분산 추정
* 분산 RTT = (1 - b) * 현재 분산 RTT + b * |측정 rtt - 추정 rtt|
* b = 0.25

재전송 타이머 값(Timeout)
* TimeoutInterval = EstimatedRTT + 4 * DevRTT
* 추정 RTT + 4 * 분산 RTT
    * 분산치에 4를 곱하는 이유는 적절한 시간 설정 때문


# TCP 연결
1 : 1 소켓 연결
* 연결 설정 과정(handshaking) 필요
* 서버 연결 소켓 : 서버 IP 주소와 서버 Port 번호 공유 가능
* 멀티캐스팅 지원 불가

Full-duplex(전이중) 통신
* 양방향 동시 세그먼트 전송
    * UDP는 단방향
* MSS : 세그먼트의 데이터 필드 최대 크기
* 송신 버퍼에서 MSS 단위로 송신

바이트 스트림(Byte Stream) 전송
* 송신 프로세스가 소켓의 송신 버퍼에 전달(write)한 바이트 스트림을 수신 소켓의 수신 버퍼에 순서대로 전송
* 송신 프로세스는 송신 버퍼에 임의의 크기의 바이트열을 씀, TCP는 세그먼트 단위(MSS)로 수신 버퍼에 전달, 수신 프로세스는 수신 버퍼에서 원하는 크기의 바이트열을 읽음

3-way handshake
* 클라이언트와 서버 간에 동기를 맞추는 과정
    * 소켓과 소켓간에 싱크를 맞춤
* 동기 정보 : 소켓 주소, 시작 순서 번호, 수신 윈도우 크기

SYN 세그먼트
* 일반적인 TCP 세그먼트에 헤더의 타입에 SYN 비트를 1로 설정
* 데이터가 없다
    * 하지만 가상적으로 한 바이트가 데이터가 있는 것처럼 설계
    * 가상적으로 함으로써 다음 데이터 전송 시 사용할 순서번호를 ACK로 반환해 줌
    * SYN 번호 + 1
* 연결 설정을 위해 클라이언트 TCP가 서버 TCP에 전송
* 시작 순서 번호(ISN) 설정
    * 무려 32비트
* ACK를 위해 순서번호 1 소비
    * 가상의 1 바이트 데이터 전송

SYN + ACK 세그먼트
* SYN 세그먼트를 수신한 서버 TCP가 클라이언트 TCP에 전송
* SYN 비트와 ACK 비트 1 설정
* 시작 순서 번호(ISN) 설정
* 확인 번호(ACK) 설정
    * SYN가 사용한 번호 + 1
    * SYN이 데이터 1바이트 있다고 가정하고 순서번호 하나 딸려 보냄
* 수신 윈도우 크기 설정
* ACK를 위해 순서번호 1 소비
    * 가상의 1바이트
* 이후 DATA 세그먼트 전송

ACK 세그먼트
* SYN + ACK 세그먼트를 받았다고 클라이언트에서 다시 서버로 전송
* 헤더에서 ACK 비트를 1로 설정
* 수신 윈도우 크기 설정
* 데이터 포함 가능
* 데이터 미포함 시에는 순서 번호 소비하지 않음
    * 가상의 1 바이트 추가하지 않는다
    * 이전의 SYN때 썼던 번호 재사용
* 이후 DATA 세그먼트 전송

# TCP 연결 해제
4-way Handshake 과정을 거친다.  
서로 FIN 보내고 ACK 보내서 4way, 서버도 연결을 끊고 싶다면 ACK와 FIN 같이 보낼 수 있음.

3-way Handshake
* 서버가 ACK FIN 합쳐서 보내서 3-way
* 클라이언트가 ACK 보낸다음 RTT가 있다가 종료된다.
    * ACK 가 손실될 수 있기 때문이다.


# TCP 세그먼트 전송 규칙
누적 수신확인
* 누적적으로 완전하게 수신된 바이트 스트림 번호 확인
* 중복 ACK 세그먼트 수신 가능

중복 ACK 
* 이미 수신한 확인번호를 가진 ACK

중복 ACK 수신
* 순서가 바뀐 세그먼트 도착
* 중간 세그먼트 손실

단일 타이머
* 누적 수신 확인이 되지 않은 가장 오래된 세그먼트에 대한 재전송 타이머 유지

# 재전송 기반 오류 복구
Timeout에 의한 재전송
* Timeout 동안 누적 ACK 미수신 세그먼트 재전송
* 누적 수신확인의 중요성
    * 만약 ACK 100과 120을 받아야 하는데 100 만왔으면 120을 받아야 하므로 재전송한다
    * 하지만 ACK 120이 도착했다면 수신자가 100과 120을 둘 다 받았기 때문에 120을 보낸 것이기 때문에 100을 재전송할 필요가 없다 
    * 그래서 ACK를 받지 못했다고 무조건 재전송하는 것은 아님

재전송하는 경우
* 라우터 버퍼 오버플로에 의한 세그먼트 손실
* 네트워크 혼잡 상황에 따른 버퍼 오버플로우 발생
* 충분히 긴 시간 동안 ACK 미수신

빠른 재전송
* 세그먼트가 손실된 상황에서 Timeout 까지 불필요한 긴 시간 대기 회피
* 3개 중복 ACK 도착하면 Timeout과 무관하게 누적 수신 확인 다음 세그먼트 재전송
* 수신자는 받은 세그먼트 버퍼에 저장했다가 중간에 손실된 세그먼트 도착하면 누적적으로 ACK 계산해서 전송

Timeout 전에 중복 ACK 발생 상황 이유
* 순서가 바뀐 세그먼트 도착
* 중간 세그먼트 손실

순서가 바뀐 세그먼트 도착
* 1 ~ 2개의 중복 ACK 후에 정상 ACK 회신
* 연속된 세그먼트의 도착 시간에 큰 차이가 없음
* 3개 이상의 중복 ACK 가 발생하면 순서 문제가 아니라 판단

중간 세그먼트 손실
* 라우터에 경미한 버퍼 오버플로우 발생
* 오버플로우 상황이 바로 개선되어 다음 세그먼트들은 정상 도착

# 흐름 제어
정의 
* 송신 TCP가 지나치게 많은 데이터를 한꺼번에 송신함으로써 수신 TCP의 버퍼가 넘쳐 데이터 손실이 발생하는 문제를 방지하는 메카니즘

방안
* 수신 TCP는 자신의 수신 버퍼내의 여유 공간의 크기를 송신 TCP에게 통지하고, 송신 TCP는 통지된 여유 공간의 크기 보다 적은 양의 데이터를 송신

수신 윈도우
* 수신 버퍼내의 여유 공간의 크기

수신윈도우 변화
* 연결 설정 시에 수신버퍼크기와 동일하게 설정
* 수신 데이터의 버퍼 저장과 응용 프로세스에 의한 버퍼 데이터 읽기 과정에서 수신 윈도우 변화

수신윈도우 통보
* 수신 TCP가 송신 TCP로 전달하는 세그먼트의 수신윈도우 필드에 포함되어 통보

송신 TCP의 흐름 제어
* 마지막으로 송신한 바이트 번호와 확인 세그먼트를 통해 마지막으로 수신 확인된 바이트 번호의 차이가 항상 수신윈도우 보다 작게 유지
* 마지막 송신 바이트 번호 - 마지막 수신 바이트 번호 <= 수신 윈도우

수신 윈도우 0
* 송신 TCP는 더 이상 데이터를 전송하지 않고 수신 TCP 로부터 변경된 수신윈도우가 도착 하길 기다림
* 수신 TCP는 송신 TCP로 전송할 확인 세그먼트가 없어 수신 윈도우 변화를 통보하지 못함
* Deadlock 상태 진입

윈도우 프로브(Probe) 세그먼트
* 수신윈도우가 0일 때 송신 TCP가 수신 TCP에게 주기적으로 전송하는 1 바이트 세그먼트
* 수신 TCP는 프로브 세그먼트에 대한 확인 세그먼트를 통해 최신 수신 윈도우 정보를 송신 TCP에게 제공

# TCP 혼잡제어
네트워크 혼잡
* 트래픽 증가로 인해 라우터/스위치 버퍼의 큐잉 지연시간 증가 및 오버플로우 발생

TCP의 네트워크 혼잡 인식
* 심각한 혼잡 : Timeout 발생
* 경미한 혼잡 : 중복 ACK 발생(3 duplicate ACKs)

TCP의 혼잡 제어 원리
* 세그먼트 전송률 축소 조정
    * 네트워크로 유입되는 트래픽 감축
    * 버퍼 오버플로 감소

흐름제어를 위한 TCP 전송률 제어
* 마지막 송신 바이트 번호 - 마지막 수신 확인 바이트 번호 <= 수신 윈도우

혼잡제어를 위한 TCP 전송률 제어
마지막 송신 바이트 번호 - 마지막 수신 확인 바이트 번호 <= min(수신 윈도우, 혼잡 윈도우)

# 슬로우 스타트
개념
* 연결 시작 또는 혼잡 발생시에 혼잡 윈도우를 최소값부터 전송률을 낮게(천천히) 시작
* ACK가 수신될 때마다 혼잡 윈도우 1씩 증가
* RTT 마다 혼잡윈도우 2배씩 증가
    * 한번에 여러 세그먼트 보내고 받은 ACK 만큼 증가하니 결국 RTT당 2배

# 혼잡 회피
개념
* 슬로우 스타트 구간에서 혼잡 윈도우는 지수적으로 증가
* 혼잡 윈도우가 임계치에 도달하거나 넘어가면 선형적으로 증가하도록 증가 속도를 조정하는 알고리즘
* RTT 마다 혼잡 윈도우를 1씩 증가(선형적)
* ACK가 수신될 때마다 혼잡윈도우를 (1 / 혼잡윈도우크기)씩 증가

# 빠른 복구
개념
* 3개의 중복 ACK에 의한 빠른 재전송 시에 적용 : 경미한 혼잡 상황
* 정상 ACK가 수신되어 오류 복구가 완료되면 슬로우 스타트 구간을 건너뛰고 혼잡 회피 단계로 진입

알고리즘
1. 임계치를 현재 혼잡 윈도우의 1/2로 설정
2. 손실된 세그먼트 재전송
3. 혼잡 윈도우를 임계치 + 3 으로 설정
4. 여전히 중복 ACK를 수신하면 혼잡윈도우 + 1
5. 정상 ACk를 수신하면 혼잡윈도우 = 임계치, 혼잡 회피 단계로 진입

# TCP 혼잡 제어 알고리즘 
## TCP Tahoe 버전
혼잡 인식 하는 경우
* Timeout
* 3개의 중복 ACK

알고리즘
* 임계치를 현재 혼잡 윈도우의 1/2로 설정
* 슬로우 스타트 개시
* 혼잡 윈도우가 임계치에 도달하거나 넘어가면 혼잡 회피 수행

## TCP Reno 버전
혼잡인식
* Timeout
* 3개 중복 ACK

알고리즘
* Timeout 발생시 Taho 버전과 동일
* 3개 중복 ACK 시는 빠른 회복 알고리즘 적용

