# 전송오류복구
정보 전송 단위
* IP, UDP : 데이터그램
* TCP : 세그먼트

세그먼트 구조
![](https://t1.daumcdn.net/cfile/tistory/994511465AF2DC262D)

## 세그먼트 오류
세그먼트 오류 
* 세그먼트 훼손 : 훼손된 세그먼트 도착(Checksum으로 확인)
    * 전송한 세그먼트와 다른 세그먼트가 도착
* 세그먼트 손실 : 세그먼트 미도착(중간 통신장치의 버퍼 오버플로우)

세그먼트 수신 확인
* 세그먼트 정상 수신 -> 수신확인(ACK) 세그먼트 회신
* 훼손 세그먼트 수신 -> 폐기 -> 미수신
* 세그먼트 미수신 -> 인지 불가

ACK
* 수신자가 데이터 세그먼트의 정상수신을 확인하기 위해 송신자에게 보내는 특수한 세그먼트
* 세그먼트의 헤더의 타입이 세그먼트비트가 0이 아닌 1

세그먼트 미수신 확인
* 세그먼트 전송 후 타이머 개시
* 타이머 종료시까지 ACK 미도착
    * 이 경우 훼손됬거나 미수신했다고 판단

타이머 설정
* RTT(Round Trip Time)과 연계된 함수
    * RTT : ACK가 돌아로기까지 시간
    * RTT보다는 길게 

오류 세그먼트 복구 절차
1. 세그먼트 전송, 타이머 시작
2. 세그먼트 타이머 종료시까지 ACK 미도착
3. 세그먼트를 재전송, 타이머 재시작

# Stop-and-Wait ARQ(Automatic Repeat Request)
송신자
1. 세그먼트 송신 후 복제본을 버퍼에 유지
2. 재전송 타이머 시작
3. 타이머 종료 전 ACK 수신 시 복제본 폐기, 타이머 종료
4. 타이머 종료 전 ACK 미수신 시 세그먼트 재전송, 타이머 재시작

수신자
1. 정상 세그먼트 수신 시 ACK 회신

문제점
* ACK 세그먼트에 오류 발생 시 중복 전송
* 수신자는 중복 세그먼트 여부 구분 불가

## SN
SN : 순서번호
* 각 세그먼트에 대한 순서 번호 : 동일 종류 세그먼트간 구분
* 송신 SN : 현재 송신 세그먼트 번호
* ACK SN : 다음 송신 세그먼트 번호(송신 SN + 1)
    * 송신자가 다음에 보낼 세그먼트 번호

SN 범위 : [0, 1]
* SN 필드 크기 : 1비트 
    * 0과 1만 있어도 된다
* Alternation Protocol


## Stop-and-Wait ARQ 문제점
SN 없는 경우
* ACK 세그먼트에 오류 발생 시 중복 전송
* 수신자는 중복 세그먼트 여부 구분 불가

SN 있는 경우
* ACK가 도착할 때까지 전송 대기
* 대기 시간동안 링크 미사용 -> 링크 사용률 저하
    * ACK를 기다리는 동안 링크 사용하지 못한다
* 결국 링크 효율이 낮아 실제로 사용하기는 어렵다

링크 효율
* 세그먼트 크기 : 1000비트
* 링크 전송속도 : 1Mbps
* RTT : 20ms
* 20ms 동안 송신 가능 비트수 : 1000000/s * 0.02s = 20000비트
    * 링크 전송속도 * 시간
* 20ms 동안 실제 송신 비트수 : 1000비트
    * Stop-and-Wait 시
* 링크 효율 : 1000/20000 = 0.05(5%)

# 파이프라이닝(Pipelinig)
개념
* ACK가 회신 되기전 RTT 동안 링크에 M개의 세그먼트를 전송

장점
* 링크 효율 제고(stop-and-wait 보다 M배 높은 효율)

요구사항
* 최대 파이프라이닝 세그먼트의 수 M(송신 윈도우) 보다 큰 순서번호 사용
    * 송신 윈도우의 범위가 0~4라면 0의 ACK를 수신하면 1~5, 1의 ACK를 수신하면 2~6 이렇게 크기는 일정하게 유지한다
* SN(sequence number) 필드 m 비트 : 2^m > M
    * m 비트가 표현할 수 있는 수보다 작아야 하니까
* 순서번호 : [0, 2^m - 1], mod 2^m

## 파이프라이닝 오류복구 유형
* Go-back-N ARQ
* Selective-Repeat ARQ


# Go-Back-N ARQ
오류 세그먼트부터 이후의 모든 세그먼트 재전송

## 송신자 동작 절차
1. ACK가 회신 되는 RTT 동안 링크에 최대 M개의 세그먼트를 전송하고 **버퍼**에 유지(송신 윈도우 = M)
    * ACK가 안오면 재전송해야하니 버퍼에 저장
2. 첫 번째 세그먼트의 ACK 수신하면 해당 세그먼트(첫 번째 세그먼트)을 버퍼에서 제거하고 송신가능 순서번호 범위를 1씩 이동(송신 윈도우 슬라이딩)
    * 앞에서부터 순서대로 슬라이딩
    * 슬라이딩 후 새로 송신 윈도우에 들어온 세그먼트는 바로 송신
    * 물론 앞의 세그먼트 중 하나라도 loss되어 수신자가 제대로 전달받지 못하였다면 누적 수신확인에 따라 수신자는 전부 폐기한다
3. 세그먼트 재전송 타이머가 종료될 때까지 ACK가 수신되지 않으면 해당 세그먼트부터 송신 윈도우의 모든 세그먼트 재전송
    * 버퍼에 있는 것들
    * 송신 윈도우에 있는 세그먼트중 하나라도 타임아웃되면 송신 윈도우에 있는 모든 세그먼트를 즉시 전부 재전송

## 송신 윈도우(send window)
* 송신가능 순서번호 범위
* 송신 후 버퍼에 유지되어야 할 세그먼트의 범위

## 송신자 버퍼 관리
* Ssize : 송신 슬라이딩 윈도우 크기
    * ACK 없이 송신가능한 최대 세그먼트의 수
    * Ssize = 2^m - 1, m은 SN의 비트수
* Sf : ACK가 수신되지 않은 첫 번째 세그먼트 순서번호
    * ACK가 수신될 때마다 Sf = (Sf + 1) mod 2^m
    * 0 ~ 3 라면 0을 의미
* Sn : 다음 송신 세그먼트 순서번호
    * 세그먼트를 송신할 때마다 Sn = (Sn + 1) mod 2^m
    * 0 ~ 3 라면 4 또는 0을 의미
    * 2비트면 0으로 돌아감

 송신 버퍼
 * [Sf, Sn - 1] 세그먼트를 재전송을 위해 버퍼에 유지

## 수신자
수신자 동작 절차
* 다음 순서번호 Rn의 세그먼트를 정상적으로 수신하면 ACK(Rn + 1) 회신
* 다음 순서번호 Rn이 아닌 모든 세그먼트는 폐기
    * Rn 인 세그먼트가 들어올때 까지 모든 세그먼트를 폐기한다
    * 수신자가 0 ~ 5 를 보냈는데 3만 도착했을 경우 0이 도착하지 않았으니 3은 폐기한다
* 이런 수신 방식을 누적 수신확인
    * 누적적으로 정상적으로 수신이 됬을때만 ACK를 보낸다


수신자 버퍼 관리 
* Rn : 다음에 수신할 세그먼트의 순서번호
* 세그먼트가 수신될 때마다 Rn = (Rn + 1) mod 2^m
* 수신 원도우 크기 : 1
* 수신자 버퍼 크기 : 1

## 송신 윈도우 최대 크기
송신 윈도우의 최대 크기는 2^m - 1이다.

2^m이 아닌 이유가 있다.

2^n일 경우 만약 수신자가 모든 세그먼트를 정상 수신하여 ACK을 회신하였으나 모든 ACK가 로스된 경우, 수신자는 정상 수신했으니 다음 와야 할 순서는 0이고 송신자는 ACK를 받지 못했으니 다시 0부터 보내게 된다.

이 경우 수신자는 0번을 수신하는게 맞기 때문에 이게 재전송인지 구별할 방법이 없다. 따라서 순서의 최대 범위는 2^n - 1이 된다.

## 장단점
장점
* Stop-and-wait 대비 고효율성
* 간단한 수신자 버퍼 관리(다음 세그먼트 수신용 버퍼)

단점
* 오류 세그먼트 이후 도착한 정상 세그먼트 재전송
    * 불필요한 재전송 회수 증가
    * 링크 효율 저하

# Selected Repeat ARQ
오류 세그먼트만 재전송하는 ARQ

송신자
1. ACK가 회신되는 RTT 동안 링크에 최대로 송신 윈도우 크기인 Ssize 개의 세그먼트를 전송
2. 누적 ACK 수신하면 송신 윈도우를 누적 ACK 수만큼 이동
3. 비누적 ACK 수신하면 해당 세그먼트의 ACK 수신 사실 기록
4. 세그먼트 재전송 타이머가 종료될 때까지 ACK가 수신되지 않으면 해당 세그먼트 재전송
    * GO BACK N 과 달리 ACK를 못받은 세그먼트만 재전송

송신 윈도우
* 송신가능 순서번호 범위
* 송신 후 버퍼에 유지되어야 할 세그먼트의 범위
* 크기는 2^(m - 1)
 
누적 ACK
* 송신 윈도우 내에서 누적적으로 순서 번호가 맞는 ACK
* 현재 송신 윈도우에서 가장 앞에 있는 세그먼트 번호 

비누적 ACK
* 송신 윈도우 내에서 누적적으로 순서 번호가 맞지 않는 ACK

수신자 동작 절차
1. 송신 윈도우와 동일한 크기의 수신 윈도우 Rsize 유지
2. 누적 정상 세그먼트를 수신하면 ACK 회신하고 누적 정상 세그먼트 수만큼 수신 윈도우 이동
3. 비누적 정상 세그먼트를 수신하면 ACK 회신하고 해당 세그먼트를 받았다고 버퍼에 유지
4. 만약 수신 위도우에 있는 ACK가 아니라면 그것은 재전송된 세그먼트이다

수신 윈도우
* 수신 가능한 세그먼트의 범위
* 송신 윈도우 크기와 동일
* 크기는 2^(m - 1)
* 만약 수신 위도우에 있는 ACK가 아니라면 그것은 재전송된 세그먼트이다


수신자 버퍼 관리
* 비누적 정상 세그먼트를 수신 버퍼에 유지
* 다음 수신 가능 세그먼트 : 수신 버퍼에 유지되고 있지 않은 수신 윈도우내의 모든 세그먼트


송신 윈도우 최대 크기
* SN 필드 크기가 m 비트일 때 송신 위도우 크기 : 2^(m - 1)
* 모든 오류 세그먼트가 오류가 났다면 2^n - 1 이면 문제가 일어난다
